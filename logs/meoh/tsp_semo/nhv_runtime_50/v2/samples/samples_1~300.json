[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8699061134713162,
            1.7563723921775818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8699061134713162,
            1.7563723921775818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8699061134713162,
            1.7563723921775818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8538669113195256,
            2.396012008190155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and crowding distance, then applies a novel local search operator that combines 2-opt with a dynamic segment reversal strategy to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and crowding distance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    def crowding_distance(solutions):\n        if len(solutions) == 1:\n            return [float('inf')]\n\n        distances = [0] * len(solutions)\n        objectives = np.array([obj for _, obj in solutions])\n\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n\n            for j in range(1, len(solutions) - 1):\n                if objectives[sorted_idx[-1], i] == objectives[sorted_idx[0], i]:\n                    continue\n                distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n        return distances\n\n    # Filter non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    # Select based on crowding distance\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    for _ in range(2):  # Number of attempts\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        if len(segment) > 1:\n            if np.random.rand() < 0.5:\n                new_solution[a:b+1] = segment[::-1]  # Reverse segment\n            else:\n                # Rotate segment\n                k = np.random.randint(1, len(segment))\n                new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5810687446721519,
            2.11182177066803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and crowding distance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    def crowding_distance(solutions):\n        if len(solutions) == 1:\n            return [float('inf')]\n\n        distances = [0] * len(solutions)\n        objectives = np.array([obj for _, obj in solutions])\n\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n\n            for j in range(1, len(solutions) - 1):\n                if objectives[sorted_idx[-1], i] == objectives[sorted_idx[0], i]:\n                    continue\n                distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n        return distances\n\n    # Filter non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    # Select based on crowding distance\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reversal\n    for _ in range(2):  # Number of attempts\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        if len(segment) > 1:\n            if np.random.rand() < 0.5:\n                new_solution[a:b+1] = segment[::-1]  # Reverse segment\n            else:\n                # Rotate segment\n                k = np.random.randint(1, len(segment))\n                new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search operator combines adaptive segment reversal with multi-objective edge swapping, dynamically prioritizing edges with high marginal gain in either objective space while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective improvement potential\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with multi-objective edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment reversal\n    segment_start = np.random.randint(0, n - 3)\n    segment_end = np.random.randint(segment_start + 2, n - 1)\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(min(3, n // 2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate potential improvement in both objectives\n            old_edges = [\n                (base_solution[i], base_solution[(i+1)%n]),\n                (base_solution[j], base_solution[(j+1)%n])\n            ]\n            new_edges = [\n                (base_solution[i], base_solution[j]),\n                (base_solution[(i+1)%n], base_solution[(j+1)%n])\n            ]\n\n            old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]]) + \\\n                       (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n            new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) + \\\n                       (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8684608871909816,
            4.807967245578766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective improvement potential\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment reversal with multi-objective edge swapping\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment reversal\n    segment_start = np.random.randint(0, n - 3)\n    segment_end = np.random.randint(segment_start + 2, n - 1)\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(min(3, n // 2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate potential improvement in both objectives\n            old_edges = [\n                (base_solution[i], base_solution[(i+1)%n]),\n                (base_solution[j], base_solution[(j+1)%n])\n            ]\n            new_edges = [\n                (base_solution[i], base_solution[j]),\n                (base_solution[(i+1)%n], base_solution[(j+1)%n])\n            ]\n\n            old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]]) + \\\n                       (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n            new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) + \\\n                       (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This heuristic selects a solution from the archive based on a weighted combination of its objective values and applies a novel hybrid local search that combines 3-opt with a greedy insertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to weights\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=0) + 1e-6)  # Avoid division by zero\n    probs = (weights * objectives).sum(axis=1)\n    probs = probs / probs.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with greedy insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes to apply 3-opt\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment\n\n    # Greedy insertion for further improvement\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        # Randomly select a node to reinsert\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n\n        # Remove node from current position\n        new_solution = np.delete(new_solution, idx)\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            # Insert node at position pos\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert node at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8429014814038451,
            14.786134600639343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to weights\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives.sum(axis=0) + 1e-6)  # Avoid division by zero\n    probs = (weights * objectives).sum(axis=1)\n    probs = probs / probs.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with greedy insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes to apply 3-opt\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment\n\n    # Greedy insertion for further improvement\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        # Randomly select a node to reinsert\n        idx = random.randint(0, n-1)\n        node = new_solution[idx]\n\n        # Remove node from current position\n        new_solution = np.delete(new_solution, idx)\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            # Insert node at position pos\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert node at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines segment rotation and node swapping to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (avoiding crowding)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel local search: segment rotation and node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Rotate segment\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated\n\n    # Swap nodes\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8612178823076186,
            1.8124579787254333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (avoiding crowding)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel local search: segment rotation and node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Rotate segment\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated\n\n    # Swap nodes\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution with the best combined objective value from the archive, then applies a novel local search combining segment rotation and node swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment rotation: rotate a segment of the tour by a random amount\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, n-segment_start)\n    rotation = np.random.randint(1, segment_length)\n    segment = new_solution[segment_start:segment_start+segment_length]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    # Node swapping: swap two non-adjacent nodes\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    while abs(i - j) <= 1:  # Ensure they are not adjacent\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7920736131560024,
            1.8933271169662476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment rotation: rotate a segment of the tour by a random amount\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, n-segment_start)\n    rotation = np.random.randint(1, segment_length)\n    segment = new_solution[segment_start:segment_start+segment_length]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    # Node swapping: swap two non-adjacent nodes\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    while abs(i - j) <= 1:  # Ensure they are not adjacent\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based local search\n    if n > 3:\n        # Randomly select a segment and reverse it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Objective-aware edge selection: replace the worst edge in one objective with the best edge in the other\n        if random.random() < 0.7:\n            # Calculate edge costs\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Find worst edge in first objective and best edge in second objective\n            worst_edge_idx = np.argmax(edges_1)\n            best_edge_idx = np.argmin(edges_2)\n\n            if worst_edge_idx != best_edge_idx:\n                # Swap the edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n                new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.910375021268472,
            3.0046005845069885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based local search\n    if n > 3:\n        # Randomly select a segment and reverse it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Objective-aware edge selection: replace the worst edge in one objective with the best edge in the other\n        if random.random() < 0.7:\n            # Calculate edge costs\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Find worst edge in first objective and best edge in second objective\n            worst_edge_idx = np.argmax(edges_1)\n            best_edge_idx = np.argmin(edges_2)\n\n            if worst_edge_idx != best_edge_idx:\n                # Swap the edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n                new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based local search\n    if n > 3:\n        # Randomly select a segment and reverse it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Objective-aware edge selection: replace the worst edge in one objective with the best edge in the other\n        if random.random() < 0.7:\n            # Calculate edge costs\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Find worst edge in first objective and best edge in second objective\n            worst_edge_idx = np.argmax(edges_1)\n            best_edge_idx = np.argmin(edges_2)\n\n            if worst_edge_idx != best_edge_idx:\n                # Swap the edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n                new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.910375021268472,
            3.0046005845069885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based local search\n    if n > 3:\n        # Randomly select a segment and reverse it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Objective-aware edge selection: replace the worst edge in one objective with the best edge in the other\n        if random.random() < 0.7:\n            # Calculate edge costs\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Find worst edge in first objective and best edge in second objective\n            worst_edge_idx = np.argmax(edges_1)\n            best_edge_idx = np.argmin(edges_2)\n\n            if worst_edge_idx != best_edge_idx:\n                # Swap the edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n                new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node swapping and path inversion to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7955966381861111,
            1.4673603177070618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node swapping and path inversion to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7955966381861111,
            1.4673603177070618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This algorithm first selects the solution with the highest combined objective value from the archive, then applies a novel hybrid local search that combines a multi-segment shuffle with an adaptive edge exchange strategy to balance improvements across both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle: randomly select 4 segments and rearrange them\n    if n >= 6:\n        points = sorted(random.sample(range(1, n-1), 3))\n        a, b, c = points[0], points[1], points[2]\n        segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge exchange: exchange edges between objectives based on their relative performance\n    for _ in range(min(3, n//2)):\n        # Find edge with worst performance in combined objectives\n        edge_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_scores.append(cost1 + cost2)\n\n        worst_edge = np.argmax(edge_scores)\n\n        # Find best edge in the other objective\n        if random.random() < 0.5:\n            # Compare with first objective\n            best_edge = np.argmin([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        else:\n            # Compare with second objective\n            best_edge = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge != best_edge:\n            # Exchange the edges\n            temp = new_solution[worst_edge]\n            new_solution[worst_edge] = new_solution[best_edge]\n            new_solution[best_edge] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9109294444579568,
            2.8051836490631104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle: randomly select 4 segments and rearrange them\n    if n >= 6:\n        points = sorted(random.sample(range(1, n-1), 3))\n        a, b, c = points[0], points[1], points[2]\n        segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge exchange: exchange edges between objectives based on their relative performance\n    for _ in range(min(3, n//2)):\n        # Find edge with worst performance in combined objectives\n        edge_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_scores.append(cost1 + cost2)\n\n        worst_edge = np.argmax(edge_scores)\n\n        # Find best edge in the other objective\n        if random.random() < 0.5:\n            # Compare with first objective\n            best_edge = np.argmin([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        else:\n            # Compare with second objective\n            best_edge = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge != best_edge:\n            # Exchange the edges\n            temp = new_solution[worst_edge]\n            new_solution[worst_edge] = new_solution[best_edge]\n            new_solution[best_edge] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This algorithm first selects the solution with the highest combined objective value from the archive, then applies a novel hybrid local search that combines a multi-segment shuffle with an adaptive edge exchange strategy to balance improvements across both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle: randomly select 4 segments and rearrange them\n    if n >= 6:\n        points = sorted(random.sample(range(1, n-1), 3))\n        a, b, c = points[0], points[1], points[2]\n        segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge exchange: exchange edges between objectives based on their relative performance\n    for _ in range(min(3, n//2)):\n        # Find edge with worst performance in combined objectives\n        edge_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_scores.append(cost1 + cost2)\n\n        worst_edge = np.argmax(edge_scores)\n\n        # Find best edge in the other objective\n        if random.random() < 0.5:\n            # Compare with first objective\n            best_edge = np.argmin([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        else:\n            # Compare with second objective\n            best_edge = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge != best_edge:\n            # Exchange the edges\n            temp = new_solution[worst_edge]\n            new_solution[worst_edge] = new_solution[best_edge]\n            new_solution[best_edge] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9109294444579568,
            2.8051836490631104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle: randomly select 4 segments and rearrange them\n    if n >= 6:\n        points = sorted(random.sample(range(1, n-1), 3))\n        a, b, c = points[0], points[1], points[2]\n        segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge exchange: exchange edges between objectives based on their relative performance\n    for _ in range(min(3, n//2)):\n        # Find edge with worst performance in combined objectives\n        edge_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_scores.append(cost1 + cost2)\n\n        worst_edge = np.argmax(edge_scores)\n\n        # Find best edge in the other objective\n        if random.random() < 0.5:\n            # Compare with first objective\n            best_edge = np.argmin([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        else:\n            # Compare with second objective\n            best_edge = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge != best_edge:\n            # Exchange the edges\n            temp = new_solution[worst_edge]\n            new_solution[worst_edge] = new_solution[best_edge]\n            new_solution[best_edge] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects a solution from the archive based on its balance between the two objectives, then applies a novel segment rotation and edge inversion strategy to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (avoiding extreme solutions)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Rotate the segment left or right\n    segment = new_solution[a:b+1]\n    if np.random.rand() < 0.5:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n    new_solution[a:b+1] = segment\n\n    # Edge inversion: invert a random edge's direction in one of the objective spaces\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        # Decide which objective space to invert based on their relative costs\n        if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[j]]:\n            # Invert in the first objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Invert in the second objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8725059522764755,
            1.911516010761261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (avoiding extreme solutions)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Rotate the segment left or right\n    segment = new_solution[a:b+1]\n    if np.random.rand() < 0.5:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n    new_solution[a:b+1] = segment\n\n    # Edge inversion: invert a random edge's direction in one of the objective spaces\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        # Decide which objective space to invert based on their relative costs\n        if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[j]]:\n            # Invert in the first objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Invert in the second objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{The new algorithm combines a multi-segment inversion strategy with a bi-objective edge balancing approach, where it randomly selects multiple segments of the tour to invert their order and then balances edges by swapping those with the highest imbalance between the two objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select multiple segments to invert\n    num_segments = random.randint(2, min(5, n // 3))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments))\n\n    # Invert each selected segment\n    for i in range(0, len(segment_indices), 2):\n        if i + 1 >= len(segment_indices):\n            break\n        start = segment_indices[i]\n        end = segment_indices[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Balance edges by swapping those with the highest imbalance\n    edge_imbalance = []\n    for i in range(n-1):\n        d1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        d2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        imbalance = abs(d1 - d2)\n        edge_imbalance.append(imbalance)\n\n    # Find edges with highest imbalance and swap them\n    if len(edge_imbalance) > 0:\n        worst_edges = np.argsort(edge_imbalance)[-min(3, len(edge_imbalance)):]\n        for edge in worst_edges:\n            if random.random() < 0.5:\n                # Swap the nodes connected by this edge\n                new_solution[edge], new_solution[edge+1] = new_solution[edge+1], new_solution[edge]\n\n    return new_solution\n\n",
        "score": [
            -0.8121307019660625,
            1.9105343222618103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select multiple segments to invert\n    num_segments = random.randint(2, min(5, n // 3))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments))\n\n    # Invert each selected segment\n    for i in range(0, len(segment_indices), 2):\n        if i + 1 >= len(segment_indices):\n            break\n        start = segment_indices[i]\n        end = segment_indices[i+1]\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Balance edges by swapping those with the highest imbalance\n    edge_imbalance = []\n    for i in range(n-1):\n        d1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        d2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        imbalance = abs(d1 - d2)\n        edge_imbalance.append(imbalance)\n\n    # Find edges with highest imbalance and swap them\n    if len(edge_imbalance) > 0:\n        worst_edges = np.argsort(edge_imbalance)[-min(3, len(edge_imbalance)):]\n        for edge in worst_edges:\n            if random.random() < 0.5:\n                # Swap the nodes connected by this edge\n                new_solution[edge], new_solution[edge+1] = new_solution[edge+1], new_solution[edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9662488277056771,
            2.1520274877548218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9662488277056771,
            2.1520274877548218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9007364160133648,
            0.9141827821731567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9007364160133648,
            0.9141827821731567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel edge-reversal strategy: Reverse segments based on edge dominance in both objectives\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    # Reverse segment2 if it improves the combined objective\n    reversed_segment = segment2[::-1]\n    temp_solution = np.concatenate([segment1, reversed_segment, segment3])\n    temp_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n    temp_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n\n    if temp_cost1 + temp_cost2 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)):\n        new_solution = temp_solution\n\n    # Multi-objective crossover: Combine segments from the best solutions in each objective\n    best_solution_obj1 = min(archive, key=lambda x: x[1][0])[0]\n    best_solution_obj2 = min(archive, key=lambda x: x[1][1])[0]\n\n    # Randomly select a segment from each best solution and merge\n    c = random.randint(1, n-2)\n    new_solution[:c] = best_solution_obj1[:c]\n    new_solution[c:] = best_solution_obj2[c:]\n\n    # Ensure no duplicates and all nodes are visited\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8823841385212132,
            1.596308171749115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel edge-reversal strategy: Reverse segments based on edge dominance in both objectives\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    # Reverse segment2 if it improves the combined objective\n    reversed_segment = segment2[::-1]\n    temp_solution = np.concatenate([segment1, reversed_segment, segment3])\n    temp_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n    temp_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1))\n\n    if temp_cost1 + temp_cost2 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)):\n        new_solution = temp_solution\n\n    # Multi-objective crossover: Combine segments from the best solutions in each objective\n    best_solution_obj1 = min(archive, key=lambda x: x[1][0])[0]\n    best_solution_obj2 = min(archive, key=lambda x: x[1][1])[0]\n\n    # Randomly select a segment from each best solution and merge\n    c = random.randint(1, n-2)\n    new_solution[:c] = best_solution_obj1[:c]\n    new_solution[c:] = best_solution_obj2[c:]\n\n    # Ensure no duplicates and all nodes are visited\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its balance between the two objectives, then applies a novel segment rotation and edge inversion strategy to explore diverse neighborhoods while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (avoiding extreme solutions)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Rotate the segment left or right\n    segment = new_solution[a:b+1]\n    if np.random.rand() < 0.5:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n    new_solution[a:b+1] = segment\n\n    # Edge inversion: invert a random edge's direction in one of the objective spaces\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        # Decide which objective space to invert based on their relative costs\n        if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[j]]:\n            # Invert in the first objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Invert in the second objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive based on dominance and diversity, then applies a novel segment reversal and edge swap strategy to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good dominance and diversity\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    segment = segment[::-1]\n    new_solution[a:b+1] = segment\n\n    # Edge swap: swap two random edges in one of the objective spaces\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            if distance_matrix_1[new_solution[i], new_solution[i+1]] > distance_matrix_2[new_solution[i], new_solution[i+1]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8960835301239399,
            1.5831355452537537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good dominance and diversity\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    segment = segment[::-1]\n    new_solution[a:b+1] = segment\n\n    # Edge swap: swap two random edges in one of the objective spaces\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            if distance_matrix_1[new_solution[i], new_solution[i+1]] > distance_matrix_2[new_solution[i], new_solution[i+1]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel scoring function that considers both objective values and tour structure, then applies a hybrid local search combining edge swaps and segment insertions to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel scoring function: combine objective values and tour structure\n    def score(sol, obj):\n        tour_length = obj[0] + obj[1]\n        diversity = len(set(sol[:len(sol)//2])) / len(sol)\n        return tour_length * (1 + diversity)\n\n    # Select solution with highest score\n    selected_solution, selected_obj = min(archive, key=lambda x: score(x[0], x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: edge swap and segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Edge swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment insertion\n    segment = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.870245793701657,
            2.479925036430359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel scoring function: combine objective values and tour structure\n    def score(sol, obj):\n        tour_length = obj[0] + obj[1]\n        diversity = len(set(sol[:len(sol)//2])) / len(sol)\n        return tour_length * (1 + diversity)\n\n    # Select solution with highest score\n    selected_solution, selected_obj = min(archive, key=lambda x: score(x[0], x[1]))\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: edge swap and segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Edge swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment insertion\n    segment = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines segment rotation and node swapping to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (avoiding crowding)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel local search: segment rotation and node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Rotate segment\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated\n\n    # Swap nodes\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality metrics, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective and quality metrics\n    def score_func(sol_obj):\n        sol, obj = sol_obj\n        # Weighted sum of objectives and solution quality\n        obj_score = 0.6 * obj[0] + 0.4 * obj[1]\n        sol_quality = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol))) + \\\n                      sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        return obj_score + 0.2 * sol_quality\n\n    selected_solution = min(archive, key=score_func)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: edge swaps and segment reversals\n    if np.random.random() < 0.7:\n        # Edge swap\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8252923339756839,
            3.485226273536682
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective and quality metrics\n    def score_func(sol_obj):\n        sol, obj = sol_obj\n        # Weighted sum of objectives and solution quality\n        obj_score = 0.6 * obj[0] + 0.4 * obj[1]\n        sol_quality = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol))) + \\\n                      sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        return obj_score + 0.2 * sol_quality\n\n    selected_solution = min(archive, key=score_func)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: edge swaps and segment reversals\n    if np.random.random() < 0.7:\n        # Edge swap\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based local search\n    if n > 3:\n        # Randomly select a segment and reverse it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Objective-aware edge selection: replace the worst edge in one objective with the best edge in the other\n        if random.random() < 0.7:\n            # Calculate edge costs\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Find worst edge in first objective and best edge in second objective\n            worst_edge_idx = np.argmax(edges_1)\n            best_edge_idx = np.argmin(edges_2)\n\n            if worst_edge_idx != best_edge_idx:\n                # Swap the edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n                new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node swapping and path inversion to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel local search operator that combines edge swapping with a multi-objective path optimization step to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective improvement potential\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n        # Calculate potential improvements\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective path optimization step\n    if n > 4:\n        k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segment = new_solution[k:l]\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        current_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try reversing the segment\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept if at least one objective improves\n        if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n            new_solution[k:l] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9306072013654729,
            2.5660301446914673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective improvement potential\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n        # Calculate potential improvements\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective path optimization step\n    if n > 4:\n        k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segment = new_solution[k:l]\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        current_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try reversing the segment\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept if at least one objective improves\n        if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n            new_solution[k:l] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its balance between the two objectives, then applies a novel segment rotation and edge inversion strategy to explore diverse neighborhoods while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (avoiding extreme solutions)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Rotate the segment left or right\n    segment = new_solution[a:b+1]\n    if np.random.rand() < 0.5:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n    new_solution[a:b+1] = segment\n\n    # Edge inversion: invert a random edge's direction in one of the objective spaces\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        # Decide which objective space to invert based on their relative costs\n        if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[j]]:\n            # Invert in the first objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Invert in the second objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its balance between the two objectives, then applies a novel segment rotation and edge inversion strategy to explore diverse neighborhoods while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (avoiding extreme solutions)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Rotate the segment left or right\n    segment = new_solution[a:b+1]\n    if np.random.rand() < 0.5:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n    new_solution[a:b+1] = segment\n\n    # Edge inversion: invert a random edge's direction in one of the objective spaces\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        # Decide which objective space to invert based on their relative costs\n        if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[j]]:\n            # Invert in the first objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Invert in the second objective space\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects a solution from the archive based on its balance between the two objectives, then applies a novel segment reversal and cross-segment insertion strategy to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Cross-segment insertion: insert a node from one segment into another\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i in range(a, b+1) and j in range(a, b+1)):\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9523533748278308,
            2.3737921714782715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Cross-segment insertion: insert a node from one segment into another\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i in range(a, b+1) and j in range(a, b+1)):\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node swapping and path inversion to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node relocation and segment rotation to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9661306278414334,
            2.6444557309150696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based local search\n    if n > 3:\n        # Randomly select a segment and reverse it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Objective-aware edge selection: replace the worst edge in one objective with the best edge in the other\n        if random.random() < 0.7:\n            # Calculate edge costs\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Find worst edge in first objective and best edge in second objective\n            worst_edge_idx = np.argmax(edges_1)\n            best_edge_idx = np.argmin(edges_2)\n\n            if worst_edge_idx != best_edge_idx:\n                # Swap the edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n                new_solution[best_edge_idx] = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based local search\n    if n > 3:\n        # Randomly select a segment and reverse it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Objective-aware edge selection: replace the worst edge in one objective with the best edge in the other\n        if random.random() < 0.7:\n            # Calculate edge costs\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Find worst edge in first objective and best edge in second objective\n            worst_edge_idx = np.argmax(edges_1)\n            best_edge_idx = np.argmin(edges_2)\n\n            if worst_edge_idx != best_edge_idx:\n                # Swap the edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n                new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The new algorithm will use a combination of segment-based local search with objective-aware edge selection, but with a novel approach of dynamically adjusting the segment size based on the solution's quality and applying a probabilistic edge swap that considers both objectives to improve the Pareto front balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 2)])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    if n > 3:\n        # Dynamically determine segment size based on solution length\n        segment_size = max(2, min(5, n // 4))\n        a = random.randint(1, n - segment_size - 1)\n        b = a + segment_size\n\n        # Apply a more complex segment transformation: rotate instead of reverse\n        segment = new_solution[a:b]\n        rotation = random.randint(1, segment_size - 1)\n        new_solution[a:b] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Probabilistic edge swap considering both objectives\n        if random.random() < 0.8:\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Calculate edge quality scores combining both objectives\n            edge_scores = [edges_1[i] + edges_2[i] for i in range(n-1)]\n            worst_edge_idx = np.argmax(edge_scores)\n\n            # Find the best edge in the opposite objective\n            opposite_edges = [edges_1[i] if i % 2 == 0 else edges_2[i] for i in range(n-1)]\n            best_opposite_idx = np.argmin(opposite_edges)\n\n            if worst_edge_idx != best_opposite_idx:\n                # Perform a more complex swap involving multiple edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_opposite_idx]\n                new_solution[best_opposite_idx] = temp\n\n                # Additional local improvement: swap adjacent nodes if beneficial\n                if worst_edge_idx > 0 and worst_edge_idx < n-2:\n                    cost_before = edges_1[worst_edge_idx-1] + edges_1[worst_edge_idx] + edges_2[worst_edge_idx-1] + edges_2[worst_edge_idx]\n                    new_solution[worst_edge_idx], new_solution[worst_edge_idx+1] = new_solution[worst_edge_idx+1], new_solution[worst_edge_idx]\n                    cost_after = distance_matrix_1[new_solution[worst_edge_idx-1], new_solution[worst_edge_idx]] + \\\n                                 distance_matrix_1[new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]] + \\\n                                 distance_matrix_2[new_solution[worst_edge_idx-1], new_solution[worst_edge_idx]] + \\\n                                 distance_matrix_2[new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]]\n                    if cost_after > cost_before:\n                        new_solution[worst_edge_idx], new_solution[worst_edge_idx+1] = new_solution[worst_edge_idx+1], new_solution[worst_edge_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7804936317402209,
            2.1747962832450867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = random.choice(archive_sorted[:max(1, len(archive) // 2)])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    if n > 3:\n        # Dynamically determine segment size based on solution length\n        segment_size = max(2, min(5, n // 4))\n        a = random.randint(1, n - segment_size - 1)\n        b = a + segment_size\n\n        # Apply a more complex segment transformation: rotate instead of reverse\n        segment = new_solution[a:b]\n        rotation = random.randint(1, segment_size - 1)\n        new_solution[a:b] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Probabilistic edge swap considering both objectives\n        if random.random() < 0.8:\n            edges_1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n            edges_2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n            # Calculate edge quality scores combining both objectives\n            edge_scores = [edges_1[i] + edges_2[i] for i in range(n-1)]\n            worst_edge_idx = np.argmax(edge_scores)\n\n            # Find the best edge in the opposite objective\n            opposite_edges = [edges_1[i] if i % 2 == 0 else edges_2[i] for i in range(n-1)]\n            best_opposite_idx = np.argmin(opposite_edges)\n\n            if worst_edge_idx != best_opposite_idx:\n                # Perform a more complex swap involving multiple edges\n                temp = new_solution[worst_edge_idx]\n                new_solution[worst_edge_idx] = new_solution[best_opposite_idx]\n                new_solution[best_opposite_idx] = temp\n\n                # Additional local improvement: swap adjacent nodes if beneficial\n                if worst_edge_idx > 0 and worst_edge_idx < n-2:\n                    cost_before = edges_1[worst_edge_idx-1] + edges_1[worst_edge_idx] + edges_2[worst_edge_idx-1] + edges_2[worst_edge_idx]\n                    new_solution[worst_edge_idx], new_solution[worst_edge_idx+1] = new_solution[worst_edge_idx+1], new_solution[worst_edge_idx]\n                    cost_after = distance_matrix_1[new_solution[worst_edge_idx-1], new_solution[worst_edge_idx]] + \\\n                                 distance_matrix_1[new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]] + \\\n                                 distance_matrix_2[new_solution[worst_edge_idx-1], new_solution[worst_edge_idx]] + \\\n                                 distance_matrix_2[new_solution[worst_edge_idx], new_solution[worst_edge_idx+1]]\n                    if cost_after > cost_before:\n                        new_solution[worst_edge_idx], new_solution[worst_edge_idx+1] = new_solution[worst_edge_idx+1], new_solution[worst_edge_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its balance between the two objectives, then applies a novel segment reversal and cross-segment insertion strategy to explore diverse neighborhoods while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Cross-segment insertion: insert a node from one segment into another\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i in range(a, b+1) and j in range(a, b+1)):\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This algorithm selects a solution from the archive with the lowest combined objective value, then applies a hybrid segment rotation and cross-segment replacement strategy to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with minimum combined objectives\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Randomly select three distinct segments\n    points = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    a, b, c = points[0], points[1], points[2]\n\n    # Rotate segments: move segment [a:b] to after [b:c]\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Cross-segment replacement: swap two nodes between segments\n    if np.random.rand() < 0.5:\n        i = np.random.randint(a, b)\n        j = np.random.randint(b, c)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8019628197829283,
            2.1799031496047974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with minimum combined objectives\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Randomly select three distinct segments\n    points = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    a, b, c = points[0], points[1], points[2]\n\n    # Rotate segments: move segment [a:b] to after [b:c]\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Cross-segment replacement: swap two nodes between segments\n    if np.random.rand() < 0.5:\n        i = np.random.randint(a, b)\n        j = np.random.randint(b, c)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node swapping and path inversion to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a novel hybrid local search operator that combines segment rotation with adaptive edge refinement to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment rotation and adaptive edge refinement\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = segment\n\n    # Adaptive edge refinement: swap edges based on objective space dominance\n    for _ in range(2):  # Perform multiple swaps\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i == j:\n            continue\n\n        # Calculate current and potential edge costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply swap if it improves at least one objective\n        if (potential_cost1 < current_cost1) or (potential_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8781656962478086,
            2.3180127143859863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment rotation and adaptive edge refinement\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = segment\n\n    # Adaptive edge refinement: swap edges based on objective space dominance\n    for _ in range(2):  # Perform multiple swaps\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i == j:\n            continue\n\n        # Calculate current and potential edge costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply swap if it improves at least one objective\n        if (potential_cost1 < current_cost1) or (potential_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8886726541788523,
            0.8166190385818481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a promising solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion and segment reversal to escape local optima while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with high potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct segments to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 segments and perform 3-opt\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Novel edge-swapping strategy: Swap edges between the two objective spaces\n    if random.random() < 0.5:\n        # Find the worst edge in the first objective space and swap it with the best edge in the second\n        worst_edge_idx = np.argmax([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        best_edge_idx = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge_idx != best_edge_idx:\n            # Swap the edges\n            temp = new_solution[worst_edge_idx]\n            new_solution[worst_edge_idx] = new_solution[best_edge_idx]\n            new_solution[best_edge_idx] = temp\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8886726541788523,
            0.8166190385818481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its balance between the two objectives, then applies a novel segment reversal and cross-segment insertion strategy to explore diverse neighborhoods while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Cross-segment insertion: insert a node from one segment into another\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i in range(a, b+1) and j in range(a, b+1)):\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm selects a solution from the archive based on the ratio of its objectives, then applies a novel segment reversal and cross-segment insertion strategy with adaptive segment sizes to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives based on ratio\n    selected_solution = max(archive, key=lambda x: x[1][0] / (x[1][1] + 1e-10))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size - 1)\n    b = a + np.random.randint(1, segment_size + 1)\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Cross-segment insertion with probability based on segment size\n    if np.random.rand() < 0.5 * (segment_size / n):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i in range(a, b+1) and j in range(a, b+1)):\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6970256674392286,
            1.6953970193862915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives based on ratio\n    selected_solution = max(archive, key=lambda x: x[1][0] / (x[1][1] + 1e-10))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size - 1)\n    b = a + np.random.randint(1, segment_size + 1)\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Cross-segment insertion with probability based on segment size\n    if np.random.rand() < 0.5 * (segment_size / n):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i in range(a, b+1) and j in range(a, b+1)):\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node relocation and segment rotation to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9579039459541197,
            1.5135387182235718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node swapping and path inversion to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on dominance and diversity, then applies a novel segment reversal and edge swap strategy to explore diverse neighborhoods while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good dominance and diversity\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    segment = segment[::-1]\n    new_solution[a:b+1] = segment\n\n    # Edge swap: swap two random edges in one of the objective spaces\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            if distance_matrix_1[new_solution[i], new_solution[i+1]] > distance_matrix_2[new_solution[i], new_solution[i+1]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined score of objective values and diversity, then applies a novel segment rotation and edge crossover strategy to explore the solution space while maintaining feasibility and promoting diversity in the generated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective and diversity\n    def score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        diversity = (obj1 - obj2) ** 2\n        return (obj1 + obj2) * diversity\n\n    selected_solution = max(archive, key=lambda x: score(x))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation: rotate a segment by a random amount\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = segment\n\n    # Edge crossover: swap edges between two random positions\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6347063281536609,
            2.336193799972534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective and diversity\n    def score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        diversity = (obj1 - obj2) ** 2\n        return (obj1 + obj2) * diversity\n\n    selected_solution = max(archive, key=lambda x: score(x))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation: rotate a segment by a random amount\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = segment\n\n    # Edge crossover: swap edges between two random positions\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This new algorithm selects a solution from the archive based on the sum of its normalized objective values, applies a segment insertion and inversion hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with balanced normalized objectives\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(np.abs(scores - np.median(scores)))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment insertion and inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] at position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Invert another segment [d:e] (where e = d + random length)\n    d = np.random.randint(1, n-1)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7599814967168197,
            1.4832627177238464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with balanced normalized objectives\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(np.abs(scores - np.median(scores)))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment insertion and inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] at position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Invert another segment [d:e] (where e = d + random length)\n    d = np.random.randint(1, n-1)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining segment inversion with a novel node swapping pattern that prioritizes improving the less dominant objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with targeted node swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert a segment to potentially reduce the dominant objective\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform targeted node swapping to improve the less dominant objective\n    k = np.random.randint(1, n-2)\n    l = np.random.randint(k+1, min(k+3, n-1))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8715874098290133,
            2.4331456422805786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with targeted node swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert a segment to potentially reduce the dominant objective\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform targeted node swapping to improve the less dominant objective\n    k = np.random.randint(1, n-2)\n    l = np.random.randint(k+1, min(k+3, n-1))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the objective space, then applies a novel three-segment exchange and inversion operator that intelligently combines segments from different parts of the tour while ensuring feasibility through careful segment boundary handling and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the non-dominated solution with the best balance in objectives\n    def dominance(sol):\n        obj = sol[1]\n        dominated = False\n        for other in archive:\n            if other[1][0] <= obj[0] and other[1][1] <= obj[1] and (other[1][0] < obj[0] or other[1][1] < obj[1]):\n                dominated = True\n                break\n        return -sum(obj) if not dominated else float('inf')\n\n    selected_solution = min(archive, key=dominance)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 6:\n        return new_solution\n\n    # Novel three-segment exchange and inversion operator\n    points = sorted(np.random.choice(range(1, n-1), size=5, replace=False))\n    a, b, c, d, e = points\n\n    # Exchange segments [a:b] and [c:d], then invert [d:e]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7408192819510826,
            2.492257833480835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the non-dominated solution with the best balance in objectives\n    def dominance(sol):\n        obj = sol[1]\n        dominated = False\n        for other in archive:\n            if other[1][0] <= obj[0] and other[1][1] <= obj[1] and (other[1][0] < obj[0] or other[1][1] < obj[1]):\n                dominated = True\n                break\n        return -sum(obj) if not dominated else float('inf')\n\n    selected_solution = min(archive, key=dominance)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 6:\n        return new_solution\n\n    # Novel three-segment exchange and inversion operator\n    points = sorted(np.random.choice(range(1, n-1), size=5, replace=False))\n    a, b, c, d, e = points\n\n    # Exchange segments [a:b] and [c:d], then invert [d:e]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([\n        new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]\n    ])\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node relocation and segment rotation to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining edge swap and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal operation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9597776125069625,
            2.38815575838089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal operation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node relocation and segment rotation to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on dominance and diversity, then applies a novel segment reversal and edge swap strategy to explore diverse neighborhoods while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good dominance and diversity\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    segment = segment[::-1]\n    new_solution[a:b+1] = segment\n\n    # Edge swap: swap two random edges in one of the objective spaces\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            if distance_matrix_1[new_solution[i], new_solution[i+1]] > distance_matrix_2[new_solution[i], new_solution[i+1]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node insertion with segment inversion and edge flipping to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Node insertion with segment inversion\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    segment = segment[::-1]\n    new_solution[a:b+1] = segment\n\n    # Edge flipping based on objective space dominance\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            if distance_matrix_1[new_solution[i], new_solution[i+1]] > distance_matrix_2[new_solution[i], new_solution[i+1]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8223837822822169,
            2.3782257437705994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Node insertion with segment inversion\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    segment = segment[::-1]\n    new_solution[a:b+1] = segment\n\n    # Edge flipping based on objective space dominance\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            if distance_matrix_1[new_solution[i], new_solution[i+1]] > distance_matrix_2[new_solution[i], new_solution[i+1]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a novel segment inversion and position swap to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Invert a segment\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Swap two positions to balance objectives\n    a, b = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8248485383982422,
            1.39065682888031
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Invert a segment\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Swap two positions to balance objectives\n    a, b = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This new algorithm selects a solution based on a weighted combination of objectives, then applies a hybrid local search that combines adaptive path reversal with objective-aware node insertion to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of objectives (alpha=0.7 for obj1, beta=0.3 for obj2)\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive path reversal: identify critical path segments based on both objectives\n    path_lengths = []\n    for i in range(n-2):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i+2]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i+2]]\n        path_lengths.append(cost1 + cost2)\n\n    # Find the most expensive path segment to reverse\n    if path_lengths:\n        i = np.argmax(path_lengths)\n        new_solution[i+1:i+3] = new_solution[i+1:i+3][::-1]\n\n    # Objective-aware node insertion: insert node from worst edge in obj2 into best position in obj1\n    worst_edge_obj2 = np.argmax([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    node_to_insert = new_solution[worst_edge_obj2]\n\n    # Find best insertion position in obj1\n    best_insert_pos = min(range(n), key=lambda pos: distance_matrix_1[new_solution[pos], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[(pos+1)%n]])\n\n    # Perform insertion\n    new_solution = np.insert(new_solution, best_insert_pos+1, node_to_insert)\n    new_solution = np.delete(new_solution, worst_edge_obj2 + (1 if worst_edge_obj2 > best_insert_pos else 0))\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8350832010475739,
            2.5408148765563965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of objectives (alpha=0.7 for obj1, beta=0.3 for obj2)\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive path reversal: identify critical path segments based on both objectives\n    path_lengths = []\n    for i in range(n-2):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i+2]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i+2]]\n        path_lengths.append(cost1 + cost2)\n\n    # Find the most expensive path segment to reverse\n    if path_lengths:\n        i = np.argmax(path_lengths)\n        new_solution[i+1:i+3] = new_solution[i+1:i+3][::-1]\n\n    # Objective-aware node insertion: insert node from worst edge in obj2 into best position in obj1\n    worst_edge_obj2 = np.argmax([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    node_to_insert = new_solution[worst_edge_obj2]\n\n    # Find best insertion position in obj1\n    best_insert_pos = min(range(n), key=lambda pos: distance_matrix_1[new_solution[pos], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[(pos+1)%n]])\n\n    # Perform insertion\n    new_solution = np.insert(new_solution, best_insert_pos+1, node_to_insert)\n    new_solution = np.delete(new_solution, worst_edge_obj2 + (1 if worst_edge_obj2 > best_insert_pos else 0))\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, applies a dynamic segment swap and inversion hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available, otherwise select the one with balanced objectives\n    non_dominated = [sol for sol in archive if not any(sol[1][0] > other[1][0] and sol[1][1] > other[1][1] for other in archive)]\n    if non_dominated:\n        selected_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    else:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment swap and inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap segments [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Invert a random segment\n    inv_start = np.random.randint(1, n-1)\n    inv_end = np.random.randint(inv_start, n-1)\n    new_solution[inv_start:inv_end+1] = new_solution[inv_start:inv_end+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6769132668292626,
            0.7979313731193542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available, otherwise select the one with balanced objectives\n    non_dominated = [sol for sol in archive if not any(sol[1][0] > other[1][0] and sol[1][1] > other[1][1] for other in archive)]\n    if non_dominated:\n        selected_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    else:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment swap and inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap segments [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Invert a random segment\n    inv_start = np.random.randint(1, n-1)\n    inv_end = np.random.randint(inv_start, n-1)\n    new_solution[inv_start:inv_end+1] = new_solution[inv_start:inv_end+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, applies a dynamic segment swap and inversion hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available, otherwise select the one with balanced objectives\n    non_dominated = [sol for sol in archive if not any(sol[1][0] > other[1][0] and sol[1][1] > other[1][1] for other in archive)]\n    if non_dominated:\n        selected_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    else:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment swap and inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap segments [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Invert a random segment\n    inv_start = np.random.randint(1, n-1)\n    inv_end = np.random.randint(inv_start, n-1)\n    new_solution[inv_start:inv_end+1] = new_solution[inv_start:inv_end+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6769132668292626,
            0.7979313731193542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available, otherwise select the one with balanced objectives\n    non_dominated = [sol for sol in archive if not any(sol[1][0] > other[1][0] and sol[1][1] > other[1][1] for other in archive)]\n    if non_dominated:\n        selected_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    else:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment swap and inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap segments [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Invert a random segment\n    inv_start = np.random.randint(1, n-1)\n    inv_end = np.random.randint(inv_start, n-1)\n    new_solution[inv_start:inv_end+1] = new_solution[inv_start:inv_end+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects the solution with the highest combined objective value from the archive, then applies a novel hybrid local search that combines a multi-segment shuffle with an adaptive edge exchange strategy to balance improvements across both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle: randomly select 4 segments and rearrange them\n    if n >= 6:\n        points = sorted(random.sample(range(1, n-1), 3))\n        a, b, c = points[0], points[1], points[2]\n        segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Adaptive edge exchange: exchange edges between objectives based on their relative performance\n    for _ in range(min(3, n//2)):\n        # Find edge with worst performance in combined objectives\n        edge_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_scores.append(cost1 + cost2)\n\n        worst_edge = np.argmax(edge_scores)\n\n        # Find best edge in the other objective\n        if random.random() < 0.5:\n            # Compare with first objective\n            best_edge = np.argmin([distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n        else:\n            # Compare with second objective\n            best_edge = np.argmin([distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)])\n\n        if worst_edge != best_edge:\n            # Exchange the edges\n            temp = new_solution[worst_edge]\n            new_solution[worst_edge] = new_solution[best_edge]\n            new_solution[best_edge] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node swapping and path inversion to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel hybrid local search that combines a multi-objective path decomposition with an adaptive node insertion strategy to balance improvements across both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (max difference between objectives)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path decomposition: split tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n-1):\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        if abs(cost1 - cost2) > 0.1 * (cost1 + cost2):  # Significant difference\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    segments.append(current_segment)\n\n    # Adaptive node insertion: reinsert nodes based on their relative performance\n    if len(segments) > 1:\n        # Randomly select a segment to modify\n        seg_idx = random.randint(0, len(segments)-1)\n        segment = segments[seg_idx]\n\n        if len(segment) > 2:\n            # Remove a random node from the segment\n            node_to_remove = random.choice(segment[1:-1])\n            segment.remove(node_to_remove)\n\n            # Find best position to insert it in the entire tour\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n-1):\n                # Calculate insertion cost considering both objectives\n                cost1 = (distance_matrix_1[new_solution[i], node_to_remove] +\n                         distance_matrix_1[node_to_remove, new_solution[i+1]] -\n                         distance_matrix_1[new_solution[i], new_solution[i+1]])\n                cost2 = (distance_matrix_2[new_solution[i], node_to_remove] +\n                         distance_matrix_2[node_to_remove, new_solution[i+1]] -\n                         distance_matrix_2[new_solution[i], new_solution[i+1]])\n                combined_cost = cost1 + cost2\n\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_pos = i+1\n\n            # Insert the node at the best position\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_remove], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.922611704119526,
            6.143609464168549
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (max difference between objectives)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path decomposition: split tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n-1):\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        if abs(cost1 - cost2) > 0.1 * (cost1 + cost2):  # Significant difference\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    segments.append(current_segment)\n\n    # Adaptive node insertion: reinsert nodes based on their relative performance\n    if len(segments) > 1:\n        # Randomly select a segment to modify\n        seg_idx = random.randint(0, len(segments)-1)\n        segment = segments[seg_idx]\n\n        if len(segment) > 2:\n            # Remove a random node from the segment\n            node_to_remove = random.choice(segment[1:-1])\n            segment.remove(node_to_remove)\n\n            # Find best position to insert it in the entire tour\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n-1):\n                # Calculate insertion cost considering both objectives\n                cost1 = (distance_matrix_1[new_solution[i], node_to_remove] +\n                         distance_matrix_1[node_to_remove, new_solution[i+1]] -\n                         distance_matrix_1[new_solution[i], new_solution[i+1]])\n                cost2 = (distance_matrix_2[new_solution[i], node_to_remove] +\n                         distance_matrix_2[node_to_remove, new_solution[i+1]] -\n                         distance_matrix_2[new_solution[i], new_solution[i+1]])\n                combined_cost = cost1 + cost2\n\n                if combined_cost < best_cost:\n                    best_cost = combined_cost\n                    best_pos = i+1\n\n            # Insert the node at the best position\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_remove], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining objective values and tour structure, applies a segment relocation and 3-opt hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and tour structure\n    def hybrid_score(sol_obj):\n        sol, (obj1, obj2) = sol_obj\n        normalized_obj1 = (obj1 - min(obj1 for _, (o1, _) in archive)) / (max(obj1 for _, (o1, _) in archive) - min(obj1 for _, (o1, _) in archive) + 1e-8)\n        normalized_obj2 = (obj2 - min(obj2 for _, (_, o2) in archive)) / (max(obj2 for _, (_, o2) in archive) - min(obj2 for _, (_, o2) in archive) + 1e-8)\n        structure_score = sum(distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol))) / len(sol)\n        return normalized_obj1 + normalized_obj2 + 0.5 * structure_score\n\n    selected_solution = min(archive, key=hybrid_score)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and 3-opt\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    c, d, e = sorted(np.random.choice(range(1, n-2), size=3, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # 3-opt: select 3 edges and reconnect them in a different way\n    if c > a and c < b:\n        i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8364618222796525,
            1.758070170879364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and tour structure\n    def hybrid_score(sol_obj):\n        sol, (obj1, obj2) = sol_obj\n        normalized_obj1 = (obj1 - min(obj1 for _, (o1, _) in archive)) / (max(obj1 for _, (o1, _) in archive) - min(obj1 for _, (o1, _) in archive) + 1e-8)\n        normalized_obj2 = (obj2 - min(obj2 for _, (_, o2) in archive)) / (max(obj2 for _, (_, o2) in archive) - min(obj2 for _, (_, o2) in archive) + 1e-8)\n        structure_score = sum(distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol))) / len(sol)\n        return normalized_obj1 + normalized_obj2 + 0.5 * structure_score\n\n    selected_solution = min(archive, key=hybrid_score)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and 3-opt\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    c, d, e = sorted(np.random.choice(range(1, n-2), size=3, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # 3-opt: select 3 edges and reconnect them in a different way\n    if c > a and c < b:\n        i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This new algorithm selects a solution based on the product of objectives (rather than sum) to prioritize solutions with balanced improvement potential, then applies a hybrid local search combining adaptive segment reversal with objective-aware node insertion to maintain feasibility and explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of objectives (balanced improvement potential)\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal: identify critical segments based on both objectives\n    segment_scores = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_scores.append(cost1 * cost2)\n\n    # Find the segment with highest product score\n    target_segment = np.argmax(segment_scores)\n\n    # Reverse the target segment\n    new_solution[target_segment:target_segment+2] = new_solution[target_segment+1], new_solution[target_segment]\n\n    # Objective-aware node insertion: insert node from worst edge in one objective to best edge in other\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Insert node from worst edge in obj1 to position after best edge in obj2\n        node_to_insert = new_solution[worst_edge_obj1]\n        new_solution = np.delete(new_solution, worst_edge_obj1)\n        insert_pos = (best_edge_obj2 + 1) % n\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9120409898880522,
            1.929427683353424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of objectives (balanced improvement potential)\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal: identify critical segments based on both objectives\n    segment_scores = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_scores.append(cost1 * cost2)\n\n    # Find the segment with highest product score\n    target_segment = np.argmax(segment_scores)\n\n    # Reverse the target segment\n    new_solution[target_segment:target_segment+2] = new_solution[target_segment+1], new_solution[target_segment]\n\n    # Objective-aware node insertion: insert node from worst edge in one objective to best edge in other\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Insert node from worst edge in obj1 to position after best edge in obj2\n        node_to_insert = new_solution[worst_edge_obj1]\n        new_solution = np.delete(new_solution, worst_edge_obj1)\n        insert_pos = (best_edge_obj2 + 1) % n\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node relocation and segment rotation to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation and segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining edge swap and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal operation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining node insertion and segment inversion that prioritizes improvements in both objective spaces, while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    max_obj = max(x[1] for x in archive)\n    norm_objs = [(x[0], (x[1][0]/max_obj[0], x[1][1]/max_obj[1])) for x in archive]\n    selected_solution = max(norm_objs, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Node insertion with objective-aware selection\n    obj_weights = np.array([distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[i]]\n                          for i in range(1, n)])\n\n    # Select node to move based on high edge cost\n    node_idx = np.argmax(obj_weights)\n    node = new_solution[node_idx]\n\n    # Remove node\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Insert at position that minimizes both objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(1, n):\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Segment inversion with objective balancing\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment inversion cost\n    prev_node = new_solution[a-1]\n    next_node = new_solution[b] if b+1 < n else new_solution[0]\n    current_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n    current_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n    inverted_segment = segment[::-1]\n    inverted_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n    inverted_cost2 = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n    # Apply inversion if it improves both objectives\n    if inverted_cost1 + inverted_cost2 < current_cost1 + current_cost2:\n        new_solution[a:b+1] = inverted_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8831289068451635,
            2.7775251865386963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of normalized objectives\n    max_obj = max(x[1] for x in archive)\n    norm_objs = [(x[0], (x[1][0]/max_obj[0], x[1][1]/max_obj[1])) for x in archive]\n    selected_solution = max(norm_objs, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Node insertion with objective-aware selection\n    obj_weights = np.array([distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[i]]\n                          for i in range(1, n)])\n\n    # Select node to move based on high edge cost\n    node_idx = np.argmax(obj_weights)\n    node = new_solution[node_idx]\n\n    # Remove node\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Insert at position that minimizes both objectives\n    best_pos = 0\n    min_cost = float('inf')\n\n    for pos in range(1, n):\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Segment inversion with objective balancing\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment inversion cost\n    prev_node = new_solution[a-1]\n    next_node = new_solution[b] if b+1 < n else new_solution[0]\n    current_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n    current_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n    inverted_segment = segment[::-1]\n    inverted_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n    inverted_cost2 = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n    # Apply inversion if it improves both objectives\n    if inverted_cost1 + inverted_cost2 < current_cost1 + current_cost2:\n        new_solution[a:b+1] = inverted_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining edge swap and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal operation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution from the archive based on the dominance relationship between objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is dominated by at least one other solution in the archive\n    selected_solution = None\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if dominated:\n            selected_solution = sol_i.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Node insertion operation\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6213425610418576,
            1.7699059844017029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is dominated by at least one other solution in the archive\n    selected_solution = None\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if dominated:\n            selected_solution = sol_i.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Node insertion operation\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.878016708944118,
            0.6092617511749268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.878016708944118,
            0.6092617511749268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines node swapping and path inversion to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node swapping and path inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select two distinct nodes to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This algorithm selects a solution from the archive based on its balance between both objectives, then applies a novel local search operator that combines multi-segment swapping with adaptive path restructuring to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives (minimizing the difference between both costs)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 6:\n        return new_solution\n\n    # Multi-segment swapping: identify three non-overlapping segments\n    segment_indices = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    a, b, c = segment_indices[0], segment_indices[1], segment_indices[2]\n\n    # Create new segments by rotating the three segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconstruct solution with rotated segments\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Adaptive path restructuring: identify the most expensive edge in each objective\n    # and replace it with a better edge from the other objective\n    edges_obj1 = [(distance_matrix_1[new_solution[k], new_solution[k+1]], k) for k in range(n-1)]\n    edges_obj2 = [(distance_matrix_2[new_solution[k], new_solution[k+1]], k) for k in range(n-1)]\n\n    worst_edge_obj1 = max(edges_obj1, key=lambda x: x[0])[1]\n    best_edge_obj2 = min(edges_obj2, key=lambda x: x[0])[1]\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8341483792735176,
            2.2748591899871826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives (minimizing the difference between both costs)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 6:\n        return new_solution\n\n    # Multi-segment swapping: identify three non-overlapping segments\n    segment_indices = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    a, b, c = segment_indices[0], segment_indices[1], segment_indices[2]\n\n    # Create new segments by rotating the three segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconstruct solution with rotated segments\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Adaptive path restructuring: identify the most expensive edge in each objective\n    # and replace it with a better edge from the other objective\n    edges_obj1 = [(distance_matrix_1[new_solution[k], new_solution[k+1]], k) for k in range(n-1)]\n    edges_obj2 = [(distance_matrix_2[new_solution[k], new_solution[k+1]], k) for k in range(n-1)]\n\n    worst_edge_obj1 = max(edges_obj1, key=lambda x: x[0])[1]\n    best_edge_obj2 = min(edges_obj2, key=lambda x: x[0])[1]\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm selects a solution with high potential for improvement by identifying and reinforcing its best-performing segments while dynamically balancing the objectives through a novel adaptive segment fusion and multi-objective edge optimization strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment fusion: identify and merge high-quality segments\n    segment_scores = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_scores.append((cost1 + cost2, i))\n\n    segment_scores.sort()\n    best_segments = [idx for (score, idx) in segment_scores[:max(2, n//5)]]\n\n    # Create fused segment by combining best segments\n    fused_segment = []\n    for i in best_segments:\n        fused_segment.extend(new_solution[i:i+2])\n\n    # Insert fused segment at random position\n    insert_pos = np.random.randint(1, n-1)\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        np.unique(fused_segment),\n        new_solution[insert_pos:]\n    ])\n\n    # Multi-objective edge optimization: replace worst edge with best edge from other objective\n    edge_costs1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n    edge_costs2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n    worst_edge1 = np.argmax(edge_costs1)\n    best_edge2 = np.argmin(edge_costs2)\n\n    if worst_edge1 != best_edge2:\n        temp = new_solution[worst_edge1]\n        new_solution[worst_edge1] = new_solution[best_edge2]\n        new_solution[best_edge2] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8436139954631456,
            1.1520827412605286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest sum of normalized objectives\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment fusion: identify and merge high-quality segments\n    segment_scores = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_scores.append((cost1 + cost2, i))\n\n    segment_scores.sort()\n    best_segments = [idx for (score, idx) in segment_scores[:max(2, n//5)]]\n\n    # Create fused segment by combining best segments\n    fused_segment = []\n    for i in best_segments:\n        fused_segment.extend(new_solution[i:i+2])\n\n    # Insert fused segment at random position\n    insert_pos = np.random.randint(1, n-1)\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        np.unique(fused_segment),\n        new_solution[insert_pos:]\n    ])\n\n    # Multi-objective edge optimization: replace worst edge with best edge from other objective\n    edge_costs1 = [distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n    edge_costs2 = [distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)]\n\n    worst_edge1 = np.argmax(edge_costs1)\n    best_edge2 = np.argmin(edge_costs2)\n\n    if worst_edge1 != best_edge2:\n        temp = new_solution[worst_edge1]\n        new_solution[worst_edge1] = new_solution[best_edge2]\n        new_solution[best_edge2] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a hybrid local search combining adaptive segment rotation, multi-objective edge insertion, and probabilistic node swapping to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential based on combined objective and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] * x[1][1] != 0 else 1))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment rotation\n    k = np.random.randint(1, min(4, n//2))\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, k)\n    new_solution[a:b+1] = rotated\n\n    # Multi-objective edge insertion\n    c = np.random.randint(1, n-1)\n    d = np.random.randint(1, n-1)\n    if c != d:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d-1], new_solution[d]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.2):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Probabilistic node swapping\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        if np.random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8568048685553036,
            2.6498681902885437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential based on combined objective and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] * x[1][1] != 0 else 1))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment rotation\n    k = np.random.randint(1, min(4, n//2))\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, k)\n    new_solution[a:b+1] = rotated\n\n    # Multi-objective edge insertion\n    c = np.random.randint(1, n-1)\n    d = np.random.randint(1, n-1)\n    if c != d:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d-1], new_solution[d]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.2):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Probabilistic node swapping\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        if np.random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a solution with a high potential for improvement based on a novel score function that combines both objectives with adaptive weights, then applies a hybrid local search combining segment inversion with objective-balanced edge swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate adaptive weights based on objective ranges\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    obj1_range = max(obj1_values) - min(obj1_values) if max(obj1_values) != min(obj1_values) else 1\n    obj2_range = max(obj2_values) - min(obj2_values) if max(obj2_values) != min(obj2_values) else 1\n\n    # Select solution with highest weighted sum of objectives\n    def score(obj):\n        weight1 = obj2_range / (obj1_range + obj2_range)\n        weight2 = obj1_range / (obj1_range + obj2_range)\n        return weight1 * obj[0] + weight2 * obj[1]\n\n    selected_solution = max(archive, key=lambda x: score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment inversion with objective balance\n    segment_scores = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_scores.append((cost1 + cost2) * (1 + abs(cost1 - cost2) / max(cost1, cost2)))\n\n    # Find the two most unbalanced segments\n    sorted_indices = np.argsort(segment_scores)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Invert the segment between i and j\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-balanced edge swap\n    edge_scores = []\n    for k in range(n-1):\n        cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]]\n        cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]]\n        edge_scores.append(abs(cost1 - cost2) / (cost1 + cost2))\n\n    worst_edge = np.argmax(edge_scores)\n    best_edge = np.argmin(edge_scores)\n\n    if worst_edge != best_edge:\n        temp = new_solution[worst_edge]\n        new_solution[worst_edge] = new_solution[best_edge]\n        new_solution[best_edge] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8748532048885537,
            2.935988128185272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate adaptive weights based on objective ranges\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    obj1_range = max(obj1_values) - min(obj1_values) if max(obj1_values) != min(obj1_values) else 1\n    obj2_range = max(obj2_values) - min(obj2_values) if max(obj2_values) != min(obj2_values) else 1\n\n    # Select solution with highest weighted sum of objectives\n    def score(obj):\n        weight1 = obj2_range / (obj1_range + obj2_range)\n        weight2 = obj1_range / (obj1_range + obj2_range)\n        return weight1 * obj[0] + weight2 * obj[1]\n\n    selected_solution = max(archive, key=lambda x: score(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment inversion with objective balance\n    segment_scores = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_scores.append((cost1 + cost2) * (1 + abs(cost1 - cost2) / max(cost1, cost2)))\n\n    # Find the two most unbalanced segments\n    sorted_indices = np.argsort(segment_scores)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Invert the segment between i and j\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-balanced edge swap\n    edge_scores = []\n    for k in range(n-1):\n        cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]]\n        cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]]\n        edge_scores.append(abs(cost1 - cost2) / (cost1 + cost2))\n\n    worst_edge = np.argmax(edge_scores)\n    best_edge = np.argmin(edge_scores)\n\n    if worst_edge != best_edge:\n        temp = new_solution[worst_edge]\n        new_solution[worst_edge] = new_solution[best_edge]\n        new_solution[best_edge] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This algorithm selects a solution with the best trade-off between the two objectives using the hypervolume indicator, then applies a novel adaptive path decomposition and segment merging strategy that dynamically balances the exploration of high-cost segments in both objectives while ensuring feasibility through constrained node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best hypervolume trade-off\n    def hypervolume(obj):\n        return obj[0] * obj[1]  # Simplified hypervolume approximation\n\n    selected_solution = max(archive, key=lambda x: hypervolume(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive path decomposition and segment merging\n    # Identify segments with high cost in either objective\n    segment_costs = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_costs.append((cost1 + cost2, i))\n\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    critical_segments = [i for (_, i) in segment_costs[:max(2, n//4)]]\n\n    # Merge critical segments by reordering nodes\n    for i in range(len(critical_segments)-1):\n        seg1 = critical_segments[i]\n        seg2 = critical_segments[i+1]\n\n        # Find nodes between segments\n        nodes = new_solution[seg1+1:seg2+1]\n        if len(nodes) < 2:\n            continue\n\n        # Reorder nodes to balance costs\n        ordered_nodes = sorted(nodes, key=lambda x: (\n            distance_matrix_1[new_solution[seg1], x] + distance_matrix_2[x, new_solution[seg2+1]],\n            distance_matrix_2[new_solution[seg1], x] + distance_matrix_1[x, new_solution[seg2+1]]\n        ))\n\n        new_solution[seg1+1:seg2+1] = ordered_nodes\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9534727107960732,
            4.239432156085968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best hypervolume trade-off\n    def hypervolume(obj):\n        return obj[0] * obj[1]  # Simplified hypervolume approximation\n\n    selected_solution = max(archive, key=lambda x: hypervolume(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive path decomposition and segment merging\n    # Identify segments with high cost in either objective\n    segment_costs = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_costs.append((cost1 + cost2, i))\n\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    critical_segments = [i for (_, i) in segment_costs[:max(2, n//4)]]\n\n    # Merge critical segments by reordering nodes\n    for i in range(len(critical_segments)-1):\n        seg1 = critical_segments[i]\n        seg2 = critical_segments[i+1]\n\n        # Find nodes between segments\n        nodes = new_solution[seg1+1:seg2+1]\n        if len(nodes) < 2:\n            continue\n\n        # Reorder nodes to balance costs\n        ordered_nodes = sorted(nodes, key=lambda x: (\n            distance_matrix_1[new_solution[seg1], x] + distance_matrix_2[x, new_solution[seg2+1]],\n            distance_matrix_2[new_solution[seg1], x] + distance_matrix_1[x, new_solution[seg2+1]]\n        ))\n\n        new_solution[seg1+1:seg2+1] = ordered_nodes\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9515903565232249,
            1.8950756192207336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining edge insertion with a novel segment inversion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge insertion with segment inversion\n    i = np.random.randint(1, n-1)\n    j = np.random.randint(1, n-1)\n    while j == i:\n        j = np.random.randint(1, n-1)\n\n    # Perform edge insertion\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.719604121557186,
            2.2971768379211426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge insertion with segment inversion\n    i = np.random.randint(1, n-1)\n    j = np.random.randint(1, n-1)\n    while j == i:\n        j = np.random.randint(1, n-1)\n\n    # Perform edge insertion\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This new algorithm selects a solution from the archive based on its non-dominated status, then applies a hybrid local search combining segment rotation, node transposition with inversion, and adaptive edge refinement to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available, otherwise select the best compromise\n    non_dominated = [s for s in archive if not any(s[1][0] > other[1][0] and s[1][1] > other[1][1] for other in archive)]\n    if non_dominated:\n        selected_solution = min(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation, node transposition with inversion, and adaptive edge refinement\n    # Segment rotation\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b+1:]])\n\n    # Node transposition with inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    if np.random.rand() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive edge refinement\n    for _ in range(2):\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost2 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n        if cost2 < cost1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6361099043221149,
            2.5573461055755615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available, otherwise select the best compromise\n    non_dominated = [s for s in archive if not any(s[1][0] > other[1][0] and s[1][1] > other[1][1] for other in archive)]\n    if non_dominated:\n        selected_solution = min(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation, node transposition with inversion, and adaptive edge refinement\n    # Segment rotation\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b+1:]])\n\n    # Node transposition with inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    if np.random.rand() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive edge refinement\n    for _ in range(2):\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost2 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n        if cost2 < cost1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping with adaptive probabilities, while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted sum of objectives)\n    weights = [0.6, 0.4]  # Higher weight for first objective\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive probabilities for operations\n    prob_relocate = 0.5\n    prob_invert = 0.3\n    prob_swap = 0.2\n\n    # Node relocation\n    if np.random.rand() < prob_relocate:\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.choice(range(1, n))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment inversion\n    if np.random.rand() < prob_invert:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping\n    if np.random.rand() < prob_swap:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9512748119856007,
            2.0812633633613586
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted sum of objectives)\n    weights = [0.6, 0.4]  # Higher weight for first objective\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive probabilities for operations\n    prob_relocate = 0.5\n    prob_invert = 0.3\n    prob_swap = 0.2\n\n    # Node relocation\n    if np.random.rand() < prob_relocate:\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.choice(range(1, n))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment inversion\n    if np.random.rand() < prob_invert:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping\n    if np.random.rand() < prob_swap:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0021815098673434,
            2.770068049430847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0021815098673434,
            2.770068049430847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining a novel segment inversion with edge swapping to balance improvement across both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with edge swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert a segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge swapping to balance objectives\n    k = np.random.randint(1, n-2)\n    l = np.random.randint(k+1, n-1)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6878353089435394,
            2.307817578315735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with edge swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert a segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge swapping to balance objectives\n    k = np.random.randint(1, n-2)\n    l = np.random.randint(k+1, n-1)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted sum of objectives with random weights, then applies a hybrid local search combining 2-opt with a novel segment rotation to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using random weighted sum of objectives\n    weights = np.random.uniform(0.1, 0.9, size=2)\n    selected_solution = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    segment = new_solution[segment_start:segment_start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    new_solution[segment_start:segment_start+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9019291248519262,
            1.613067388534546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using random weighted sum of objectives\n    weights = np.random.uniform(0.1, 0.9, size=2)\n    selected_solution = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    segment = new_solution[segment_start:segment_start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    new_solution[segment_start:segment_start+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a novel hybrid local search combining a multi-segment crossover with a dynamic edge reversal to explore the solution space while ensuring feasibility through comprehensive validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: multi-segment crossover with dynamic edge reversal\n    segments = []\n    num_segments = np.random.randint(2, min(4, n//2))\n    for _ in range(num_segments):\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segments.append((a, b))\n\n    # Sort segments by start position\n    segments.sort()\n\n    # Apply multi-segment crossover\n    temp_solution = []\n    last_pos = 0\n    for a, b in segments:\n        temp_solution.extend(new_solution[last_pos:a])\n        temp_solution.extend(new_solution[a:b+1][::-1])  # Reverse the segment\n        last_pos = b + 1\n    temp_solution.extend(new_solution[last_pos:])\n\n    # Dynamic edge reversal: reverse edges based on multi-objective improvement\n    for i in range(1, n-1):\n        current_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[i+1]]\n        current_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[i+1]]\n\n        # Consider reversing the edge\n        new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i+1]] + distance_matrix_1[temp_solution[i], temp_solution[i]]\n        new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i+1]] + distance_matrix_2[temp_solution[i], temp_solution[i]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            temp_solution[i], temp_solution[i+1] = temp_solution[i+1], temp_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(temp_solution)) != n:\n        temp_solution = selected_solution.copy()\n\n    return np.array(temp_solution)\n\n",
        "score": [
            -0.8458261907855993,
            1.4513292908668518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: multi-segment crossover with dynamic edge reversal\n    segments = []\n    num_segments = np.random.randint(2, min(4, n//2))\n    for _ in range(num_segments):\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segments.append((a, b))\n\n    # Sort segments by start position\n    segments.sort()\n\n    # Apply multi-segment crossover\n    temp_solution = []\n    last_pos = 0\n    for a, b in segments:\n        temp_solution.extend(new_solution[last_pos:a])\n        temp_solution.extend(new_solution[a:b+1][::-1])  # Reverse the segment\n        last_pos = b + 1\n    temp_solution.extend(new_solution[last_pos:])\n\n    # Dynamic edge reversal: reverse edges based on multi-objective improvement\n    for i in range(1, n-1):\n        current_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[i+1]]\n        current_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[i+1]]\n\n        # Consider reversing the edge\n        new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i+1]] + distance_matrix_1[temp_solution[i], temp_solution[i]]\n        new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i+1]] + distance_matrix_2[temp_solution[i], temp_solution[i]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            temp_solution[i], temp_solution[i+1] = temp_solution[i+1], temp_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(temp_solution)) != n:\n        temp_solution = selected_solution.copy()\n\n    return np.array(temp_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This algorithm selects a solution with high potential for improvement by identifying and relinking critical segments based on both objectives, then applies a hybrid local search that combines adaptive segment relinking with objective-aware edge replacement, followed by a novel node reinsertion strategy to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Novel node reinsertion: remove a random node and reinsert it in a position that minimizes the sum of both objectives\n    if n > 4:\n        node_to_remove = np.random.randint(1, n-1)\n        removed_node = new_solution[node_to_remove]\n        new_solution = np.delete(new_solution, node_to_remove)\n\n        best_position = 0\n        min_cost = float('inf')\n\n        for pos in range(1, len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, removed_node)\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_position = pos\n\n        new_solution = np.insert(new_solution, best_position, removed_node)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9468461021219186,
            10.649176180362701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Novel node reinsertion: remove a random node and reinsert it in a position that minimizes the sum of both objectives\n    if n > 4:\n        node_to_remove = np.random.randint(1, n-1)\n        removed_node = new_solution[node_to_remove]\n        new_solution = np.delete(new_solution, node_to_remove)\n\n        best_position = 0\n        min_cost = float('inf')\n\n        for pos in range(1, len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, removed_node)\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_position = pos\n\n        new_solution = np.insert(new_solution, best_position, removed_node)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This new algorithm selects a solution from the archive based on its diversity in objective space, then applies a hybrid local search combining a novel node swapping strategy with a multi-objective-aware path inversion to explore the solution space while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives (potential for improvement in both dimensions)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node swapping with path inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap nodes at positions a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Path inversion between a and b if it improves both objectives\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate original and inverted costs\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a-1, b))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a-1, b))\n\n    inverted_cost1 = distance_matrix_1[new_solution[a-1], inverted_segment[0]] + \\\n                    sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1)) + \\\n                    distance_matrix_1[inverted_segment[-1], new_solution[b+1]]\n    inverted_cost2 = distance_matrix_2[new_solution[a-1], inverted_segment[0]] + \\\n                    sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1)) + \\\n                    distance_matrix_2[inverted_segment[-1], new_solution[b+1]]\n\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[a:b+1] = inverted_segment\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8251945522481694,
            1.4052771925926208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most diverse objectives (potential for improvement in both dimensions)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node swapping with path inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap nodes at positions a and b\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Path inversion between a and b if it improves both objectives\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate original and inverted costs\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a-1, b))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a-1, b))\n\n    inverted_cost1 = distance_matrix_1[new_solution[a-1], inverted_segment[0]] + \\\n                    sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1)) + \\\n                    distance_matrix_1[inverted_segment[-1], new_solution[b+1]]\n    inverted_cost2 = distance_matrix_2[new_solution[a-1], inverted_segment[0]] + \\\n                    sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1)) + \\\n                    distance_matrix_2[inverted_segment[-1], new_solution[b+1]]\n\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[a:b+1] = inverted_segment\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining edge swap and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal operation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining edge swap and segment reversal with adaptive segment lengths to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with weighted sum\n    objectives = np.array([x[1] for x in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for each objective\n    scores = (normalized * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive edge swap\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive segment reversal with variable lengths\n    segment_length = max(2, min(10, n // 4))\n    a = np.random.randint(1, n - segment_length)\n    b = a + segment_length\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8840012518170628,
            2.071706473827362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with weighted sum\n    objectives = np.array([x[1] for x in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for each objective\n    scores = (normalized * weights).sum(axis=1)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive edge swap\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive segment reversal with variable lengths\n    segment_length = max(2, min(10, n // 4))\n    a = np.random.randint(1, n - segment_length)\n    b = a + segment_length\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, applies a novel hybrid operator combining multi-objective-aware node swapping and segment inversion to explore the solution space while ensuring feasibility through careful validation and restoration of the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: multi-objective-aware node swapping and segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap nodes at positions a and b if it improves both objectives\n    original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n    original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n    if not ((new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Invert a segment between random positions\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[d:c-1:-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.696536629046656,
            2.071888566017151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: multi-objective-aware node swapping and segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap nodes at positions a and b if it improves both objectives\n    original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n    original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n    if not ((new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Invert a segment between random positions\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[d:c-1:-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node insertion: insert node at position c that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_prev, node_next = new_solution[c-1], new_solution[c+1]\n        node_insert = new_solution[c]\n\n        cost1 = distance_matrix_1[node_prev, node_insert] + distance_matrix_1[node_insert, node_next]\n        cost2 = distance_matrix_2[node_prev, node_insert] + distance_matrix_2[node_insert, node_next]\n\n        # Try inserting node_insert at a different position\n        for pos in range(1, n-1):\n            if pos != c:\n                node_new_prev, node_new_next = new_solution[pos-1], new_solution[pos]\n                new_cost1 = distance_matrix_1[node_new_prev, node_insert] + distance_matrix_1[node_insert, node_new_next]\n                new_cost2 = distance_matrix_2[node_new_prev, node_insert] + distance_matrix_2[node_insert, node_new_next]\n\n                if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.2):\n                    # Remove node_insert from current position\n                    new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                    # Insert node_insert at new position\n                    new_solution = np.concatenate([new_solution[:pos], [node_insert], new_solution[pos:]])\n                    break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8809876845066662,
            2.247940957546234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node insertion: insert node at position c that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_prev, node_next = new_solution[c-1], new_solution[c+1]\n        node_insert = new_solution[c]\n\n        cost1 = distance_matrix_1[node_prev, node_insert] + distance_matrix_1[node_insert, node_next]\n        cost2 = distance_matrix_2[node_prev, node_insert] + distance_matrix_2[node_insert, node_next]\n\n        # Try inserting node_insert at a different position\n        for pos in range(1, n-1):\n            if pos != c:\n                node_new_prev, node_new_next = new_solution[pos-1], new_solution[pos]\n                new_cost1 = distance_matrix_1[node_new_prev, node_insert] + distance_matrix_1[node_insert, node_new_next]\n                new_cost2 = distance_matrix_2[node_new_prev, node_insert] + distance_matrix_2[node_insert, node_new_next]\n\n                if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.2):\n                    # Remove node_insert from current position\n                    new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                    # Insert node_insert at new position\n                    new_solution = np.concatenate([new_solution[:pos], [node_insert], new_solution[pos:]])\n                    break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel hybrid local search combining segment rotation, node swapping, and edge crossing to explore the solution space while ensuring feasibility and promoting diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Node swapping\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge crossing\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9421551859331685,
            2.316952347755432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Node swapping\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge crossing\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel scoring metric that combines objective values and solution diversity, applies a hybrid operator combining a segment insertion and a node swap, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores combining objectives and diversity\n    scores = []\n    for solution, objectives in archive:\n        obj1, obj2 = objectives\n        diversity = len(np.unique(solution[:len(solution)//2])) / len(solution)\n        score = obj1 * obj2 * diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment insertion and node swap\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:a], new_solution[b+1:]])\n\n    # Swap two nodes (excluding first and last)\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8221937558404688,
            3.5593138933181763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores combining objectives and diversity\n    scores = []\n    for solution, objectives in archive:\n        obj1, obj2 = objectives\n        diversity = len(np.unique(solution[:len(solution)//2])) / len(solution)\n        score = obj1 * obj2 * diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment insertion and node swap\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:a], new_solution[b+1:]])\n\n    # Swap two nodes (excluding first and last)\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment insertion and inversion hybrid operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9023032966101097,
            1.3826017379760742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment crossover and node reinsertion with a probabilistic acceptance criterion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted sum of objectives)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Segment crossover between two random segments\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n\n    # Create a new segment by combining parts of two segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_segment = np.concatenate([segment1, segment2])\n\n    # Remove duplicates while preserving order\n    _, unique_indices = np.unique(new_segment, return_index=True)\n    new_segment = new_segment[np.sort(unique_indices)]\n\n    # Insert the new segment back into the solution\n    insert_pos = np.random.choice(range(1, n-len(new_segment)+1))\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        new_segment,\n        new_solution[insert_pos+len(new_segment):]\n    ])\n\n    # Node reinsertion with probabilistic acceptance\n    for _ in range(3):\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n\n        # Remove the node\n        temp_solution = np.delete(new_solution, node_idx)\n\n        # Try inserting in a random position\n        insert_pos = np.random.choice(range(1, n-1))\n        temp_solution = np.insert(temp_solution, insert_pos, node)\n\n        # Calculate objective values for both solutions\n        def calculate_objectives(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(1, len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(1, len(sol)))\n            return (cost1, cost2)\n\n        old_obj = calculate_objectives(new_solution)\n        new_obj = calculate_objectives(temp_solution)\n\n        # Probabilistic acceptance based on improvement\n        if (new_obj[0] < old_obj[0] and new_obj[1] < old_obj[1]) or np.random.rand() < 0.3:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9030756750945672,
            4.512859642505646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted sum of objectives)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Segment crossover between two random segments\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n\n    # Create a new segment by combining parts of two segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_segment = np.concatenate([segment1, segment2])\n\n    # Remove duplicates while preserving order\n    _, unique_indices = np.unique(new_segment, return_index=True)\n    new_segment = new_segment[np.sort(unique_indices)]\n\n    # Insert the new segment back into the solution\n    insert_pos = np.random.choice(range(1, n-len(new_segment)+1))\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        new_segment,\n        new_solution[insert_pos+len(new_segment):]\n    ])\n\n    # Node reinsertion with probabilistic acceptance\n    for _ in range(3):\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n\n        # Remove the node\n        temp_solution = np.delete(new_solution, node_idx)\n\n        # Try inserting in a random position\n        insert_pos = np.random.choice(range(1, n-1))\n        temp_solution = np.insert(temp_solution, insert_pos, node)\n\n        # Calculate objective values for both solutions\n        def calculate_objectives(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(1, len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(1, len(sol)))\n            return (cost1, cost2)\n\n        old_obj = calculate_objectives(new_solution)\n        new_obj = calculate_objectives(temp_solution)\n\n        # Probabilistic acceptance based on improvement\n        if (new_obj[0] < old_obj[0] and new_obj[1] < old_obj[1]) or np.random.rand() < 0.3:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective dominance (non-dominated solutions with high combined objective values), then applies a hybrid local search combining segment inversion with a novel node swapping pattern that considers both objective spaces to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with high combined objective value\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        selected_solution = max(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with objective-aware swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware node swapping\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i != j:\n            # Swap nodes based on distance improvement in both objectives\n            dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n            dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n            dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n            dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n            if (dist1_after + dist2_after) < (dist1_before + dist2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7306227115239052,
            2.5330514907836914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with high combined objective value\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        selected_solution = max(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with objective-aware swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Objective-aware node swapping\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i != j:\n            # Swap nodes based on distance improvement in both objectives\n            dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n            dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n            dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n            dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n            if (dist1_after + dist2_after) < (dist1_before + dist2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This new algorithm selects a solution from the archive based on the diversity of its objective values, then applies a novel hybrid local search combining edge exchange with a dynamic segment rotation to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse objectives\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    obj1_std = np.std(obj1_values)\n    obj2_std = np.std(obj2_values)\n\n    if obj1_std > obj2_std:\n        selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    else:\n        selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: edge exchange with dynamic segment rotation\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, n-1)\n    c = np.random.randint(1, n-2)\n\n    # Edge exchange\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Dynamic segment rotation\n    rotation_length = np.random.randint(2, min(4, n-c))\n    rotated_segment = np.roll(new_solution[c:c+rotation_length], 1)\n    new_solution[c:c+rotation_length] = rotated_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8339236813231828,
            2.576682984828949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with diverse objectives\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    obj1_std = np.std(obj1_values)\n    obj2_std = np.std(obj2_values)\n\n    if obj1_std > obj2_std:\n        selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    else:\n        selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: edge exchange with dynamic segment rotation\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, n-1)\n    c = np.random.randint(1, n-2)\n\n    # Edge exchange\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Dynamic segment rotation\n    rotation_length = np.random.randint(2, min(4, n-c))\n    rotated_segment = np.roll(new_solution[c:c+rotation_length], 1)\n    new_solution[c:c+rotation_length] = rotated_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining edge swap and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal operation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This algorithm selects a solution with the highest sum of objectives, identifies critical nodes based on their contribution to both objectives, and applies a novel hybrid local search combining adaptive node insertion with objective-aware edge flipping to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify critical nodes based on their contribution to both objectives\n    node_contributions = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        node_contributions.append(cost1 + cost2)\n\n    # Find most critical nodes\n    sorted_indices = np.argsort(node_contributions)[::-1]\n    critical_nodes = sorted_indices[:max(2, n//5)]\n\n    # Adaptive node insertion: remove and reinsert critical nodes\n    for node_idx in critical_nodes:\n        node = new_solution[node_idx]\n        # Remove node\n        new_solution = np.delete(new_solution, node_idx)\n        # Find best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n        for i in range(len(new_solution)):\n            prev = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n        # Insert node\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping: flip edges that improve one objective while not worsening the other\n    for i in range(n-2):\n        a, b, c = new_solution[i], new_solution[i+1], new_solution[i+2]\n        original_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n        original_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n        flipped_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n        flipped_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n\n        if (flipped_cost1 < original_cost1 and flipped_cost2 <= original_cost2) or \\\n           (flipped_cost2 < original_cost2 and flipped_cost1 <= original_cost1):\n            new_solution[i+1], new_solution[i+2] = new_solution[i+2], new_solution[i+1]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5210706370208071,
            12.087553203105927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify critical nodes based on their contribution to both objectives\n    node_contributions = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        node_contributions.append(cost1 + cost2)\n\n    # Find most critical nodes\n    sorted_indices = np.argsort(node_contributions)[::-1]\n    critical_nodes = sorted_indices[:max(2, n//5)]\n\n    # Adaptive node insertion: remove and reinsert critical nodes\n    for node_idx in critical_nodes:\n        node = new_solution[node_idx]\n        # Remove node\n        new_solution = np.delete(new_solution, node_idx)\n        # Find best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n        for i in range(len(new_solution)):\n            prev = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n        # Insert node\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping: flip edges that improve one objective while not worsening the other\n    for i in range(n-2):\n        a, b, c = new_solution[i], new_solution[i+1], new_solution[i+2]\n        original_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n        original_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n        flipped_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n        flipped_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n\n        if (flipped_cost1 < original_cost1 and flipped_cost2 <= original_cost2) or \\\n           (flipped_cost2 < original_cost2 and flipped_cost1 <= original_cost1):\n            new_solution[i+1], new_solution[i+2] = new_solution[i+2], new_solution[i+1]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping, while ensuring feasibility and diversity through a novel selection criterion that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted sum of objectives)\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    # Node relocation\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping with diversity consideration\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if abs(i - j) > 1:  # Ensure meaningful swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9246757344848193,
            2.6510486006736755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted sum of objectives)\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    # Node relocation\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping with diversity consideration\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if abs(i - j) > 1:  # Ensure meaningful swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines multi-objective path inversion with adaptive node swapping to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective path inversion: invert segments based on both objectives\n    segment_scores = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_scores.append((cost1 + cost2) / (cost1 * cost2 + 1e-10))  # Harmonic mean for balance\n\n    # Find the most balanced segment to invert\n    target_index = np.argmax(segment_scores)\n    segment_length = min(3, n - target_index - 1)  # Limit segment length\n\n    # Invert the selected segment\n    segment_start = target_index\n    segment_end = target_index + segment_length\n    new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n    # Adaptive node swapping: swap nodes based on objective dominance\n    for i in range(n):\n        for j in range(i+1, n):\n            # Check if swapping improves both objectives\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n               (new_cost1 <= original_cost1 and new_cost2 < original_cost2 and np.random.rand() < 0.3) or \\\n               (new_cost1 < original_cost1 and new_cost2 <= original_cost2 and np.random.rand() < 0.3):\n                # Perform the swap\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n                break\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8513145539770252,
            3.3265299201011658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective path inversion: invert segments based on both objectives\n    segment_scores = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_scores.append((cost1 + cost2) / (cost1 * cost2 + 1e-10))  # Harmonic mean for balance\n\n    # Find the most balanced segment to invert\n    target_index = np.argmax(segment_scores)\n    segment_length = min(3, n - target_index - 1)  # Limit segment length\n\n    # Invert the selected segment\n    segment_start = target_index\n    segment_end = target_index + segment_length\n    new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n    # Adaptive node swapping: swap nodes based on objective dominance\n    for i in range(n):\n        for j in range(i+1, n):\n            # Check if swapping improves both objectives\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n               (new_cost1 <= original_cost1 and new_cost2 < original_cost2 and np.random.rand() < 0.3) or \\\n               (new_cost1 < original_cost1 and new_cost2 <= original_cost2 and np.random.rand() < 0.3):\n                # Perform the swap\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n                break\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"objective-biased\" segment relocation with a multi-objective edge insertion to explore the solution space while balancing both objectives and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives and diversity\n    selected_idx = np.argmax([(sum(obj) / (1 + np.std(obj))) for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Objective-biased segment relocation\n    obj_weights = archive[selected_idx][1]\n    total_weight = sum(obj_weights)\n    prob = [w/total_weight for w in obj_weights]\n\n    if np.random.rand() < prob[0]:\n        # Relocate segment based on first objective\n        segment_len = min(3, n//4)\n        start = np.random.randint(1, n-segment_len)\n        segment = new_solution[start:start+segment_len]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_len:], segment])\n        insert_pos = np.random.randint(1, n-segment_len+1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:\n        # Relocate segment based on second objective\n        segment_len = min(4, n//3)\n        start = np.random.randint(1, n-segment_len)\n        segment = new_solution[start:start+segment_len]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_len:]])\n        insert_pos = np.random.randint(1, n-segment_len+1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Multi-objective edge insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_a, node_b = new_solution[a], new_solution[b]\n\n    if np.random.rand() < 0.5:\n        # Insert based on first objective\n        candidates = np.argsort(distance_matrix_1[node_a] + distance_matrix_1[node_b])\n    else:\n        # Insert based on second objective\n        candidates = np.argsort(distance_matrix_2[node_a] + distance_matrix_2[node_b])\n\n    for candidate in candidates:\n        if candidate not in new_solution:\n            new_solution = np.insert(new_solution, a+1, candidate)\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6465376847295593,
            7.761234760284424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives and diversity\n    selected_idx = np.argmax([(sum(obj) / (1 + np.std(obj))) for _, obj in archive])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Objective-biased segment relocation\n    obj_weights = archive[selected_idx][1]\n    total_weight = sum(obj_weights)\n    prob = [w/total_weight for w in obj_weights]\n\n    if np.random.rand() < prob[0]:\n        # Relocate segment based on first objective\n        segment_len = min(3, n//4)\n        start = np.random.randint(1, n-segment_len)\n        segment = new_solution[start:start+segment_len]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_len:], segment])\n        insert_pos = np.random.randint(1, n-segment_len+1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:\n        # Relocate segment based on second objective\n        segment_len = min(4, n//3)\n        start = np.random.randint(1, n-segment_len)\n        segment = new_solution[start:start+segment_len]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_len:]])\n        insert_pos = np.random.randint(1, n-segment_len+1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Multi-objective edge insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_a, node_b = new_solution[a], new_solution[b]\n\n    if np.random.rand() < 0.5:\n        # Insert based on first objective\n        candidates = np.argsort(distance_matrix_1[node_a] + distance_matrix_1[node_b])\n    else:\n        # Insert based on second objective\n        candidates = np.argsort(distance_matrix_2[node_a] + distance_matrix_2[node_b])\n\n    for candidate in candidates:\n        if candidate not in new_solution:\n            new_solution = np.insert(new_solution, a+1, candidate)\n            break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Multi-objective node swap: swap node at position c with another node if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        swap_pos = np.random.choice(range(1, n-1))\n        if swap_pos != c:\n            swap_node = new_solution[swap_pos]\n\n            original_cost1 = distance_matrix_1[new_solution[c-1], node] + distance_matrix_1[node, new_solution[c+1]] + \\\n                             distance_matrix_1[new_solution[swap_pos-1], swap_node] + distance_matrix_1[swap_node, new_solution[swap_pos+1]]\n            original_cost2 = distance_matrix_2[new_solution[c-1], node] + distance_matrix_2[node, new_solution[c+1]] + \\\n                             distance_matrix_2[new_solution[swap_pos-1], swap_node] + distance_matrix_2[swap_node, new_solution[swap_pos+1]]\n\n            new_cost1 = distance_matrix_1[new_solution[c-1], swap_node] + distance_matrix_1[swap_node, new_solution[c+1]] + \\\n                         distance_matrix_1[new_solution[swap_pos-1], node] + distance_matrix_1[node, new_solution[swap_pos+1]]\n            new_cost2 = distance_matrix_2[new_solution[c-1], swap_node] + distance_matrix_2[swap_node, new_solution[c+1]] + \\\n                         distance_matrix_2[new_solution[swap_pos-1], node] + distance_matrix_2[node, new_solution[swap_pos+1]]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution[c], new_solution[swap_pos] = new_solution[swap_pos], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6112912999588556,
            2.498090982437134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Multi-objective node swap: swap node at position c with another node if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        swap_pos = np.random.choice(range(1, n-1))\n        if swap_pos != c:\n            swap_node = new_solution[swap_pos]\n\n            original_cost1 = distance_matrix_1[new_solution[c-1], node] + distance_matrix_1[node, new_solution[c+1]] + \\\n                             distance_matrix_1[new_solution[swap_pos-1], swap_node] + distance_matrix_1[swap_node, new_solution[swap_pos+1]]\n            original_cost2 = distance_matrix_2[new_solution[c-1], node] + distance_matrix_2[node, new_solution[c+1]] + \\\n                             distance_matrix_2[new_solution[swap_pos-1], swap_node] + distance_matrix_2[swap_node, new_solution[swap_pos+1]]\n\n            new_cost1 = distance_matrix_1[new_solution[c-1], swap_node] + distance_matrix_1[swap_node, new_solution[c+1]] + \\\n                         distance_matrix_1[new_solution[swap_pos-1], node] + distance_matrix_1[node, new_solution[swap_pos+1]]\n            new_cost2 = distance_matrix_2[new_solution[c-1], swap_node] + distance_matrix_2[swap_node, new_solution[c+1]] + \\\n                         distance_matrix_2[new_solution[swap_pos-1], node] + distance_matrix_2[node, new_solution[swap_pos+1]]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution[c], new_solution[swap_pos] = new_solution[swap_pos], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This new algorithm selects a solution from the archive based on its non-dominated status and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge exchange to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the non-dominated solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Multi-objective edge exchange: swap two edges if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if i != j and abs(i - j) > 1:\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j]\n\n        original_cost1 = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n        original_cost2 = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n\n        new_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[i], next_j]\n        new_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[i], next_j]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5801214228055148,
            1.7238454222679138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the non-dominated solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Multi-objective edge exchange: swap two edges if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if i != j and abs(i - j) > 1:\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j]\n\n        original_cost1 = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n        original_cost2 = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n\n        new_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[i], next_j]\n        new_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[i], next_j]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted sum of objectives with random weights, then applies a hybrid local search combining 2-opt with a novel segment rotation to balance both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using random weighted sum of objectives\n    weights = np.random.uniform(0.1, 0.9, size=2)\n    selected_solution = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    segment = new_solution[segment_start:segment_start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    new_solution[segment_start:segment_start+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection mechanism that combines objective values with solution structure diversity, then applies a hybrid local search combining a novel segment inversion with a guided segment rotation to balance both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity and objective balance\n    def diversity_score(sol):\n        obj1, obj2 = sol[1]\n        diversity = np.mean([np.abs(distance_matrix_1[sol[0][i]][sol[0][i+1]] - distance_matrix_2[sol[0][i]][sol[0][i+1]]) for i in range(len(sol[0])-1)])\n        return (obj1 + obj2) / (1 + diversity)\n\n    selected_solution = min(archive, key=diversity_score)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: guided segment inversion\n    i, j = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    if np.random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Guided rotation based on objective differences\n        segment = new_solution[i:j+1]\n        obj_diff = np.mean([distance_matrix_1[segment[k]][segment[k+1]] - distance_matrix_2[segment[k]][segment[k+1]] for k in range(len(segment)-1)])\n        rotation = 1 if obj_diff > 0 else -1\n        new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7679737180044413,
            7.459846615791321
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity and objective balance\n    def diversity_score(sol):\n        obj1, obj2 = sol[1]\n        diversity = np.mean([np.abs(distance_matrix_1[sol[0][i]][sol[0][i+1]] - distance_matrix_2[sol[0][i]][sol[0][i+1]]) for i in range(len(sol[0])-1)])\n        return (obj1 + obj2) / (1 + diversity)\n\n    selected_solution = min(archive, key=diversity_score)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: guided segment inversion\n    i, j = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    if np.random.random() < 0.5:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Guided rotation based on objective differences\n        segment = new_solution[i:j+1]\n        obj_diff = np.mean([distance_matrix_1[segment[k]][segment[k+1]] - distance_matrix_2[segment[k]][segment[k+1]] for k in range(len(segment)-1)])\n        rotation = 1 if obj_diff > 0 else -1\n        new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment rotation, node transposition, and edge inversion to generate a neighbor solution while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (weighted sum)\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation, node transposition, and edge inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Segment rotation: move segment [a:b] to position c and rotate it\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Node transposition: swap two nodes with different positions\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge inversion: invert a random edge\n    k = np.random.choice(range(1, n-1))\n    new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9124975593865474,
            1.0185151100158691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (weighted sum)\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation, node transposition, and edge inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Segment rotation: move segment [a:b] to position c and rotate it\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Node transposition: swap two nodes with different positions\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge inversion: invert a random edge\n    k = np.random.choice(range(1, n-1))\n    new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted sum of objectives with random weights, then applies a hybrid local search combining 2-opt with a novel segment rotation to balance both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using random weighted sum of objectives\n    weights = np.random.uniform(0.1, 0.9, size=2)\n    selected_solution = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    segment = new_solution[segment_start:segment_start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    new_solution[segment_start:segment_start+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel multi-objective diversity metric, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node exchange to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on multi-objective diversity metric\n    objectives = np.array([sol[1] for sol in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity = np.sum(normalized, axis=1) * np.prod(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Multi-objective node exchange\n    if c > 0 and c < n-1:\n        node1 = new_solution[c]\n        node2 = new_solution[c+1]\n\n        # Calculate original costs\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+2] if c+2 < n else new_solution[0]\n\n        original_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, next_node]\n\n        # Try exchanging nodes\n        new_cost1 = distance_matrix_1[prev_node, node2] + distance_matrix_1[node2, node1] + distance_matrix_1[node1, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node2] + distance_matrix_2[node2, node1] + distance_matrix_2[node1, next_node]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[c], new_solution[c+1] = new_solution[c+1], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9610973024888314,
            2.3727179765701294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on multi-objective diversity metric\n    objectives = np.array([sol[1] for sol in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity = np.sum(normalized, axis=1) * np.prod(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Multi-objective node exchange\n    if c > 0 and c < n-1:\n        node1 = new_solution[c]\n        node2 = new_solution[c+1]\n\n        # Calculate original costs\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+2] if c+2 < n else new_solution[0]\n\n        original_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, next_node]\n\n        # Try exchanging nodes\n        new_cost1 = distance_matrix_1[prev_node, node2] + distance_matrix_1[node2, node1] + distance_matrix_1[node1, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node2] + distance_matrix_2[node2, node1] + distance_matrix_2[node1, next_node]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[c], new_solution[c+1] = new_solution[c+1], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment insertion and inversion hybrid operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, applies a dynamic segment relocation and reversal hybrid operator with variable segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with adaptive weights\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = np.random.uniform(0.3, 0.7, size=2)  # Random adaptive weights\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment relocation and reversal\n    segment_len = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(1, n-segment_len)\n    segment = new_solution[start:start+segment_len]\n\n    # Relocate segment\n    new_pos = np.random.randint(1, n-segment_len)\n    if new_pos >= start:\n        new_pos += segment_len\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_len:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Reverse another segment\n    rev_start = np.random.randint(1, n-2)\n    rev_len = np.random.randint(2, min(4, n-rev_start))\n    new_solution[rev_start:rev_start+rev_len] = new_solution[rev_start:rev_start+rev_len][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6385112438881497,
            1.338456392288208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with adaptive weights\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = np.random.uniform(0.3, 0.7, size=2)  # Random adaptive weights\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment relocation and reversal\n    segment_len = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(1, n-segment_len)\n    segment = new_solution[start:start+segment_len]\n\n    # Relocate segment\n    new_pos = np.random.randint(1, n-segment_len)\n    if new_pos >= start:\n        new_pos += segment_len\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_len:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Reverse another segment\n    rev_start = np.random.randint(1, n-2)\n    rev_len = np.random.randint(2, min(4, n-rev_start))\n    new_solution[rev_start:rev_start+rev_len] = new_solution[rev_start:rev_start+rev_len][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining node insertion with a novel segment inversion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node insertion with segment inversion\n    i = np.random.randint(1, n-1)\n    j = np.random.randint(1, n-1)\n    while j == i:\n        j = np.random.randint(1, n-1)\n\n    # Insert node at position j\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k:k+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7074053557639352,
            1.7670042514801025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node insertion with segment inversion\n    i = np.random.randint(1, n-1)\n    j = np.random.randint(1, n-1)\n    while j == i:\n        j = np.random.randint(1, n-1)\n\n    # Insert node at position j\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k:k+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of its objective values, then applies a hybrid local search combining segment relocation, edge swapping, and node reinsertion to explore the solution space while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective (prioritize sum but consider individual objectives)\n    weights = np.array([0.7, 0.3])  # Higher weight for first objective\n    selected_solution = max(archive, key=lambda x: np.dot(weights, x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment relocation, edge swapping, and node reinsertion\n    # Segment relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.choice(range(1, len(new_solution)))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Edge swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9067157533555033,
            2.7565435767173767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective (prioritize sum but consider individual objectives)\n    weights = np.array([0.7, 0.3])  # Higher weight for first objective\n    selected_solution = max(archive, key=lambda x: np.dot(weights, x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment relocation, edge swapping, and node reinsertion\n    # Segment relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.choice(range(1, len(new_solution)))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Edge swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node reinsertion\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining segment shuffling with a novel objective-aware edge insertion to explore the solution space while balancing both objectives and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shuffling with objective-aware edge insertion\n    # Randomly select a segment to shuffle\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Calculate the total cost for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    cost1_before = calculate_cost(new_solution, distance_matrix_1)\n    cost2_before = calculate_cost(new_solution, distance_matrix_2)\n\n    # Randomly select two nodes to potentially insert between\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[i]\n    node2 = new_solution[j]\n\n    # Try inserting node1 between node2 and its successor\n    temp_solution = new_solution.copy()\n    temp_solution = np.delete(temp_solution, i)\n    insert_pos = np.where(temp_solution == node2)[0][0] + 1\n    temp_solution = np.insert(temp_solution, insert_pos, node1)\n\n    cost1_after = calculate_cost(temp_solution, distance_matrix_1)\n    cost2_after = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept the insertion if it improves at least one objective\n    if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n        new_solution = temp_solution.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6906004694554269,
            2.5832239389419556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shuffling with objective-aware edge insertion\n    # Randomly select a segment to shuffle\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Calculate the total cost for each objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(n):\n            cost += distance_matrix[solution[i], solution[(i+1)%n]]\n        return cost\n\n    cost1_before = calculate_cost(new_solution, distance_matrix_1)\n    cost2_before = calculate_cost(new_solution, distance_matrix_2)\n\n    # Randomly select two nodes to potentially insert between\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[i]\n    node2 = new_solution[j]\n\n    # Try inserting node1 between node2 and its successor\n    temp_solution = new_solution.copy()\n    temp_solution = np.delete(temp_solution, i)\n    insert_pos = np.where(temp_solution == node2)[0][0] + 1\n    temp_solution = np.insert(temp_solution, insert_pos, node1)\n\n    cost1_after = calculate_cost(temp_solution, distance_matrix_1)\n    cost2_after = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Accept the insertion if it improves at least one objective\n    if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n        new_solution = temp_solution.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted objective score, applies a hybrid operator combining node insertion and segment reversal, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted objective selection (prioritize solutions with better balance)\n    weighted_scores = [0.4 * obj[0] + 0.6 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: node insertion and segment reversal\n    a = np.random.randint(1, n-1)\n    b = np.random.randint(1, n-1)\n    while b == a:\n        b = np.random.randint(1, n-1)\n\n    # Insert node at position a\n    node = new_solution[b]\n    new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Reverse segment [c:d] (where d = c + random length)\n    c = np.random.randint(1, n-2)\n    d = min(c + np.random.randint(1, n-c-1), n-1)\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6402431506120176,
            0.953924298286438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted objective selection (prioritize solutions with better balance)\n    weighted_scores = [0.4 * obj[0] + 0.6 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: node insertion and segment reversal\n    a = np.random.randint(1, n-1)\n    b = np.random.randint(1, n-1)\n    while b == a:\n        b = np.random.randint(1, n-1)\n\n    # Insert node at position a\n    node = new_solution[b]\n    new_solution = np.concatenate([new_solution[:a], [node], new_solution[a:b], new_solution[b+1:]])\n\n    # Reverse segment [c:d] (where d = c + random length)\n    c = np.random.randint(1, n-2)\n    d = min(c + np.random.randint(1, n-c-1), n-1)\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment insertion and inversion hybrid operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment rotation and inversion hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8927454349859741,
            0.812868595123291
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8938935464095001,
            0.40162986516952515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] and insert at position c\n    segment = new_solution[a:b+1][::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d < n-1:\n        node1, node2 = new_solution[c-1], new_solution[c]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n            new_solution[c-1], new_solution[d] = new_solution[d], new_solution[c-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8938935464095001,
            0.40162986516952515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining objective values and diversity, applies a segment swap and inversion hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid score combining objectives and diversity\n    scores = [(sum(obj) + np.random.uniform(0, 0.1)) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment swap and inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap segments [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Invert a segment [e:f] (where f = e + random length)\n    e = np.random.randint(1, n-1)\n    f = min(e + np.random.randint(1, n-e), n-1)\n    new_solution[e:f+1] = new_solution[e:f+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6015649796723249,
            1.1901171803474426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid score combining objectives and diversity\n    scores = [(sum(obj) + np.random.uniform(0, 0.1)) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment swap and inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap segments [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Invert a segment [e:f] (where f = e + random length)\n    e = np.random.randint(1, n-1)\n    f = min(e + np.random.randint(1, n-e), n-1)\n    new_solution[e:f+1] = new_solution[e:f+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This algorithm selects a solution from the archive based on the product of its objective values, then applies a novel local search strategy combining segment rotation, node swapping with distance-based selection, and adaptive edge insertion to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of objectives (balances both objectives)\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation: select a segment and rotate it\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Node swapping with distance-based selection\n    i = np.random.choice(range(1, n-1))\n    j = np.argmin(distance_matrix_1[new_solution[i], :] + distance_matrix_2[new_solution[i], :])\n    if i != j and j < n-1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge insertion: insert a node between two nodes with high combined distance\n    if n > 4:\n        k = np.random.choice(range(1, n-2))\n        l = np.argmax(distance_matrix_1[new_solution[k], :] + distance_matrix_2[new_solution[k], :])\n        if l != k and l < n-1:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7917682149634672,
            3.212510049343109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest product of objectives (balances both objectives)\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation: select a segment and rotate it\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Node swapping with distance-based selection\n    i = np.random.choice(range(1, n-1))\n    j = np.argmin(distance_matrix_1[new_solution[i], :] + distance_matrix_2[new_solution[i], :])\n    if i != j and j < n-1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive edge insertion: insert a node between two nodes with high combined distance\n    if n > 4:\n        k = np.random.choice(range(1, n-2))\n        l = np.argmax(distance_matrix_1[new_solution[k], :] + distance_matrix_2[new_solution[k], :])\n        if l != k and l < n-1:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment rotation and inversion hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This new algorithm selects a solution from the archive based on the worst objective values in either space, applies a segment crossover and mutation hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with worst objective in either space\n    objectives = np.array([obj for (_, obj) in archive])\n    worst_idx = np.argmax(np.max(objectives, axis=1))\n    selected_solution = archive[worst_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment crossover and mutation\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n\n    # Crossover segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Mutate a segment by swapping nodes\n    e = np.random.randint(1, n-2)\n    f = np.random.randint(e+1, min(e+4, n-1))\n    new_solution[e:f+1] = np.random.permutation(new_solution[e:f+1])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6773324255405577,
            1.9289070963859558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with worst objective in either space\n    objectives = np.array([obj for (_, obj) in archive])\n    worst_idx = np.argmax(np.max(objectives, axis=1))\n    selected_solution = archive[worst_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment crossover and mutation\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n\n    # Crossover segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Mutate a segment by swapping nodes\n    e = np.random.randint(1, n-2)\n    f = np.random.randint(e+1, min(e+4, n-1))\n    new_solution[e:f+1] = np.random.permutation(new_solution[e:f+1])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d > 0 and c < n-1 and d < n-1:\n        node1, node2 = new_solution[c], new_solution[c+1]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        current_cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        current_cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution[c+1], new_solution[d] = new_solution[d], new_solution[c+1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8584455106618383,
            3.0034746527671814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swap: swap edges that improve both objectives if possible\n    if c > 0 and d > 0 and c < n-1 and d < n-1:\n        node1, node2 = new_solution[c], new_solution[c+1]\n        node3, node4 = new_solution[d], new_solution[d+1]\n\n        current_cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4]\n        current_cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution[c+1], new_solution[d] = new_solution[d], new_solution[c+1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment rotation, node transposition, and edge inversion to generate a neighbor solution while ensuring feasibility through careful validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (weighted sum)\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation, node transposition, and edge inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Segment rotation: move segment [a:b] to position c and rotate it\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Node transposition: swap two nodes with different positions\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge inversion: invert a random edge\n    k = np.random.choice(range(1, n-1))\n    new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware criterion (e.g., least explored or most balanced objective values), then applies a hybrid local search combining node insertion, edge swapping, and a novel \"objective-aware\" segment inversion to generate a neighbor solution while ensuring feasibility through careful validation and objective-aware perturbation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (weighted sum)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node insertion, edge swapping, and objective-aware segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Node insertion: move a segment to a new position\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Edge swapping: swap two edges with different objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n    new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    # Objective-aware segment inversion: invert a segment based on objective dominance\n    k = np.random.choice(range(1, n-2))\n    segment_length = np.random.randint(2, min(5, n-k))\n    segment = new_solution[k:k+segment_length]\n    if distance_matrix_1[segment[0], segment[-1]] < distance_matrix_2[segment[0], segment[-1]]:\n        new_solution[k:k+segment_length] = segment[::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6560489117348459,
            1.3193188905715942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (weighted sum)\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node insertion, edge swapping, and objective-aware segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Node insertion: move a segment to a new position\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Edge swapping: swap two edges with different objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n    new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    # Objective-aware segment inversion: invert a segment based on objective dominance\n    k = np.random.choice(range(1, n-2))\n    segment_length = np.random.randint(2, min(5, n-k))\n    segment = new_solution[k:k+segment_length]\n    if distance_matrix_1[segment[0], segment[-1]] < distance_matrix_2[segment[0], segment[-1]]:\n        new_solution[k:k+segment_length] = segment[::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment insertion and inversion hybrid operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This new algorithm selects a solution from the archive using a rank-based selection scheme, applies a segment crossover and mutation operator with dynamic segment sizes, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank-based selection\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive)-1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment crossover\n    a = np.random.randint(1, n-3)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    c = np.random.randint(1, n-3)\n    d = np.random.randint(c+1, min(c+5, n-1))\n\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Dynamic mutation\n    mutation_size = max(2, min(5, int(n * 0.2)))\n    for _ in range(mutation_size):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.777465555292128,
            1.9116873145103455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank-based selection\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive)-1)\n    selected_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment crossover\n    a = np.random.randint(1, n-3)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    c = np.random.randint(1, n-3)\n    d = np.random.randint(c+1, min(c+5, n-1))\n\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Dynamic mutation\n    mutation_size = max(2, min(5, int(n * 0.2)))\n    for _ in range(mutation_size):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining a novel segment inversion with a greedy edge swap to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Segment inversion with greedy edge swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert a segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Greedy edge swap to improve objectives\n    for k in range(1, n-1):\n        a, b = new_solution[k-1], new_solution[k]\n        c, d = new_solution[k], new_solution[k+1]\n        cost1 = distance_matrix_1[a][b] + distance_matrix_1[c][d]\n        cost2 = distance_matrix_2[a][b] + distance_matrix_2[c][d]\n        new_cost1 = distance_matrix_1[a][c] + distance_matrix_1[b][d]\n        new_cost2 = distance_matrix_2[a][c] + distance_matrix_2[b][d]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.2):\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.794455147206234,
            3.809077203273773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Segment inversion with greedy edge swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert a segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Greedy edge swap to improve objectives\n    for k in range(1, n-1):\n        a, b = new_solution[k-1], new_solution[k]\n        c, d = new_solution[k], new_solution[k+1]\n        cost1 = distance_matrix_1[a][b] + distance_matrix_1[c][d]\n        cost2 = distance_matrix_2[a][b] + distance_matrix_2[c][d]\n        new_cost1 = distance_matrix_1[a][c] + distance_matrix_1[b][d]\n        new_cost2 = distance_matrix_2[a][c] + distance_matrix_2[b][d]\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.2):\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This algorithm selects the solution with the highest diversity in objectives (maximizing the difference between the two objective values) from the archive, then applies a hybrid local search combining 4-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity in objectives\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation\n    i, j, k, l = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n\n    # Perform 4-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Rotate a segment to balance objectives\n    segment_start = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    rotated_segment = np.roll(new_solution[segment_start:segment_start+segment_length], np.random.randint(1, segment_length))\n    new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6787278436966785,
            2.161552309989929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity in objectives\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation\n    i, j, k, l = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n\n    # Perform 4-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Rotate a segment to balance objectives\n    segment_start = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    rotated_segment = np.roll(new_solution[segment_start:segment_start+segment_length], np.random.randint(1, segment_length))\n    new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with high potential for improvement and applies a novel hybrid local search that combines adaptive segment relinking with objective-aware edge replacement to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest sum of objectives (most promising for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relinking: identify critical segments based on both objectives\n    segment_lengths = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        segment_lengths.append(cost1 + cost2)\n\n    # Find the two most expensive segments to relink\n    sorted_indices = np.argsort(segment_lengths)[::-1]\n    i, j = sorted_indices[0], sorted_indices[1]\n\n    # Relink segments by inserting nodes from j into i\n    segment_i = new_solution[:i+1]\n    segment_j = new_solution[i+1:j+1]\n    segment_rest = new_solution[j+1:]\n\n    # Create new relinked path\n    new_solution = np.concatenate([segment_i, segment_j[::-1], segment_rest])\n\n    # Objective-aware edge replacement: replace worst edge in one objective with best in another\n    worst_edge_obj1 = np.argmax([distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n    best_edge_obj2 = np.argmin([distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)])\n\n    if worst_edge_obj1 != best_edge_obj2:\n        # Swap nodes to replace worst edge in obj1 with best edge in obj2\n        temp = new_solution[worst_edge_obj1]\n        new_solution[worst_edge_obj1] = new_solution[best_edge_obj2]\n        new_solution[best_edge_obj2] = temp\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel hybrid operator that combines node insertion with adaptive segment swapping, ensuring feasibility by maintaining all nodes and validating the tour structure while prioritizing edges that show potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective balance (0.7 obj1, 0.3 obj2)\n    selected_solution = min(archive, key=lambda x: 0.7*x[1][0] + 0.3*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: node insertion with adaptive segment swapping\n    # Step 1: Identify nodes with high potential for improvement\n    improvement_potential = []\n    for i in range(n):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        improvement_potential.append(cost1 + cost2)\n\n    # Step 2: Select worst and best nodes based on potential\n    worst_node = np.argmax(improvement_potential)\n    best_node = np.argmin(improvement_potential)\n\n    # Step 3: Remove worst node and insert it near best node\n    removed_node = new_solution[worst_node]\n    new_solution = np.concatenate([new_solution[:worst_node], new_solution[worst_node+1:]])\n    insert_pos = (best_node + 1) % (n-1)\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Step 4: Adaptive segment swapping based on objective dominance\n    # Identify segments where one objective dominates the other\n    obj1_dominance = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        obj1_dominance.append(cost1 < 0.7 * cost2)\n\n    # Find segments where obj1 dominates and swap them with non-dominating segments\n    dominating_segments = [i for i, dom in enumerate(obj1_dominance) if dom]\n    non_dominating_segments = [i for i, dom in enumerate(obj1_dominance) if not dom]\n\n    if dominating_segments and non_dominating_segments:\n        seg1 = dominating_segments[np.random.randint(len(dominating_segments))]\n        seg2 = non_dominating_segments[np.random.randint(len(non_dominating_segments))]\n\n        # Swap segments\n        temp = new_solution[seg1:seg1+1].copy()\n        new_solution[seg1:seg1+1] = new_solution[seg2:seg2+1]\n        new_solution[seg2:seg2+1] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6295967064235425,
            2.835887849330902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective balance (0.7 obj1, 0.3 obj2)\n    selected_solution = min(archive, key=lambda x: 0.7*x[1][0] + 0.3*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: node insertion with adaptive segment swapping\n    # Step 1: Identify nodes with high potential for improvement\n    improvement_potential = []\n    for i in range(n):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        improvement_potential.append(cost1 + cost2)\n\n    # Step 2: Select worst and best nodes based on potential\n    worst_node = np.argmax(improvement_potential)\n    best_node = np.argmin(improvement_potential)\n\n    # Step 3: Remove worst node and insert it near best node\n    removed_node = new_solution[worst_node]\n    new_solution = np.concatenate([new_solution[:worst_node], new_solution[worst_node+1:]])\n    insert_pos = (best_node + 1) % (n-1)\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Step 4: Adaptive segment swapping based on objective dominance\n    # Identify segments where one objective dominates the other\n    obj1_dominance = []\n    for i in range(n-1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        obj1_dominance.append(cost1 < 0.7 * cost2)\n\n    # Find segments where obj1 dominates and swap them with non-dominating segments\n    dominating_segments = [i for i, dom in enumerate(obj1_dominance) if dom]\n    non_dominating_segments = [i for i, dom in enumerate(obj1_dominance) if not dom]\n\n    if dominating_segments and non_dominating_segments:\n        seg1 = dominating_segments[np.random.randint(len(dominating_segments))]\n        seg2 = non_dominating_segments[np.random.randint(len(non_dominating_segments))]\n\n        # Swap segments\n        temp = new_solution[seg1:seg1+1].copy()\n        new_solution[seg1:seg1+1] = new_solution[seg2:seg2+1]\n        new_solution[seg2:seg2+1] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment rotation, node transposition, and edge inversion to generate a neighbor solution while ensuring feasibility through careful validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (weighted sum)\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation, node transposition, and edge inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Segment rotation: move segment [a:b] to position c and rotate it\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Node transposition: swap two nodes with different positions\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge inversion: invert a random edge\n    k = np.random.choice(range(1, n-1))\n    new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining segment permutation, node insertion, and path reversal to generate a neighbor solution while ensuring feasibility through comprehensive validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objectives and diversity\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + np.random.uniform(0.1, 0.3)))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation, node insertion, and path reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Segment permutation: move segment [a:b] to position c and permute it\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Node insertion: move a node to a different position\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Path reversal: reverse a random path segment\n    k = np.random.choice(range(1, n-1))\n    l = np.random.choice(range(k, min(k+5, n-1)))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8430633822794636,
            2.0181326270103455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objectives and diversity\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + np.random.uniform(0.1, 0.3)))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation, node insertion, and path reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Segment permutation: move segment [a:b] to position c and permute it\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Node insertion: move a node to a different position\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Path reversal: reverse a random path segment\n    k = np.random.choice(range(1, n-1))\n    l = np.random.choice(range(k, min(k+5, n-1)))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment rotation and inversion hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This new algorithm selects a solution from the archive using a Pareto-dominance-based selection criterion, applies a dynamic segment crossover and mutation operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance based selection\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj <= obj).all() and (other_obj < obj).any():\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment crossover and mutation\n    segment_length = np.random.randint(2, min(5, n//2))\n    a = np.random.randint(1, n-segment_length)\n    b = a + segment_length - 1\n    segment = new_solution[a:b+1]\n\n    # Adaptive segment insertion\n    c = np.random.randint(1, n-segment_length)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-segment_length)\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Mutation with adaptive segment length\n    mutation_length = np.random.randint(2, min(4, n//3))\n    d = np.random.randint(1, n-mutation_length)\n    e = d + mutation_length - 1\n    new_solution[d:e+1] = np.random.permutation(new_solution[d:e+1])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9282891419489251,
            9.462361991405487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance based selection\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj <= obj).all() and (other_obj < obj).any():\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment crossover and mutation\n    segment_length = np.random.randint(2, min(5, n//2))\n    a = np.random.randint(1, n-segment_length)\n    b = a + segment_length - 1\n    segment = new_solution[a:b+1]\n\n    # Adaptive segment insertion\n    c = np.random.randint(1, n-segment_length)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-segment_length)\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Mutation with adaptive segment length\n    mutation_length = np.random.randint(2, min(4, n//3))\n    d = np.random.randint(1, n-mutation_length)\n    e = d + mutation_length - 1\n    new_solution[d:e+1] = np.random.permutation(new_solution[d:e+1])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment rotation and inversion hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid operator that combines adaptive segment reordering with objective-biased edge swaps to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (difference between objectives)\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(diversity)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering\n    segment_size = max(2, min(5, n // 3))\n    start = np.random.randint(1, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Objective-biased edge swaps\n    obj1_cost = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    obj2_cost = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n    if obj1_cost > obj2_cost:\n        segment = segment[::-1]  # Reverse to favor objective 1\n    else:\n        segment = np.roll(segment, 1)  # Rotate to favor objective 2\n\n    new_solution[start:start+segment_size] = segment\n\n    # Additional edge optimization\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[j], new_solution[i]] +\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[j], new_solution[i]]) < (\n        distance_matrix_1[new_solution[i-1], new_solution[i]] +\n        distance_matrix_1[new_solution[j], new_solution[j+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n        distance_matrix_2[new_solution[j], new_solution[j+1]]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.38299240128170076,
            2.5388506054878235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity (difference between objectives)\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(diversity)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering\n    segment_size = max(2, min(5, n // 3))\n    start = np.random.randint(1, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Objective-biased edge swaps\n    obj1_cost = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    obj2_cost = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n    if obj1_cost > obj2_cost:\n        segment = segment[::-1]  # Reverse to favor objective 1\n    else:\n        segment = np.roll(segment, 1)  # Rotate to favor objective 2\n\n    new_solution[start:start+segment_size] = segment\n\n    # Additional edge optimization\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n        distance_matrix_1[new_solution[j], new_solution[i]] +\n        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n        distance_matrix_2[new_solution[j], new_solution[i]]) < (\n        distance_matrix_1[new_solution[i-1], new_solution[i]] +\n        distance_matrix_1[new_solution[j], new_solution[j+1]] +\n        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n        distance_matrix_2[new_solution[j], new_solution[j+1]]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This algorithm selects a well-performing solution from the archive, then applies a novel hybrid local search combining segment reversal with a multi-objective-aware edge insertion, ensuring feasibility while exploring the solution space more effectively by balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge insertion: insert a random edge if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if i != j and abs(i - j) > 1:\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j+1]\n\n        original_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n        original_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n        # Swap edges i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        new_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n        new_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n        if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8495379975478659,
            1.7463515996932983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge insertion: insert a random edge if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if i != j and abs(i - j) > 1:\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j+1]\n\n        original_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n        original_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n        # Swap edges i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        new_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n        new_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n        if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest improvement potential in either objective, then applies a novel \"objective-biased segment inversion\" operator that inverts segments while prioritizing nodes that contribute most to the weaker objective, ensuring feasibility by validating the tour structure and maintaining all nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest improvement potential (max of min objectives)\n    selected_solution = max(archive, key=lambda x: min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions per node\n    obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Identify nodes contributing most to the weaker objective\n    weaker_obj = 1 if obj1 < obj2 else 2\n    contributions = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        if weaker_obj == 1:\n            contrib = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        else:\n            contrib = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        contributions.append((contrib, i))\n\n    # Sort nodes by contribution to weaker objective (descending)\n    contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top nodes for segment inversion\n    top_nodes = [x[1] for x in contributions[:max(2, n//5)]]\n    top_nodes.sort()\n\n    # Perform objective-biased segment inversion\n    for i in range(len(top_nodes)-1):\n        a = top_nodes[i]\n        b = top_nodes[i+1]\n        if a < b:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9137532187194884,
            2.0360280871391296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest improvement potential (max of min objectives)\n    selected_solution = max(archive, key=lambda x: min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions per node\n    obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Identify nodes contributing most to the weaker objective\n    weaker_obj = 1 if obj1 < obj2 else 2\n    contributions = []\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        if weaker_obj == 1:\n            contrib = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        else:\n            contrib = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        contributions.append((contrib, i))\n\n    # Sort nodes by contribution to weaker objective (descending)\n    contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top nodes for segment inversion\n    top_nodes = [x[1] for x in contributions[:max(2, n//5)]]\n    top_nodes.sort()\n\n    # Perform objective-biased segment inversion\n    for i in range(len(top_nodes)-1):\n        a = top_nodes[i]\n        b = top_nodes[i+1]\n        if a < b:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    l = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-l))\n    inverted_segment = new_solution[l:l+segment_length][::-1]\n    new_solution[l:l+segment_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9224821054098313,
            2.2282524704933167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    l = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-l))\n    inverted_segment = new_solution[l:l+segment_length][::-1]\n    new_solution[l:l+segment_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment insertion and inversion hybrid operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-dominance criterion, applies a segment relocation and reversal hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution from the archive\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n - segment_start))\n    segment_end = segment_start + segment_length\n\n    new_position = np.random.randint(1, n - segment_length)\n    while new_position >= segment_start and new_position <= segment_end:\n        new_position = np.random.randint(1, n - segment_length)\n\n    segment = new_solution[segment_start:segment_end]\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n    if new_position < segment_start:\n        new_solution = np.concatenate([new_solution[:new_position], segment, new_solution[new_position:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_position], segment, new_solution[new_position:]])\n\n    # Reversal of a segment\n    reversal_start = np.random.randint(1, n-2)\n    reversal_length = np.random.randint(2, min(4, n - reversal_start))\n    reversal_end = reversal_start + reversal_length\n\n    new_solution[reversal_start:reversal_end] = new_solution[reversal_start:reversal_end][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8274462244782372,
            1.7163747549057007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution from the archive\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n - segment_start))\n    segment_end = segment_start + segment_length\n\n    new_position = np.random.randint(1, n - segment_length)\n    while new_position >= segment_start and new_position <= segment_end:\n        new_position = np.random.randint(1, n - segment_length)\n\n    segment = new_solution[segment_start:segment_end]\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n    if new_position < segment_start:\n        new_solution = np.concatenate([new_solution[:new_position], segment, new_solution[new_position:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_position], segment, new_solution[new_position:]])\n\n    # Reversal of a segment\n    reversal_start = np.random.randint(1, n-2)\n    reversal_length = np.random.randint(2, min(4, n - reversal_start))\n    reversal_end = reversal_start + reversal_length\n\n    new_solution[reversal_start:reversal_end] = new_solution[reversal_start:reversal_end][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swap: swap nodes c and d if it improves both objectives\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    prev_c = new_solution[c-1]\n    next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                      distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n    original_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                      distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n    new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                 distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n    new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                 distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5990285299697724,
            1.9583835005760193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swap: swap nodes c and d if it improves both objectives\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    prev_c = new_solution[c-1]\n    next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                      distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n    original_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                      distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n    new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                 distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n    new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                 distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This algorithm selects a solution with the highest Pareto dominance count (number of solutions it dominates) from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance count\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n    selected_solution = archive[np.argmax(dominance_counts)][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Invert a segment to balance objectives\n    l = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-l))\n    new_solution[l:l+segment_length] = new_solution[l:l+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8891944973824195,
            2.2576204538345337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance count\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n    selected_solution = archive[np.argmax(dominance_counts)][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    # Invert a segment to balance objectives\n    l = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-l))\n    new_solution[l:l+segment_length] = new_solution[l:l+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping with adaptive probabilities to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted sum of objectives)\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with adaptive probabilities\n    operation = np.random.choice(['relocate', 'invert', 'swap'], p=[0.4, 0.3, 0.3])\n\n    if operation == 'relocate':\n        # Node relocation\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.choice(range(1, n))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operation == 'invert':\n        # Segment inversion\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    elif operation == 'swap':\n        # Edge swapping\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.865811605333686,
            1.9765225052833557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted sum of objectives)\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with adaptive probabilities\n    operation = np.random.choice(['relocate', 'invert', 'swap'], p=[0.4, 0.3, 0.3])\n\n    if operation == 'relocate':\n        # Node relocation\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.choice(range(1, n))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operation == 'invert':\n        # Segment inversion\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    elif operation == 'swap':\n        # Edge swapping\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining segment inversion with a novel node swapping strategy that prioritizes improving both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the non-dominated solution with the highest combined objective value\n    def is_dominated(a, b):\n        return a[0] >= b[0] and a[1] >= b[1] and (a[0] > b[0] or a[1] > b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        selected_solution = max(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with node swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [i:j]\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Swap nodes at positions k and l\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.675208349689062,
            2.3535327315330505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the non-dominated solution with the highest combined objective value\n    def is_dominated(a, b):\n        return a[0] >= b[0] and a[1] >= b[1] and (a[0] > b[0] or a[1] > b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        selected_solution = max(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with node swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [i:j]\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Swap nodes at positions k and l\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This new algorithm selects a solution from the archive based on the dominance of its objectives, applies a segment inversion and position swap hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select the one with the best combined objective\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if non_dominated:\n        selected_solution = min(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment inversion and position swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Swap positions [c] and [d]\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7211593257379716,
            2.7447428703308105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select the one with the best combined objective\n    non_dominated = [sol for sol in archive if not any(all(sol[1][i] >= other[1][i] for i in range(2)) and any(sol[1][i] > other[1][i] for i in range(2)) for other in archive)]\n    if non_dominated:\n        selected_solution = min(non_dominated, key=lambda x: sum(x[1]))[0].copy()\n    else:\n        selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment inversion and position swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Swap positions [c] and [d]\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment rotation and inversion hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment insertion and inversion hybrid operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto dominance-aware criterion, applies a novel segment reversal and swap hybrid operator with dynamic segment lengths and adaptive swap probability, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance-aware criterion\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment reversal and adaptive node swap\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive node swap probability based on solution quality\n    swap_prob = 0.3 + 0.2 * (1 - sum(objectives[selected_idx]) / (objectives.max(axis=0).sum() + 1e-8))\n    if np.random.rand() < swap_prob:\n        c = np.random.randint(1, n-1)\n        d = np.random.randint(1, n-1)\n        while d == c:\n            d = np.random.randint(1, n-1)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7640409266397052,
            8.066240072250366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance-aware criterion\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment reversal and adaptive node swap\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive node swap probability based on solution quality\n    swap_prob = 0.3 + 0.2 * (1 - sum(objectives[selected_idx]) / (objectives.max(axis=0).sum() + 1e-8))\n    if np.random.rand() < swap_prob:\n        c = np.random.randint(1, n-1)\n        d = np.random.randint(1, n-1)\n        while d == c:\n            d = np.random.randint(1, n-1)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a segment relocation and reversal hybrid operator to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives (middle ground)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    selected_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Reverse another segment [d:e] (where e = d + random length)\n    e = min(d + np.random.randint(1, n-d), n-1)\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This new algorithm selects a solution from the archive based on the dominance relationship between objectives, applies a hybrid operator combining segment relocation and a novel edge-swap mechanism to generate a neighbor, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with balanced objectives\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                if archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]:\n                    dominated[i] = True\n                    break\n\n    non_dominated = [s for i, s in enumerate(archive) if not dominated[i]]\n    if not non_dominated:\n        non_dominated = archive\n\n    sorted_non_dominated = sorted(non_dominated, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = sorted_non_dominated[len(sorted_non_dominated) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.randint(1, n-1)\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Edge swap: swap two edges that are not adjacent\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if abs(i-j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7248741391777944,
            1.0912702083587646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with balanced objectives\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                if archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]:\n                    dominated[i] = True\n                    break\n\n    non_dominated = [s for i, s in enumerate(archive) if not dominated[i]]\n    if not non_dominated:\n        non_dominated = archive\n\n    sorted_non_dominated = sorted(non_dominated, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = sorted_non_dominated[len(sorted_non_dominated) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: segment relocation and edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.randint(1, n-1)\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Edge swap: swap two edges that are not adjacent\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if abs(i-j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9462150820560888,
            0.8009148240089417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment insertion and inversion hybrid operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment crossover and adaptive inversion operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with normalized objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores[:, 0] * 0.7 + normalized_scores[:, 1] * 0.3\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment crossover and adaptive inversion\n    a = np.random.randint(1, n-3)\n    b = np.random.randint(a+1, min(a+5, n-2))\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Crossover segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:c+(b-a+1)]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:]])\n\n    # Adaptive inversion\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8959412060998104,
            13.114044308662415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with normalized objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores[:, 0] * 0.7 + normalized_scores[:, 1] * 0.3\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment crossover and adaptive inversion\n    a = np.random.randint(1, n-3)\n    b = np.random.randint(a+1, min(a+5, n-2))\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Crossover segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:c+(b-a+1)]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:]])\n\n    # Adaptive inversion\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment rotation and inversion hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded areas, then applies a segment crossover and mutation hybrid operator with adaptive segment lengths to generate diverse neighbors while ensuring feasibility through tour validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_idx = np.lexsort((objectives[:,1], objectives[:,0]))\n    sorted_obj = objectives[sorted_idx]\n    crowding = np.zeros(len(sorted_obj))\n\n    for i in range(len(objectives[0])):\n        sorted_obj = sorted_obj[np.argsort(sorted_obj[:,i])]\n        crowding[1:-1] += (sorted_obj[2:,i] - sorted_obj[:-2,i]) / (sorted_obj[-1,i] - sorted_obj[0,i] + 1e-8)\n\n    selected_idx = sorted_idx[np.argmax(crowding)]\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment crossover and mutation\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:]])\n    new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:]])\n\n    # Adaptive mutation\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8630058062210701,
            2.6587453484535217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_idx = np.lexsort((objectives[:,1], objectives[:,0]))\n    sorted_obj = objectives[sorted_idx]\n    crowding = np.zeros(len(sorted_obj))\n\n    for i in range(len(objectives[0])):\n        sorted_obj = sorted_obj[np.argsort(sorted_obj[:,i])]\n        crowding[1:-1] += (sorted_obj[2:,i] - sorted_obj[:-2,i]) / (sorted_obj[-1,i] - sorted_obj[0,i] + 1e-8)\n\n    selected_idx = sorted_idx[np.argmax(crowding)]\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment crossover and mutation\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:]])\n    new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:]])\n\n    # Adaptive mutation\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search combining segment rotation, node swapping, and partial inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential based on weighted objectives\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation, node swapping, and partial inversion\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Partial inversion\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8446490458165229,
            2.519492447376251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential based on weighted objectives\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation, node swapping, and partial inversion\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swapping\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Partial inversion\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment rotation and inversion hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9201101531652884,
            0.8819664716720581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a segment insertion and inversion hybrid operator with adaptive segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted objectives\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = [sum(weights * np.array(obj)) for (_, obj) in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: adaptive segment insertion and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+4, n-1))  # Smaller segment\n    c = np.random.randint(1, n-1)\n    while c == a or c == b:\n        c = np.random.randint(1, n-1)\n\n    # Insert segment [a:b] after position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment [d:e] with adaptive length\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+3, n-1))  # Smaller segment\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware selection strategy, then applies a novel hybrid local search combining node sequence shifting, partial tour reversal with objective-aware segment selection, and adaptive edge reinsertion to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is not dominated by others in the archive\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node sequence shifting\n    shift_size = np.random.randint(1, min(3, n//2))\n    shift_pos = np.random.randint(1, n-shift_size)\n    segment = new_solution[shift_pos:shift_pos+shift_size]\n    new_solution = np.concatenate([new_solution[:shift_pos], new_solution[shift_pos+shift_size:], segment])\n\n    # Partial tour reversal with objective-aware segment selection\n    if np.random.rand() < 0.7:  # Higher probability for this operation\n        a = np.random.randint(1, n-2)\n        b = np.random.randint(a+1, min(a+5, n-1))\n        # Check if reversing this segment improves at least one objective\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive edge reinsertion\n    if np.random.rand() < 0.5:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i-1 or j == (i+1)%n:\n            j = np.random.randint(1, n-1)\n        # Remove edge (i, i+1) and reinsert it between (j, j+1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = j if j < len(new_solution)-1 else len(new_solution)-1\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8011816974716388,
            2.2735989689826965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is not dominated by others in the archive\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node sequence shifting\n    shift_size = np.random.randint(1, min(3, n//2))\n    shift_pos = np.random.randint(1, n-shift_size)\n    segment = new_solution[shift_pos:shift_pos+shift_size]\n    new_solution = np.concatenate([new_solution[:shift_pos], new_solution[shift_pos+shift_size:], segment])\n\n    # Partial tour reversal with objective-aware segment selection\n    if np.random.rand() < 0.7:  # Higher probability for this operation\n        a = np.random.randint(1, n-2)\n        b = np.random.randint(a+1, min(a+5, n-1))\n        # Check if reversing this segment improves at least one objective\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive edge reinsertion\n    if np.random.rand() < 0.5:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i-1 or j == (i+1)%n:\n            j = np.random.randint(1, n-1)\n        # Remove edge (i, i+1) and reinsert it between (j, j+1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = j if j < len(new_solution)-1 else len(new_solution)-1\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining a novel segment inversion with a cross-swap operation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with cross-swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert a segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Cross-swap operation\n    k = np.random.randint(1, n-1)\n    l = np.random.randint(1, n-1)\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.812481077041525,
            2.208763003349304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with cross-swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert a segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Cross-swap operation\n    k = np.random.randint(1, n-1)\n    l = np.random.randint(1, n-1)\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This new algorithm selects a solution from the archive based on its balance between objectives, then applies a hybrid local search combining a novel segment crossover with multi-objective edge optimization to explore the solution space while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective edge optimization\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform segment crossover between [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Multi-objective edge optimization: swap edges that improve both objectives\n    for _ in range(10):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j+1]\n\n        current_cost1 = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n        current_cost2 = (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j])\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6272299877510734,
            1.8442305326461792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective edge optimization\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform segment crossover between [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Multi-objective edge optimization: swap edges that improve both objectives\n    for _ in range(10):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j+1]\n\n        current_cost1 = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n        current_cost2 = (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j])\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized objective values and applies a hybrid local search combining a novel segment insertion with a multi-objective-aware node exchange, which exchanges two nodes in a way that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best normalized objective values\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    if max_cost1 == 0 or max_cost2 == 0:\n        selected_solution = archive[0][0].copy()\n    else:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))\n        selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment insertion with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Try inserting the segment at a different position\n    new_pos = np.random.choice(range(1, n-1))\n    if new_pos >= a and new_pos <= b:\n        return new_solution\n\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:new_pos], segment, new_solution[new_pos:]])\n\n    # Node exchange: exchange two nodes if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate costs before exchange\n    cost1_before = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] +\n                   distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]])\n    cost2_before = (distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] +\n                    distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]])\n\n    # Calculate costs after exchange\n    cost1_after = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] +\n                   distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]])\n    cost2_after = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] +\n                   distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]])\n\n    if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6152797526435774,
            2.1931074261665344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best normalized objective values\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    if max_cost1 == 0 or max_cost2 == 0:\n        selected_solution = archive[0][0].copy()\n    else:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))\n        selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment insertion with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Try inserting the segment at a different position\n    new_pos = np.random.choice(range(1, n-1))\n    if new_pos >= a and new_pos <= b:\n        return new_solution\n\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:new_pos], segment, new_solution[new_pos:]])\n\n    # Node exchange: exchange two nodes if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate costs before exchange\n    cost1_before = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] +\n                   distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]])\n    cost2_before = (distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] +\n                    distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]])\n\n    # Calculate costs after exchange\n    cost1_after = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] +\n                   distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]])\n    cost2_after = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] +\n                   distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]])\n\n    if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion, which rotates a segment of nodes and inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n    # Try to insert the rotated segment back in a way that improves both objectives\n    for pos in range(1, n-1):\n        if pos >= a and pos <= b:\n            continue\n\n        # Calculate costs if we insert the rotated segment here\n        if pos < a:\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n            current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n            current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n            new_cost1 = distance_matrix_1[new_prev, rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], new_next]\n            new_cost2 = distance_matrix_2[new_prev, rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], new_next]\n        else:\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n            current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n            current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n            new_cost1 = distance_matrix_1[new_prev, rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], new_next]\n            new_cost2 = distance_matrix_2[new_prev, rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], new_next]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the original segment and insert the rotated segment\n            new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b+1:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.79557680057107,
            1.8870287537574768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n    # Try to insert the rotated segment back in a way that improves both objectives\n    for pos in range(1, n-1):\n        if pos >= a and pos <= b:\n            continue\n\n        # Calculate costs if we insert the rotated segment here\n        if pos < a:\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n            current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n            current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n            new_cost1 = distance_matrix_1[new_prev, rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], new_next]\n            new_cost2 = distance_matrix_2[new_prev, rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], new_next]\n        else:\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n            current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n            current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n            new_cost1 = distance_matrix_1[new_prev, rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], new_next]\n            new_cost2 = distance_matrix_2[new_prev, rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], new_next]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the original segment and insert the rotated segment\n            new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b+1:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score, applies a segment rotation and inversion hybrid operator with dynamic segment lengths, and ensures feasibility by validating the tour structure while maintaining all nodes in the solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid operator: segment rotation and inversion\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    k = np.random.randint(1, len(segment))\n    rotated = np.roll(segment, k)\n\n    # Insert rotated segment\n    c = np.random.randint(1, n-1)\n    while c in range(a, b+1):\n        c = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:c+1], rotated, new_solution[c+1:] if c+1 < a else new_solution[c+1:]])\n\n    # Invert another segment\n    d = np.random.randint(1, n-2)\n    e = np.random.randint(d+1, min(d+4, n-1))\n    new_solution[d:e+1] = new_solution[d:e+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware metric, then applies a novel hybrid local search combining a dynamic segment relocation with a multi-objective edge swapping operator to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (measured by objective variance)\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n    diversity_score = np.sum(diversity)\n    selected_idx = np.argmax(diversity_score) if len(archive) > 1 else 0\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: dynamic segment relocation with multi-objective edge swapping\n    segment_length = np.random.randint(2, min(5, n//2))\n    a = np.random.randint(1, n-segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Relocate segment to a new position\n    c = np.random.randint(1, n-segment_length)\n    while abs(c - a) < segment_length:\n        c = np.random.randint(1, n-segment_length)\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_length:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if i == j or j == i+1:\n            continue\n\n        # Current edges\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[i], new_solution[i+1]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[j], new_solution[j+1])\n        ]\n\n        # New edges after swap\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j], new_solution[i+1]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[i], new_solution[j+1])\n        ]\n\n        # Calculate cost differences\n        delta1 = sum(distance_matrix_1[u, v] for u, v in new_edges) - sum(distance_matrix_1[u, v] for u, v in current_edges)\n        delta2 = sum(distance_matrix_2[u, v] for u, v in new_edges) - sum(distance_matrix_2[u, v] for u, v in current_edges)\n\n        if (delta1 < 0 and delta2 < 0) or (np.random.random() < 0.3):\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8761598438406633,
            1.5737628936767578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (measured by objective variance)\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n    diversity_score = np.sum(diversity)\n    selected_idx = np.argmax(diversity_score) if len(archive) > 1 else 0\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: dynamic segment relocation with multi-objective edge swapping\n    segment_length = np.random.randint(2, min(5, n//2))\n    a = np.random.randint(1, n-segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Relocate segment to a new position\n    c = np.random.randint(1, n-segment_length)\n    while abs(c - a) < segment_length:\n        c = np.random.randint(1, n-segment_length)\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_length:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if i == j or j == i+1:\n            continue\n\n        # Current edges\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[i], new_solution[i+1]),\n            (new_solution[j-1], new_solution[j]),\n            (new_solution[j], new_solution[j+1])\n        ]\n\n        # New edges after swap\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[j], new_solution[i+1]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[i], new_solution[j+1])\n        ]\n\n        # Calculate cost differences\n        delta1 = sum(distance_matrix_1[u, v] for u, v in new_edges) - sum(distance_matrix_1[u, v] for u, v in current_edges)\n        delta2 = sum(distance_matrix_2[u, v] for u, v in new_edges) - sum(distance_matrix_2[u, v] for u, v in current_edges)\n\n        if (delta1 < 0 and delta2 < 0) or (np.random.random() < 0.3):\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment reversal to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment reversal\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Reverse a segment to balance objectives\n    l = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(5, n-l))\n    new_solution[l:l+segment_length] = new_solution[l:l+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8095673761432143,
            1.8766595125198364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment reversal\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Reverse a segment to balance objectives\n    l = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(5, n-l))\n    new_solution[l:l+segment_length] = new_solution[l:l+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9813449421236852,
            2.1678643226623535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This new algorithm selects a solution from the archive based on its diversity in the objective space, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swapping to explore the solution space while balancing both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swapping\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate current and potential costs\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j+1]\n\n        current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                         distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                         distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        # Swap nodes\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                     distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                     distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        # Accept if both objectives improve or with small probability\n        if not ((new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.random() < 0.1):\n            # Revert swap\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4083579571602084,
            1.744211494922638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swapping\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate current and potential costs\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j+1]\n\n        current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                         distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                         distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        # Swap nodes\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                     distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                     distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        # Accept if both objectives improve or with small probability\n        if not ((new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.random() < 0.1):\n            # Revert swap\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive based on its proximity to the ideal point in the objective space, then applies a hybrid local search combining a novel cluster-based segment rearrangement with a multi-objective-aware node swap to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to ideal point (minimizing both objectives)\n    ideal_point = (min(obj[0] for _, obj in archive), min(obj[1] for _, obj in archive))\n    selected_solution = min(archive, key=lambda x: (x[1][0] - ideal_point[0])**2 + (x[1][1] - ideal_point[1])**2)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Cluster-based segment rearrangement\n    cluster_size = max(2, n // 5)\n    start_idx = np.random.randint(1, n - cluster_size - 1)\n    segment = new_solution[start_idx:start_idx + cluster_size]\n\n    # Rearrange segment based on distance to cluster center in both spaces\n    center = np.mean(instance[segment], axis=0)\n    dist1 = np.linalg.norm(instance[segment, :2] - center[:2], axis=1)\n    dist2 = np.linalg.norm(instance[segment, 2:] - center[2:], axis=1)\n    sorted_indices = np.argsort(dist1 + dist2)\n    new_solution[start_idx:start_idx + cluster_size] = segment[sorted_indices]\n\n    # Multi-objective-aware node swap\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate original and new costs\n        prev_i, next_i = new_solution[i-1], new_solution[i+1]\n        prev_j, next_j = new_solution[j-1], new_solution[j+1]\n\n        original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                          distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                          distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                     distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                     distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        # Accept swap if it improves both objectives or with some probability\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or np.random.random() < 0.1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7224764806337506,
            2.143440008163452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution closest to ideal point (minimizing both objectives)\n    ideal_point = (min(obj[0] for _, obj in archive), min(obj[1] for _, obj in archive))\n    selected_solution = min(archive, key=lambda x: (x[1][0] - ideal_point[0])**2 + (x[1][1] - ideal_point[1])**2)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Cluster-based segment rearrangement\n    cluster_size = max(2, n // 5)\n    start_idx = np.random.randint(1, n - cluster_size - 1)\n    segment = new_solution[start_idx:start_idx + cluster_size]\n\n    # Rearrange segment based on distance to cluster center in both spaces\n    center = np.mean(instance[segment], axis=0)\n    dist1 = np.linalg.norm(instance[segment, :2] - center[:2], axis=1)\n    dist2 = np.linalg.norm(instance[segment, 2:] - center[2:], axis=1)\n    sorted_indices = np.argsort(dist1 + dist2)\n    new_solution[start_idx:start_idx + cluster_size] = segment[sorted_indices]\n\n    # Multi-objective-aware node swap\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate original and new costs\n        prev_i, next_i = new_solution[i-1], new_solution[i+1]\n        prev_j, next_j = new_solution[j-1], new_solution[j+1]\n\n        original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                          distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                          distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                     distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                     distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        # Accept swap if it improves both objectives or with some probability\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or np.random.random() < 0.1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a novel multi-objective diversity metric, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node exchange to explore the solution space while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on multi-objective diversity metric\n    objectives = np.array([sol[1] for sol in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity = np.sum(normalized, axis=1) * np.prod(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Multi-objective node exchange\n    if c > 0 and c < n-1:\n        node1 = new_solution[c]\n        node2 = new_solution[c+1]\n\n        # Calculate original costs\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+2] if c+2 < n else new_solution[0]\n\n        original_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, next_node]\n\n        # Try exchanging nodes\n        new_cost1 = distance_matrix_1[prev_node, node2] + distance_matrix_1[node2, node1] + distance_matrix_1[node1, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node2] + distance_matrix_2[node2, node1] + distance_matrix_2[node1, next_node]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[c], new_solution[c+1] = new_solution[c+1], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on crowding distance metric\n    objectives = np.array([sol[1] for sol in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding[i] = float('inf')\n        else:\n            crowding[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    k = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] left\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion\n    if k > 0 and k < n-1:\n        node = new_solution[k]\n        new_pos = np.random.choice(range(1, n-1))\n\n        # Calculate original costs\n        original_prev = new_solution[k-1]\n        original_next = new_solution[k+1] if k+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node] + distance_matrix_1[node, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node] + distance_matrix_2[node, original_next]\n\n        # Try inserting node at new position\n        new_prev = new_solution[new_pos-1]\n        new_next = new_solution[new_pos] if new_pos < n-1 else new_solution[0]\n        new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5845202534660894,
            2.3374263048171997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on crowding distance metric\n    objectives = np.array([sol[1] for sol in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding[i] = float('inf')\n        else:\n            crowding[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    k = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] left\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion\n    if k > 0 and k < n-1:\n        node = new_solution[k]\n        new_pos = np.random.choice(range(1, n-1))\n\n        # Calculate original costs\n        original_prev = new_solution[k-1]\n        original_next = new_solution[k+1] if k+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node] + distance_matrix_1[node, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node] + distance_matrix_2[node, original_next]\n\n        # Try inserting node at new position\n        new_prev = new_solution[new_pos-1]\n        new_next = new_solution[new_pos] if new_pos < n-1 else new_solution[0]\n        new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm selects a solution from the archive based on the minimum sum of normalized objective values, then applies a hybrid local search combining segment relocation, node swapping, and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with minimum sum\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = min(\n            archive,\n            key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2)\n        )[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operations\n    # Segment relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.choice(range(1, len(new_solution)))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Node swapping\n    i, j = sorted(np.random.choice(range(1, len(new_solution)-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge reversal\n    c, d = sorted(np.random.choice(range(1, len(new_solution)-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7001761566222791,
            1.3947336673736572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with minimum sum\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = min(\n            archive,\n            key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2)\n        )[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operations\n    # Segment relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.choice(range(1, len(new_solution)))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Node swapping\n    i, j = sorted(np.random.choice(range(1, len(new_solution)-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Edge reversal\n    c, d = sorted(np.random.choice(range(1, len(new_solution)-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search that combines adaptive segment merging with biased edge reinsertion, guided by the relative strengths of each objective, while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9649523104351738,
            1.9041653871536255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Reverse segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], reversed_segment, new_solution[c:]])\n\n    # Multi-objective node swap: swap nodes that improve both objectives if possible\n    if c > 0 and c < n-1:\n        node1 = new_solution[c]\n        node2 = new_solution[c+1]\n\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+2] if c+2 < n else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, next_node]\n\n        # Try swapping with a random node in the segment\n        if len(reversed_segment) > 1:\n            swap_pos = np.random.choice(range(len(reversed_segment)))\n            node_to_swap = reversed_segment[swap_pos]\n\n            new_cost1 = (distance_matrix_1[prev_node, node_to_swap] + distance_matrix_1[node_to_swap, node2] + distance_matrix_1[node2, next_node] -\n                         distance_matrix_1[prev_node, node1] - distance_matrix_1[node1, node2] - distance_matrix_1[node2, next_node])\n            new_cost2 = (distance_matrix_2[prev_node, node_to_swap] + distance_matrix_2[node_to_swap, node2] + distance_matrix_2[node2, next_node] -\n                         distance_matrix_2[prev_node, node1] - distance_matrix_2[node1, node2] - distance_matrix_2[node2, next_node])\n\n            if (new_cost1 < 0 and new_cost2 < 0) or (np.random.random() < 0.2):\n                # Perform the swap\n                reversed_segment[swap_pos], reversed_segment[swap_pos-1 if swap_pos > 0 else -1] = reversed_segment[swap_pos-1 if swap_pos > 0 else -1], reversed_segment[swap_pos]\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], reversed_segment, new_solution[c:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9232561135110267,
            1.1824572086334229
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Reverse segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], reversed_segment, new_solution[c:]])\n\n    # Multi-objective node swap: swap nodes that improve both objectives if possible\n    if c > 0 and c < n-1:\n        node1 = new_solution[c]\n        node2 = new_solution[c+1]\n\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+2] if c+2 < n else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, next_node]\n\n        # Try swapping with a random node in the segment\n        if len(reversed_segment) > 1:\n            swap_pos = np.random.choice(range(len(reversed_segment)))\n            node_to_swap = reversed_segment[swap_pos]\n\n            new_cost1 = (distance_matrix_1[prev_node, node_to_swap] + distance_matrix_1[node_to_swap, node2] + distance_matrix_1[node2, next_node] -\n                         distance_matrix_1[prev_node, node1] - distance_matrix_1[node1, node2] - distance_matrix_1[node2, next_node])\n            new_cost2 = (distance_matrix_2[prev_node, node_to_swap] + distance_matrix_2[node_to_swap, node2] + distance_matrix_2[node2, next_node] -\n                         distance_matrix_2[prev_node, node1] - distance_matrix_2[node1, node2] - distance_matrix_2[node2, next_node])\n\n            if (new_cost1 < 0 and new_cost2 < 0) or (np.random.random() < 0.2):\n                # Perform the swap\n                reversed_segment[swap_pos], reversed_segment[swap_pos-1 if swap_pos > 0 else -1] = reversed_segment[swap_pos-1 if swap_pos > 0 else -1], reversed_segment[swap_pos]\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], reversed_segment, new_solution[c:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance criterion, then applies a hybrid local search combining a novel segment inversion with adaptive segment lengths and a biased node relocation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    selected_index = np.argmax(crowding_distances)\n    selected_solution = archive[selected_index][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with adaptive lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+10, n-1))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Biased node relocation\n    c = np.random.randint(1, n-1)\n    if np.random.rand() < 0.5:\n        if distance_matrix_1[new_solution[c-1], new_solution[c+1]] < distance_matrix_2[new_solution[c-1], new_solution[c+1]]:\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:c+2], new_solution[c:c+1], new_solution[c+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:c+2], new_solution[c:c+1], new_solution[c+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4390075689371307,
            2.689248502254486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    selected_index = np.argmax(crowding_distances)\n    selected_solution = archive[selected_index][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with adaptive lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+10, n-1))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Biased node relocation\n    c = np.random.randint(1, n-1)\n    if np.random.rand() < 0.5:\n        if distance_matrix_1[new_solution[c-1], new_solution[c+1]] < distance_matrix_2[new_solution[c-1], new_solution[c+1]]:\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:c+2], new_solution[c:c+1], new_solution[c+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:c+2], new_solution[c:c+1], new_solution[c+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in both objectives, then applies a novel hybrid local search combining a multi-segment inversion with a dynamic objective-weighted edge insertion, which intelligently reorders segments and inserts nodes based on their potential to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto front preference)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment inversion with dynamic objective-weighted edge insertion\n    # Step 1: Invert multiple non-overlapping segments\n    num_segments = np.random.randint(1, min(4, n//3))\n    segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n    positions = np.random.choice(range(1, n-max(segment_lengths)), size=num_segments, replace=False)\n\n    for pos, length in zip(positions, segment_lengths):\n        new_solution[pos:pos+length] = new_solution[pos:pos+length][::-1]\n\n    # Step 2: Dynamic objective-weighted edge insertion\n    # Calculate objective weights based on current solution's performance\n    obj1_weight = 0.5 + np.random.random() * 0.5\n    obj2_weight = 1 - obj1_weight\n\n    # Find the worst edge in both objectives\n    worst_edge1 = None\n    worst_edge2 = None\n    max_cost1 = -1\n    max_cost2 = -1\n\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        cost1 = distance_matrix_1[prev, curr]\n        cost2 = distance_matrix_2[prev, curr]\n\n        if cost1 > max_cost1:\n            max_cost1 = cost1\n            worst_edge1 = i\n        if cost2 > max_cost2:\n            max_cost2 = cost2\n            worst_edge2 = i\n\n    # Decide which edge to prioritize based on weights\n    if obj1_weight > obj2_weight:\n        target_edge = worst_edge1\n    else:\n        target_edge = worst_edge2\n\n    if target_edge is not None:\n        # Remove the target edge and insert it elsewhere optimally\n        node_to_insert = new_solution[target_edge]\n        new_solution = np.concatenate([new_solution[:target_edge], new_solution[target_edge+1:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(1, n-1):\n            prev = new_solution[pos-1]\n            curr = new_solution[pos]\n\n            # Calculate insertion cost\n            cost1 = distance_matrix_1[prev, node_to_insert] + distance_matrix_1[node_to_insert, curr]\n            cost2 = distance_matrix_2[prev, node_to_insert] + distance_matrix_2[node_to_insert, curr]\n\n            weighted_cost = obj1_weight * cost1 + obj2_weight * cost2\n\n            if weighted_cost < best_cost:\n                best_cost = weighted_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6803487837253932,
            2.3752387166023254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto front preference)\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment inversion with dynamic objective-weighted edge insertion\n    # Step 1: Invert multiple non-overlapping segments\n    num_segments = np.random.randint(1, min(4, n//3))\n    segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n    positions = np.random.choice(range(1, n-max(segment_lengths)), size=num_segments, replace=False)\n\n    for pos, length in zip(positions, segment_lengths):\n        new_solution[pos:pos+length] = new_solution[pos:pos+length][::-1]\n\n    # Step 2: Dynamic objective-weighted edge insertion\n    # Calculate objective weights based on current solution's performance\n    obj1_weight = 0.5 + np.random.random() * 0.5\n    obj2_weight = 1 - obj1_weight\n\n    # Find the worst edge in both objectives\n    worst_edge1 = None\n    worst_edge2 = None\n    max_cost1 = -1\n    max_cost2 = -1\n\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        cost1 = distance_matrix_1[prev, curr]\n        cost2 = distance_matrix_2[prev, curr]\n\n        if cost1 > max_cost1:\n            max_cost1 = cost1\n            worst_edge1 = i\n        if cost2 > max_cost2:\n            max_cost2 = cost2\n            worst_edge2 = i\n\n    # Decide which edge to prioritize based on weights\n    if obj1_weight > obj2_weight:\n        target_edge = worst_edge1\n    else:\n        target_edge = worst_edge2\n\n    if target_edge is not None:\n        # Remove the target edge and insert it elsewhere optimally\n        node_to_insert = new_solution[target_edge]\n        new_solution = np.concatenate([new_solution[:target_edge], new_solution[target_edge+1:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(1, n-1):\n            prev = new_solution[pos-1]\n            curr = new_solution[pos]\n\n            # Calculate insertion cost\n            cost1 = distance_matrix_1[prev, node_to_insert] + distance_matrix_1[node_to_insert, curr]\n            cost2 = distance_matrix_2[prev, node_to_insert] + distance_matrix_2[node_to_insert, curr]\n\n            weighted_cost = obj1_weight * cost1 + obj2_weight * cost2\n\n            if weighted_cost < best_cost:\n                best_cost = weighted_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swap: swap node at position c with another node if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        swap_pos = np.random.choice(range(1, n-1))\n        if swap_pos != c:\n            swap_node = new_solution[swap_pos]\n\n            # Calculate original costs\n            original_cost1 = (distance_matrix_1[new_solution[c-1], node] + distance_matrix_1[node, new_solution[c+1]] +\n                             distance_matrix_1[new_solution[swap_pos-1], swap_node] + distance_matrix_1[swap_node, new_solution[swap_pos+1]])\n            original_cost2 = (distance_matrix_2[new_solution[c-1], node] + distance_matrix_2[node, new_solution[c+1]] +\n                             distance_matrix_2[new_solution[swap_pos-1], swap_node] + distance_matrix_2[swap_node, new_solution[swap_pos+1]])\n\n            # Calculate new costs\n            new_cost1 = (distance_matrix_1[new_solution[c-1], swap_node] + distance_matrix_1[swap_node, new_solution[c+1]] +\n                        distance_matrix_1[new_solution[swap_pos-1], node] + distance_matrix_1[node, new_solution[swap_pos+1]])\n            new_cost2 = (distance_matrix_2[new_solution[c-1], swap_node] + distance_matrix_2[swap_node, new_solution[c+1]] +\n                        distance_matrix_2[new_solution[swap_pos-1], node] + distance_matrix_2[node, new_solution[swap_pos+1]])\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution[c], new_solution[swap_pos] = new_solution[swap_pos], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5031460090470924,
            2.1894257068634033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swap: swap node at position c with another node if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        swap_pos = np.random.choice(range(1, n-1))\n        if swap_pos != c:\n            swap_node = new_solution[swap_pos]\n\n            # Calculate original costs\n            original_cost1 = (distance_matrix_1[new_solution[c-1], node] + distance_matrix_1[node, new_solution[c+1]] +\n                             distance_matrix_1[new_solution[swap_pos-1], swap_node] + distance_matrix_1[swap_node, new_solution[swap_pos+1]])\n            original_cost2 = (distance_matrix_2[new_solution[c-1], node] + distance_matrix_2[node, new_solution[c+1]] +\n                             distance_matrix_2[new_solution[swap_pos-1], swap_node] + distance_matrix_2[swap_node, new_solution[swap_pos+1]])\n\n            # Calculate new costs\n            new_cost1 = (distance_matrix_1[new_solution[c-1], swap_node] + distance_matrix_1[swap_node, new_solution[c+1]] +\n                        distance_matrix_1[new_solution[swap_pos-1], node] + distance_matrix_1[node, new_solution[swap_pos+1]])\n            new_cost2 = (distance_matrix_2[new_solution[c-1], swap_node] + distance_matrix_2[swap_node, new_solution[c+1]] +\n                        distance_matrix_2[new_solution[swap_pos-1], node] + distance_matrix_2[node, new_solution[swap_pos+1]])\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution[c], new_solution[swap_pos] = new_solution[swap_pos], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel scoring function combining objective values and tour diversity, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping, with adaptive neighborhood sizes to explore the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel scoring function combining objectives and diversity\n    def score(solution, objectives):\n        cost1, cost2 = objectives\n        diversity = len(np.unique(np.diff(solution)))\n        return (cost1 + cost2) * (1 + 0.1 * diversity)\n\n    # Select solution with highest score\n    selected = max(archive, key=lambda x: score(x[0], x[1]))\n    selected_solution = selected[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive neighborhood size\n    neighborhood_size = min(3, max(1, n // 10))\n\n    # Node relocation with adaptive size\n    for _ in range(neighborhood_size):\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.choice(range(1, n))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment inversion with adaptive size\n    for _ in range(neighborhood_size):\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping with adaptive size\n    for _ in range(neighborhood_size):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7416243102645631,
            3.594726860523224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel scoring function combining objectives and diversity\n    def score(solution, objectives):\n        cost1, cost2 = objectives\n        diversity = len(np.unique(np.diff(solution)))\n        return (cost1 + cost2) * (1 + 0.1 * diversity)\n\n    # Select solution with highest score\n    selected = max(archive, key=lambda x: score(x[0], x[1]))\n    selected_solution = selected[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive neighborhood size\n    neighborhood_size = min(3, max(1, n // 10))\n\n    # Node relocation with adaptive size\n    for _ in range(neighborhood_size):\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.choice(range(1, n))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment inversion with adaptive size\n    for _ in range(neighborhood_size):\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping with adaptive size\n    for _ in range(neighborhood_size):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a novel local search combining a block relocation with a partial reverse to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Block relocation with partial reverse\n    a, b = sorted(np.random.choice(range(1, n-3), size=2, replace=False))\n    block_length = np.random.randint(2, min(5, n-b))\n\n    # Relocate block\n    block = new_solution[b:b+block_length]\n    new_solution = np.concatenate([new_solution[:b], new_solution[b+block_length:]])\n    insert_pos = np.random.randint(1, len(new_solution)-block_length+1)\n    new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n    # Reverse a partial segment\n    c = np.random.randint(1, len(new_solution)-2)\n    reverse_length = np.random.randint(2, min(5, len(new_solution)-c))\n    new_solution[c:c+reverse_length] = new_solution[c+reverse_length-1:c-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6888624226625979,
            1.4355559349060059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Block relocation with partial reverse\n    a, b = sorted(np.random.choice(range(1, n-3), size=2, replace=False))\n    block_length = np.random.randint(2, min(5, n-b))\n\n    # Relocate block\n    block = new_solution[b:b+block_length]\n    new_solution = np.concatenate([new_solution[:b], new_solution[b+block_length:]])\n    insert_pos = np.random.randint(1, len(new_solution)-block_length+1)\n    new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:]])\n\n    # Reverse a partial segment\n    c = np.random.randint(1, len(new_solution)-2)\n    reverse_length = np.random.randint(2, min(5, len(new_solution)-c))\n    new_solution[c:c+reverse_length] = new_solution[c+reverse_length-1:c-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a novel hybrid local search combining a multi-objective-aware segment reversal with a probabilistic node reinsertion strategy to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with probabilistic node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Probabilistic node reinsertion: move node to a random position if it improves both objectives\n    for _ in range(2):  # Try multiple times\n        c = np.random.choice(range(1, n-1))\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8992043431146999,
            1.6932011246681213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with probabilistic node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Probabilistic node reinsertion: move node to a random position if it improves both objectives\n    for _ in range(2):  # Try multiple times\n        c = np.random.choice(range(1, n-1))\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel path relinking operator that combines segments from multiple solutions while ensuring feasibility through a constrained edge insertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    front = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        f_max = objectives[sorted_idx[-1], m]\n        f_min = objectives[sorted_idx[0], m]\n\n        if f_max == f_min:\n            continue\n\n        for i in range(1, len(archive)-1):\n            idx = sorted_idx[i]\n            crowding[idx] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (f_max - f_min)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Path relinking with constrained edge insertion\n    k = np.random.randint(2, min(5, n//2))\n    segments = []\n    for _ in range(k):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, min(i+4, n))\n        segments.append(new_solution[i:j])\n\n    combined = np.concatenate(segments)\n    np.random.shuffle(combined)\n\n    # Insert with feasibility check\n    pos = np.random.randint(1, n-1)\n    temp = np.concatenate([new_solution[:pos], combined, new_solution[pos:]])\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    # Edge optimization based on combined distance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            combined_dist = (distance_matrix_1[new_solution[i-1], new_solution[i+1]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i+1]])\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n            if combined_dist < current_dist:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8777910923344854,
            1.9958757758140564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    front = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        f_max = objectives[sorted_idx[-1], m]\n        f_min = objectives[sorted_idx[0], m]\n\n        if f_max == f_min:\n            continue\n\n        for i in range(1, len(archive)-1):\n            idx = sorted_idx[i]\n            crowding[idx] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (f_max - f_min)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Path relinking with constrained edge insertion\n    k = np.random.randint(2, min(5, n//2))\n    segments = []\n    for _ in range(k):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, min(i+4, n))\n        segments.append(new_solution[i:j])\n\n    combined = np.concatenate(segments)\n    np.random.shuffle(combined)\n\n    # Insert with feasibility check\n    pos = np.random.randint(1, n-1)\n    temp = np.concatenate([new_solution[:pos], combined, new_solution[pos:]])\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    # Edge optimization based on combined distance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            combined_dist = (distance_matrix_1[new_solution[i-1], new_solution[i+1]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i+1]])\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n            if combined_dist < current_dist:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid local search combining a novel path fragmentation with a multi-objective-aware path reassembly, which splits the tour into segments and reassembles them in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path fragmentation with multi-objective reassembly\n    num_segments = np.random.randint(2, min(5, n//2))\n    segment_lengths = np.random.randint(2, n//num_segments, size=num_segments)\n    segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    # Split the solution into segments\n    segments = []\n    start = 0\n    for length in segment_lengths:\n        segments.append(new_solution[start:start+length])\n        start += length\n\n    # Shuffle segments to create new order\n    np.random.shuffle(segments)\n\n    # Reassemble segments with multi-objective consideration\n    best_reassembly = new_solution.copy()\n    best_cost = (float('inf'), float('inf'))\n\n    for _ in range(10):  # Try multiple random reassemblies\n        temp_solution = np.concatenate(segments)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if cost1 < best_cost[0] and cost2 < best_cost[1]:\n            best_reassembly = temp_solution.copy()\n            best_cost = (cost1, cost2)\n\n    new_solution = best_reassembly\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.37979236709707387,
            3.771219789981842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path fragmentation with multi-objective reassembly\n    num_segments = np.random.randint(2, min(5, n//2))\n    segment_lengths = np.random.randint(2, n//num_segments, size=num_segments)\n    segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    # Split the solution into segments\n    segments = []\n    start = 0\n    for length in segment_lengths:\n        segments.append(new_solution[start:start+length])\n        start += length\n\n    # Shuffle segments to create new order\n    np.random.shuffle(segments)\n\n    # Reassemble segments with multi-objective consideration\n    best_reassembly = new_solution.copy()\n    best_cost = (float('inf'), float('inf'))\n\n    for _ in range(10):  # Try multiple random reassemblies\n        temp_solution = np.concatenate(segments)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if cost1 < best_cost[0] and cost2 < best_cost[1]:\n            best_reassembly = temp_solution.copy()\n            best_cost = (cost1, cost2)\n\n    new_solution = best_reassembly\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8278471794491142,
            0.39205408096313477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8278471794491142,
            0.39205408096313477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective diversity, then applies a multi-objective-aware node insertion strategy that dynamically reorders segments by considering both objectives' improvements simultaneously while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives (maximal difference)\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment reordering with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Calculate potential improvements for both objectives\n    for i in range(1, n-1):\n        if i >= a and i < b:\n            continue\n\n        # Calculate cost of inserting segment at position i\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i]\n\n        # Cost in first objective space\n        cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                 sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1)) +\n                 distance_matrix_1[segment[-1], next_node])\n\n        # Cost in second objective space\n        cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                 sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1)) +\n                 distance_matrix_2[segment[-1], next_node])\n\n        # Calculate current cost\n        current_cost1 = distance_matrix_1[prev_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # If both objectives improve or randomly accept with 20% probability\n        if ((cost1 < current_cost1 and cost2 < current_cost2) or np.random.random() < 0.2):\n            # Remove the segment and insert it at new position\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:i], segment, new_solution[i:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4582294768823062,
            0.8910036087036133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives (maximal difference)\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment reordering with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Calculate potential improvements for both objectives\n    for i in range(1, n-1):\n        if i >= a and i < b:\n            continue\n\n        # Calculate cost of inserting segment at position i\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i]\n\n        # Cost in first objective space\n        cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                 sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1)) +\n                 distance_matrix_1[segment[-1], next_node])\n\n        # Cost in second objective space\n        cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                 sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1)) +\n                 distance_matrix_2[segment[-1], next_node])\n\n        # Calculate current cost\n        current_cost1 = distance_matrix_1[prev_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # If both objectives improve or randomly accept with 20% probability\n        if ((cost1 < current_cost1 and cost2 < current_cost2) or np.random.random() < 0.2):\n            # Remove the segment and insert it at new position\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:i], segment, new_solution[i:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm selects a solution with the highest variance in objective values from the archive, then applies a novel \"objective-balancing\" local search that combines multi-segment inversion, adaptive node relocation, and distance-aware edge insertion to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance (promising for Pareto improvement)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment inversion with objective-aware segment selection\n    segments = []\n    for _ in range(2):\n        start = np.random.randint(1, n-2)\n        length = np.random.randint(2, min(5, n-start))\n        segments.append((start, start+length))\n\n    for s, e in segments:\n        segment = new_solution[s:e]\n        # Invert based on which objective is currently worse\n        if sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) > \\\n           sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)):\n            new_solution[s:e] = segment[::-1]\n\n    # Adaptive node relocation based on distance matrices\n    for _ in range(2):\n        node = np.random.choice(new_solution[1:-1])\n        node_idx = np.where(new_solution == node)[0][0]\n\n        # Calculate potential insertion points based on both distance matrices\n        candidates = []\n        for pos in range(1, n):\n            if pos == node_idx or pos == node_idx+1:\n                continue\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            candidates.append((pos, cost1 + cost2))\n\n        if candidates:\n            best_pos = min(candidates, key=lambda x: x[1])[0]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Distance-aware edge insertion\n    for _ in range(1):\n        # Find the edge with highest combined distance\n        max_dist = -1\n        edge_idx = -1\n        for i in range(n-1):\n            dist = distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                   distance_matrix_2[new_solution[i], new_solution[i+1]]\n            if dist > max_dist:\n                max_dist = dist\n                edge_idx = i\n\n        # Insert a node that bridges the gap in both spaces\n        candidates = []\n        for node in new_solution:\n            cost1 = distance_matrix_1[new_solution[edge_idx], node] + \\\n                    distance_matrix_1[node, new_solution[edge_idx+1]]\n            cost2 = distance_matrix_2[new_solution[edge_idx], node] + \\\n                    distance_matrix_2[node, new_solution[edge_idx+1]]\n            candidates.append((node, cost1 + cost2))\n\n        if candidates:\n            best_node = min(candidates, key=lambda x: x[1])[0]\n            node_idx = np.where(new_solution == best_node)[0][0]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, edge_idx+1, best_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.44983996045938607,
            3.4359535574913025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance (promising for Pareto improvement)\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment inversion with objective-aware segment selection\n    segments = []\n    for _ in range(2):\n        start = np.random.randint(1, n-2)\n        length = np.random.randint(2, min(5, n-start))\n        segments.append((start, start+length))\n\n    for s, e in segments:\n        segment = new_solution[s:e]\n        # Invert based on which objective is currently worse\n        if sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) > \\\n           sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)):\n            new_solution[s:e] = segment[::-1]\n\n    # Adaptive node relocation based on distance matrices\n    for _ in range(2):\n        node = np.random.choice(new_solution[1:-1])\n        node_idx = np.where(new_solution == node)[0][0]\n\n        # Calculate potential insertion points based on both distance matrices\n        candidates = []\n        for pos in range(1, n):\n            if pos == node_idx or pos == node_idx+1:\n                continue\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            candidates.append((pos, cost1 + cost2))\n\n        if candidates:\n            best_pos = min(candidates, key=lambda x: x[1])[0]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Distance-aware edge insertion\n    for _ in range(1):\n        # Find the edge with highest combined distance\n        max_dist = -1\n        edge_idx = -1\n        for i in range(n-1):\n            dist = distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                   distance_matrix_2[new_solution[i], new_solution[i+1]]\n            if dist > max_dist:\n                max_dist = dist\n                edge_idx = i\n\n        # Insert a node that bridges the gap in both spaces\n        candidates = []\n        for node in new_solution:\n            cost1 = distance_matrix_1[new_solution[edge_idx], node] + \\\n                    distance_matrix_1[node, new_solution[edge_idx+1]]\n            cost2 = distance_matrix_2[new_solution[edge_idx], node] + \\\n                    distance_matrix_2[node, new_solution[edge_idx+1]]\n            candidates.append((node, cost1 + cost2))\n\n        if candidates:\n            best_node = min(candidates, key=lambda x: x[1])[0]\n            node_idx = np.where(new_solution == best_node)[0][0]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, edge_idx+1, best_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a novel local search combining a segment relocation with a partial shuffle to balance objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Segment relocation with partial shuffle\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = np.random.randint(2, min(5, n-i))\n\n    # Relocate a segment\n    segment = new_solution[i:i+segment_length]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:], segment])\n\n    # Shuffle a portion to balance objectives\n    k = np.random.randint(1, n-2)\n    shuffle_length = np.random.randint(2, min(5, n-k))\n    np.random.shuffle(new_solution[k:k+shuffle_length])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5901554642102138,
            2.2406052350997925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Segment relocation with partial shuffle\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = np.random.randint(2, min(5, n-i))\n\n    # Relocate a segment\n    segment = new_solution[i:i+segment_length]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:], segment])\n\n    # Shuffle a portion to balance objectives\n    k = np.random.randint(1, n-2)\n    shuffle_length = np.random.randint(2, min(5, n-k))\n    np.random.shuffle(new_solution[k:k+shuffle_length])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a hybrid local search combining a novel segment inversion with adaptive segment sizes and a biased edge swapping mechanism to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances\n    objectives = np.array([obj for _, obj in archive])\n    front = objectives.copy()\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(front[:, m])\n        front_sorted = front[sorted_idx]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(front)-1):\n            if front_sorted[i+1, m] == front_sorted[i-1, m]:\n                continue\n            crowding[sorted_idx[i]] += (front_sorted[i+1, m] - front_sorted[i-1, m]) / (front_sorted[-1, m] - front_sorted[0, m])\n\n    # Select solution with lowest crowding distance\n    selected_idx = np.argmin(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with adaptive lengths\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    end = start + seg_length\n\n    segment = new_solution[start:end]\n    inverted_segment = segment[::-1]\n\n    new_solution[start:end] = inverted_segment\n\n    # Biased edge swapping\n    swap_prob = 0.5 if np.random.rand() < 0.3 else 0.8\n    for i in range(1, n-1):\n        if np.random.rand() < swap_prob:\n            if distance_matrix_1[new_solution[i-1], new_solution[i+1]] < distance_matrix_2[new_solution[i-1], new_solution[i+1]]:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n            else:\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7984497729479735,
            2.5018187165260315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances\n    objectives = np.array([obj for _, obj in archive])\n    front = objectives.copy()\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(front[:, m])\n        front_sorted = front[sorted_idx]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(front)-1):\n            if front_sorted[i+1, m] == front_sorted[i-1, m]:\n                continue\n            crowding[sorted_idx[i]] += (front_sorted[i+1, m] - front_sorted[i-1, m]) / (front_sorted[-1, m] - front_sorted[0, m])\n\n    # Select solution with lowest crowding distance\n    selected_idx = np.argmin(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with adaptive lengths\n    seg_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_length)\n    end = start + seg_length\n\n    segment = new_solution[start:end]\n    inverted_segment = segment[::-1]\n\n    new_solution[start:end] = inverted_segment\n\n    # Biased edge swapping\n    swap_prob = 0.5 if np.random.rand() < 0.3 else 0.8\n    for i in range(1, n-1):\n        if np.random.rand() < swap_prob:\n            if distance_matrix_1[new_solution[i-1], new_solution[i+1]] < distance_matrix_2[new_solution[i-1], new_solution[i+1]]:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n            else:\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and node centrality, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion that prioritizes both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives and node centrality\n    def selection_key(sol_obj):\n        sol, obj = sol_obj\n        # Prefer solutions with good objective values and central nodes\n        centrality = sum(np.mean(distance_matrix_1[sol, :], axis=1) + np.mean(distance_matrix_2[sol, :], axis=1))\n        return obj[0] + obj[1] - 0.5 * centrality\n\n    archive_sorted = sorted(archive, key=selection_key)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated\n\n    # Multi-objective node insertion\n    for _ in range(2):\n        i = np.random.choice(range(1, n-1))\n        node = new_solution[i]\n\n        # Find insertion position that improves both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(1, n-1):\n            if pos == i or pos == i+1:\n                continue\n\n            prev = new_solution[pos-1]\n            next_ = new_solution[pos]\n\n            # Calculate potential improvement\n            current_cost1 = distance_matrix_1[prev, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_]\n            new_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_]\n\n            current_cost2 = distance_matrix_2[prev, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_]\n            new_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_]\n\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5412178462700151,
            4.296320199966431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives and node centrality\n    def selection_key(sol_obj):\n        sol, obj = sol_obj\n        # Prefer solutions with good objective values and central nodes\n        centrality = sum(np.mean(distance_matrix_1[sol, :], axis=1) + np.mean(distance_matrix_2[sol, :], axis=1))\n        return obj[0] + obj[1] - 0.5 * centrality\n\n    archive_sorted = sorted(archive, key=selection_key)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated\n\n    # Multi-objective node insertion\n    for _ in range(2):\n        i = np.random.choice(range(1, n-1))\n        node = new_solution[i]\n\n        # Find insertion position that improves both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(1, n-1):\n            if pos == i or pos == i+1:\n                continue\n\n            prev = new_solution[pos-1]\n            next_ = new_solution[pos]\n\n            # Calculate potential improvement\n            current_cost1 = distance_matrix_1[prev, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_]\n            new_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_]\n\n            current_cost2 = distance_matrix_2[prev, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_]\n            new_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_]\n\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9513633827069793,
            0.893399178981781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance criterion, then applies a hybrid local search combining a novel segment inversion with adaptive segment lengths and a biased node reinsertion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with adaptive lengths\n    segment_length = max(2, min(5, n // 4))\n    a = np.random.randint(1, n-segment_length)\n    b = a + segment_length\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Biased node reinsertion\n    c = np.random.randint(1, n-1)\n    if np.random.rand() < 0.6:  # Higher probability to reinsert nodes based on better objective\n        if distance_matrix_1[new_solution[c-1], new_solution[c+1]] < distance_matrix_2[new_solution[c-1], new_solution[c+1]]:\n            node = new_solution[c]\n            new_solution = np.delete(new_solution, c)\n            insert_pos = np.random.randint(1, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            node = new_solution[c]\n            new_solution = np.delete(new_solution, c)\n            insert_pos = np.random.randint(1, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5616972693172173,
            2.7080782055854797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with adaptive lengths\n    segment_length = max(2, min(5, n // 4))\n    a = np.random.randint(1, n-segment_length)\n    b = a + segment_length\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Biased node reinsertion\n    c = np.random.randint(1, n-1)\n    if np.random.rand() < 0.6:  # Higher probability to reinsert nodes based on better objective\n        if distance_matrix_1[new_solution[c-1], new_solution[c+1]] < distance_matrix_2[new_solution[c-1], new_solution[c+1]]:\n            node = new_solution[c]\n            new_solution = np.delete(new_solution, c)\n            insert_pos = np.random.randint(1, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            node = new_solution[c]\n            new_solution = np.delete(new_solution, c)\n            insert_pos = np.random.randint(1, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel scoring function that combines objective values and diversity, then applies a hybrid local search combining edge swapping, segment inversion, and node relocation to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel scoring function: weighted sum of objectives plus diversity\n    def score(sol_obj):\n        cost1, cost2 = sol_obj[1]\n        diversity = len(set(sol_obj[0])) / len(sol_obj[0])\n        return 0.6 * (cost1 + cost2) + 0.4 * diversity\n\n    # Select solution with highest score\n    selected_solution = max(archive, key=score)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search\n    # 1. Edge swapping with probability 0.4\n    if np.random.random() < 0.4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment inversion with probability 0.3\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 3. Node relocation with probability 0.5\n    if np.random.random() < 0.5:\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.choice(range(1, n))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9229675407118033,
            3.793620228767395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel scoring function: weighted sum of objectives plus diversity\n    def score(sol_obj):\n        cost1, cost2 = sol_obj[1]\n        diversity = len(set(sol_obj[0])) / len(sol_obj[0])\n        return 0.6 * (cost1 + cost2) + 0.4 * diversity\n\n    # Select solution with highest score\n    selected_solution = max(archive, key=score)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search\n    # 1. Edge swapping with probability 0.4\n    if np.random.random() < 0.4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Segment inversion with probability 0.3\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 3. Node relocation with probability 0.5\n    if np.random.random() < 0.5:\n        node_idx = np.random.choice(range(1, n-1))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.choice(range(1, n))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel path inversion operator with adaptive segment selection to generate diverse neighbors while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive path inversion with segment selection\n    segment_length = max(2, min(n//3, np.random.randint(2, 6)))\n    start = np.random.randint(0, n - segment_length)\n\n    # Invert segment and adjust for circularity\n    segment = new_solution[start:start+segment_length]\n    new_solution[start:start+segment_length] = segment[::-1]\n\n    # Multi-objective aware edge swap\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.46047943415573567,
            2.2845755219459534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive path inversion with segment selection\n    segment_length = max(2, min(n//3, np.random.randint(2, 6)))\n    start = np.random.randint(0, n - segment_length)\n\n    # Invert segment and adjust for circularity\n    segment = new_solution[start:start+segment_length]\n    new_solution[start:start+segment_length] = segment[::-1]\n\n    # Multi-objective aware edge swap\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This new algorithm selects a solution from the archive based on its diversity and applies a hybrid local search combining a novel node swapping mechanism with a multi-objective-aware segment inversion that alternates between swapping nodes and inverting segments to explore the solution space while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution from the archive\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: alternating node swapping and segment inversion\n    for _ in range(2):  # Perform two iterations of alternating operations\n        # Node swapping\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment inversion\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7774576746101081,
            2.173983633518219
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution from the archive\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: alternating node swapping and segment inversion\n    for _ in range(2):  # Perform two iterations of alternating operations\n        # Node swapping\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment inversion\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search that combines adaptive segment merging with biased edge reinsertion, guided by the relative strengths of each objective, while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search that combines adaptive segment merging with biased edge reinsertion, guided by the relative strengths of each objective, while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search that combines adaptive segment merging with biased edge reinsertion, guided by the relative strengths of each objective, while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9783332719841749,
            2.4338977336883545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel multi-objective segment inversion and dynamic node merging strategy to generate a neighbor solution, which intelligently balances improvements across both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on hybrid of diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    quality = np.sum(objectives, axis=1)\n    scores = diversity[0] * diversity[1] / (quality + 1e-6)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment costs in both objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n    # Invert segment if it improves both objectives\n    inverted_segment = segment[::-1]\n    inv_cost1 = sum(distance_matrix_1[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n    inv_cost2 = sum(distance_matrix_2[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n\n    if (inv_cost1 < seg_cost1 and inv_cost2 < seg_cost2) or (np.random.random() < 0.3):\n        new_solution[a:b+1] = inverted_segment\n\n    # Dynamic node merging\n    c = np.random.choice(range(1, n-2))\n    node1, node2 = new_solution[c], new_solution[c+1]\n\n    # Calculate potential merged cost\n    merged_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_solution[c+2]]\n    merged_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_solution[c+2]]\n\n    # Compare with current cost\n    current_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_solution[c+2]]\n    current_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_solution[c+2]]\n\n    if (merged_cost1 < current_cost1 and merged_cost2 < current_cost2) or (np.random.random() < 0.2):\n        # Merge nodes by removing one and adjusting connections\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6905678784899052,
            3.6236221194267273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on hybrid of diversity and quality\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    quality = np.sum(objectives, axis=1)\n    scores = diversity[0] * diversity[1] / (quality + 1e-6)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment costs in both objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n    # Invert segment if it improves both objectives\n    inverted_segment = segment[::-1]\n    inv_cost1 = sum(distance_matrix_1[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n    inv_cost2 = sum(distance_matrix_2[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n\n    if (inv_cost1 < seg_cost1 and inv_cost2 < seg_cost2) or (np.random.random() < 0.3):\n        new_solution[a:b+1] = inverted_segment\n\n    # Dynamic node merging\n    c = np.random.choice(range(1, n-2))\n    node1, node2 = new_solution[c], new_solution[c+1]\n\n    # Calculate potential merged cost\n    merged_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_solution[c+2]]\n    merged_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_solution[c+2]]\n\n    # Compare with current cost\n    current_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_solution[c+2]]\n    current_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_solution[c+2]]\n\n    if (merged_cost1 < current_cost1 and merged_cost2 < current_cost2) or (np.random.random() < 0.2):\n        # Merge nodes by removing one and adjusting connections\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining segment reversal with a novel node sequence permutation to explore the solution space while balancing both objectives and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with node sequence permutation\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select a segment to permute\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[c:d+1]\n    np.random.shuffle(segment)\n    new_solution[c:d+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6615079620453442,
            2.2580918669700623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with node sequence permutation\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select a segment to permute\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[c:d+1]\n    np.random.shuffle(segment)\n    new_solution[c:d+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment shift with a multi-objective-aware node exchange, which shifts a segment of nodes and exchanges nodes between segments to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shift with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Shift the segment to a new position\n    pos = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:pos], segment, new_solution[pos:]])\n\n    # Node exchange between segments\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs if we swap the nodes\n    new_cost1 = (distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] +\n                 distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]])\n    new_cost2 = (distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] +\n                 distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]])\n\n    # Compare with current cost\n    current_cost1 = (distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] +\n                     distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]])\n    current_cost2 = (distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] +\n                     distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]])\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8454447131931507,
            1.220997929573059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shift with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Shift the segment to a new position\n    pos = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:pos], segment, new_solution[pos:]])\n\n    # Node exchange between segments\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs if we swap the nodes\n    new_cost1 = (distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] +\n                 distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]])\n    new_cost2 = (distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] +\n                 distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]])\n\n    # Compare with current cost\n    current_cost1 = (distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] +\n                     distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]])\n    current_cost2 = (distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] +\n                     distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]])\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap and insertion, which explores the solution space by inverting segments and strategically swapping or inserting nodes to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap and insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if c != d:\n        original_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[c+1]] + \\\n                          distance_matrix_1[new_solution[d-1], new_solution[d]] + distance_matrix_1[new_solution[d], new_solution[d+1]]\n        original_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[c], new_solution[c+1]] + \\\n                          distance_matrix_2[new_solution[d-1], new_solution[d]] + distance_matrix_2[new_solution[d], new_solution[d+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d], new_solution[c+1]] + \\\n                     distance_matrix_1[new_solution[d-1], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[d+1]]\n        new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d], new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], new_solution[c]] + distance_matrix_2[new_solution[c], new_solution[d+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Node insertion: insert a node at a different position if it improves both objectives\n    e = np.random.choice(range(1, n-1))\n    f = np.random.choice(range(1, n-1))\n    if e != f:\n        original_cost1 = distance_matrix_1[new_solution[f-1], new_solution[f]] + distance_matrix_1[new_solution[f], new_solution[f+1]]\n        original_cost2 = distance_matrix_2[new_solution[f-1], new_solution[f]] + distance_matrix_2[new_solution[f], new_solution[f+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[f-1], new_solution[e]] + distance_matrix_1[new_solution[e], new_solution[f+1]]\n        new_cost2 = distance_matrix_2[new_solution[f-1], new_solution[e]] + distance_matrix_2[new_solution[e], new_solution[f+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            node = new_solution[e]\n            new_solution = np.concatenate([new_solution[:e], new_solution[e+1:]])\n            new_solution = np.insert(new_solution, f, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7778988145725827,
            2.0614840984344482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap and insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if c != d:\n        original_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[c+1]] + \\\n                          distance_matrix_1[new_solution[d-1], new_solution[d]] + distance_matrix_1[new_solution[d], new_solution[d+1]]\n        original_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[c], new_solution[c+1]] + \\\n                          distance_matrix_2[new_solution[d-1], new_solution[d]] + distance_matrix_2[new_solution[d], new_solution[d+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d], new_solution[c+1]] + \\\n                     distance_matrix_1[new_solution[d-1], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[d+1]]\n        new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d], new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], new_solution[c]] + distance_matrix_2[new_solution[c], new_solution[d+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Node insertion: insert a node at a different position if it improves both objectives\n    e = np.random.choice(range(1, n-1))\n    f = np.random.choice(range(1, n-1))\n    if e != f:\n        original_cost1 = distance_matrix_1[new_solution[f-1], new_solution[f]] + distance_matrix_1[new_solution[f], new_solution[f+1]]\n        original_cost2 = distance_matrix_2[new_solution[f-1], new_solution[f]] + distance_matrix_2[new_solution[f], new_solution[f+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[f-1], new_solution[e]] + distance_matrix_1[new_solution[e], new_solution[f+1]]\n        new_cost2 = distance_matrix_2[new_solution[f-1], new_solution[e]] + distance_matrix_2[new_solution[e], new_solution[f+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            node = new_solution[e]\n            new_solution = np.concatenate([new_solution[:e], new_solution[e+1:]])\n            new_solution = np.insert(new_solution, f, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search that combines adaptive segment merging with biased edge reinsertion, guided by the relative strengths of each objective, while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a novel hybrid local search that combines adaptive path reversal with guided node insertion, prioritizing edges that improve the weaker objective while maintaining feasibility through a validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective dominance and structural diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    dominance_scores = np.max(normalized_obj, axis=1)\n    selection_probs = 1 - dominance_scores\n    selection_probs = selection_probs / np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = solutions[selected_idx].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive path reversal\n    segment_size = max(2, min(6, n // 3))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Guided node insertion based on objective imbalance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 > cost2 and np.random.rand() < 0.6) or (cost2 > cost1 and np.random.rand() < 0.4):\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                insert_pos = np.random.randint(1, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6856590177833619,
            3.1175721883773804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective dominance and structural diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    dominance_scores = np.max(normalized_obj, axis=1)\n    selection_probs = 1 - dominance_scores\n    selection_probs = selection_probs / np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = solutions[selected_idx].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive path reversal\n    segment_size = max(2, min(6, n // 3))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Guided node insertion based on objective imbalance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 > cost2 and np.random.rand() < 0.6) or (cost2 > cost1 and np.random.rand() < 0.4):\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                insert_pos = np.random.randint(1, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.4:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8750187388966302,
            0.7276519536972046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.4:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This new algorithm selects a solution from the archive based on a composite objective score combining both objectives, then applies a novel adaptive segment reordering strategy with dynamic segment lengths and a biased edge reinsertion mechanism to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best composite score (weighted sum of objectives)\n    selected_solution = min(archive, key=lambda x: 0.6*x[1][0] + 0.4*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(1, n-segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Dynamic reordering based on objective preference\n    if np.random.rand() < 0.7:  # 70% chance to reorder based on objective 1\n        sorted_segment = sorted(segment, key=lambda x: distance_matrix_1[new_solution[start-1], x] + distance_matrix_1[x, new_solution[start+segment_length]])\n    else:  # 30% chance to reorder based on objective 2\n        sorted_segment = sorted(segment, key=lambda x: distance_matrix_2[new_solution[start-1], x] + distance_matrix_2[x, new_solution[start+segment_length]])\n\n    new_solution[start:start+segment_length] = sorted_segment\n\n    # Biased edge reinsertion\n    for _ in range(2):  # Perform 2 reinsertions\n        pos = np.random.choice(range(1, n-1))\n        if np.random.rand() < 0.6:  # 60% chance to reinsert based on objective 1\n            best_pos = min(range(1, n-1), key=lambda p: distance_matrix_1[new_solution[p-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[p+1]])\n        else:  # 40% chance to reinsert based on objective 2\n            best_pos = min(range(1, n-1), key=lambda p: distance_matrix_2[new_solution[p-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[p+1]])\n\n        if best_pos != pos:\n            node = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.739048172766019,
            1.8563870191574097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best composite score (weighted sum of objectives)\n    selected_solution = min(archive, key=lambda x: 0.6*x[1][0] + 0.4*x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reordering\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(1, n-segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Dynamic reordering based on objective preference\n    if np.random.rand() < 0.7:  # 70% chance to reorder based on objective 1\n        sorted_segment = sorted(segment, key=lambda x: distance_matrix_1[new_solution[start-1], x] + distance_matrix_1[x, new_solution[start+segment_length]])\n    else:  # 30% chance to reorder based on objective 2\n        sorted_segment = sorted(segment, key=lambda x: distance_matrix_2[new_solution[start-1], x] + distance_matrix_2[x, new_solution[start+segment_length]])\n\n    new_solution[start:start+segment_length] = sorted_segment\n\n    # Biased edge reinsertion\n    for _ in range(2):  # Perform 2 reinsertions\n        pos = np.random.choice(range(1, n-1))\n        if np.random.rand() < 0.6:  # 60% chance to reinsert based on objective 1\n            best_pos = min(range(1, n-1), key=lambda p: distance_matrix_1[new_solution[p-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[p+1]])\n        else:  # 40% chance to reinsert based on objective 2\n            best_pos = min(range(1, n-1), key=lambda p: distance_matrix_2[new_solution[p-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[p+1]])\n\n        if best_pos != pos:\n            node = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a multi-objective-aware node insertion with a probabilistic edge reversal, and then performs a segment rotation to further improve the solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective-aware node insertion\n    a = np.random.choice(range(1, n-1))\n    node = new_solution[a]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+1:]])\n\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == a:\n            continue\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic edge reversal\n    for i in range(1, n-1):\n        if np.random.random() < 0.25:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6956875580787312,
            1.8252639174461365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective-aware node insertion\n    a = np.random.choice(range(1, n-1))\n    node = new_solution[a]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+1:]])\n\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == a:\n            continue\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic edge reversal\n    for i in range(1, n-1):\n        if np.random.random() < 0.25:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel node insertion with a multi-objective-aware edge swapping, which swaps two edges and inserts a node in a way that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node insertion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_a = new_solution[a]\n    node_b = new_solution[b]\n\n    # Swap edges and insert node_a at position b\n    new_solution[a] = new_solution[b]\n    new_solution[b] = node_a\n\n    # Edge swapping: swap two edges if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate costs if we swap edges\n    new_cost1 = distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]]\n\n    # Compare with current cost\n    current_cost1 = distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] + \\\n                    distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]]\n    current_cost2 = distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] + \\\n                    distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6911611292987722,
            1.8989021182060242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node insertion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_a = new_solution[a]\n    node_b = new_solution[b]\n\n    # Swap edges and insert node_a at position b\n    new_solution[a] = new_solution[b]\n    new_solution[b] = node_a\n\n    # Edge swapping: swap two edges if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate costs if we swap edges\n    new_cost1 = distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]]\n\n    # Compare with current cost\n    current_cost1 = distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] + \\\n                    distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]]\n    current_cost2 = distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] + \\\n                    distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This algorithm selects a solution with a balanced objective value (between min and max) from the archive, then applies a hybrid local search combining node swaps with a novel segment reversal to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective value (between min and max)\n    objectives = [sum(obj) for (sol, obj) in archive]\n    min_obj, max_obj = min(objectives), max(objectives)\n    balanced_solutions = [sol for (sol, obj) in archive if min_obj <= sum(obj) <= (min_obj + max_obj) * 0.5]\n    if not balanced_solutions:\n        selected_solution = archive[np.random.choice(len(archive))][0].copy()\n    else:\n        selected_solution = balanced_solutions[np.random.choice(len(balanced_solutions))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node swaps with segment reversal\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Reverse a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6254553642009942,
            1.3959594368934631
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective value (between min and max)\n    objectives = [sum(obj) for (sol, obj) in archive]\n    min_obj, max_obj = min(objectives), max(objectives)\n    balanced_solutions = [sol for (sol, obj) in archive if min_obj <= sum(obj) <= (min_obj + max_obj) * 0.5]\n    if not balanced_solutions:\n        selected_solution = archive[np.random.choice(len(archive))][0].copy()\n    else:\n        selected_solution = balanced_solutions[np.random.choice(len(balanced_solutions))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node swaps with segment reversal\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Reverse a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This new algorithm selects solutions from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel adaptive segment inversion and biased edge swapping strategy to generate high-quality neighbors while balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                crowding_distances[sorted_idx[i]] += 0\n            else:\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment inversion\n    segment_length = max(2, min(10, n // 4))\n    start = np.random.randint(1, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Biased edge swapping\n    for _ in range(3):\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n\n        # Calculate potential improvement\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n        if new_dist < old_dist:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5718004795591604,
            3.3685964345932007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                crowding_distances[sorted_idx[i]] += 0\n            else:\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment inversion\n    segment_length = max(2, min(10, n // 4))\n    start = np.random.randint(1, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Biased edge swapping\n    for _ in range(3):\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n\n        # Calculate potential improvement\n        old_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n        if new_dist < old_dist:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel objective diversity metric, then applies a hybrid local search combining a dynamic segment inversion with a biased edge reversal strategy to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    def diversity(obj):\n        return abs(obj[0] - obj[1])\n\n    selected_solution = max(archive, key=lambda x: diversity(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment inversion\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    segment_end = segment_start + segment_length\n\n    # Invert segment with probability based on objective imbalance\n    obj = next(obj for sol, obj in archive if np.array_equal(sol, selected_solution))\n    imbalance = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-10)\n\n    if np.random.rand() < imbalance:\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Biased edge reversal\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            if distance_matrix_1[new_solution[i-1], new_solution[i+1]] < distance_matrix_2[new_solution[i-1], new_solution[i+1]]:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n            else:\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6984719435562685,
            2.1957852840423584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    def diversity(obj):\n        return abs(obj[0] - obj[1])\n\n    selected_solution = max(archive, key=lambda x: diversity(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment inversion\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    segment_end = segment_start + segment_length\n\n    # Invert segment with probability based on objective imbalance\n    obj = next(obj for sol, obj in archive if np.array_equal(sol, selected_solution))\n    imbalance = abs(obj[0] - obj[1]) / (obj[0] + obj[1] + 1e-10)\n\n    if np.random.rand() < imbalance:\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Biased edge reversal\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            if distance_matrix_1[new_solution[i-1], new_solution[i+1]] < distance_matrix_2[new_solution[i-1], new_solution[i+1]]:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n            else:\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values using a weighted sum approach, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge exchange to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using weighted sum approach (alpha = 0.7 for first objective)\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Multi-objective edge exchange\n    for i in range(1, n-2):\n        for j in range(i+2, min(i+5, n-1)):\n            node1 = new_solution[i]\n            node2 = new_solution[j]\n            prev1 = new_solution[i-1]\n            next1 = new_solution[i+1]\n            prev2 = new_solution[j-1]\n            next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n            current_cost1 = (distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] +\n                            distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2])\n            current_cost2 = (distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] +\n                            distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2])\n\n            new_cost1 = (distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] +\n                        distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2])\n            new_cost2 = (distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] +\n                        distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8177685633631916,
            3.4985626935958862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using weighted sum approach (alpha = 0.7 for first objective)\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Multi-objective edge exchange\n    for i in range(1, n-2):\n        for j in range(i+2, min(i+5, n-1)):\n            node1 = new_solution[i]\n            node2 = new_solution[j]\n            prev1 = new_solution[i-1]\n            next1 = new_solution[i+1]\n            prev2 = new_solution[j-1]\n            next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n            current_cost1 = (distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] +\n                            distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2])\n            current_cost2 = (distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] +\n                            distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2])\n\n            new_cost1 = (distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] +\n                        distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2])\n            new_cost2 = (distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] +\n                        distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node swapping, which swaps two nodes and reinserts them in a way that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted sum of objectives\n    archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n\n    # Node swapping: swap two nodes and reinsert them in a way that improves both objectives if possible\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Try to insert node_i at position j and node_j at position i\n    for pos in range(1, n-1):\n        if pos == i or pos == j:\n            continue\n\n        # Calculate costs for the new configuration\n        new_cost1 = (distance_matrix_1[new_solution[pos-1], node_j] + distance_matrix_1[node_j, new_solution[pos+1]] +\n                     distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]])\n        new_cost2 = (distance_matrix_2[new_solution[pos-1], node_j] + distance_matrix_2[node_j, new_solution[pos+1]] +\n                     distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]])\n\n        # Compare with current cost\n        current_cost1 = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]] +\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]])\n        current_cost2 = (distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Perform the swap\n            new_solution[i], new_solution[pos] = new_solution[pos], new_solution[i]\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6335125736923098,
            2.2244041562080383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted sum of objectives\n    archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n\n    # Node swapping: swap two nodes and reinsert them in a way that improves both objectives if possible\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Try to insert node_i at position j and node_j at position i\n    for pos in range(1, n-1):\n        if pos == i or pos == j:\n            continue\n\n        # Calculate costs for the new configuration\n        new_cost1 = (distance_matrix_1[new_solution[pos-1], node_j] + distance_matrix_1[node_j, new_solution[pos+1]] +\n                     distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]])\n        new_cost2 = (distance_matrix_2[new_solution[pos-1], node_j] + distance_matrix_2[node_j, new_solution[pos+1]] +\n                     distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]])\n\n        # Compare with current cost\n        current_cost1 = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]] +\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]])\n        current_cost2 = (distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Perform the swap\n            new_solution[i], new_solution[pos] = new_solution[pos], new_solution[i]\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swap: swap edges between positions c and d if it improves both objectives\n    if c != d and abs(c - d) > 1:\n        node_c = new_solution[c]\n        node_d = new_solution[d]\n\n        original_cost1 = distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] + distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]]\n        original_cost2 = distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] + distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] + distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]]\n        new_cost2 = distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] + distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7762818111018714,
            1.4842966198921204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swap: swap edges between positions c and d if it improves both objectives\n    if c != d and abs(c - d) > 1:\n        node_c = new_solution[c]\n        node_d = new_solution[d]\n\n        original_cost1 = distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] + distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]]\n        original_cost2 = distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] + distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] + distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]]\n        new_cost2 = distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] + distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm selects a solution from the archive based on its average objective value, then applies a novel local search combining a multi-segment shuffle with a conditional node relocation strategy to explore diverse solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with median average objective value\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment shuffle\n    num_segments = np.random.randint(2, min(5, n//2))\n    segment_points = sorted(np.random.choice(range(1, n-1), size=num_segments+1, replace=False))\n\n    segments = []\n    for i in range(num_segments):\n        start, end = segment_points[i], segment_points[i+1]\n        segments.append(new_solution[start:end])\n\n    np.random.shuffle(segments)\n\n    new_solution = np.concatenate([new_solution[:segment_points[0]]] +\n                                 segments +\n                                 [new_solution[segment_points[-1]:]])\n\n    # Conditional node relocation\n    for _ in range(3):\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n\n        # Calculate current costs\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i+1]\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting at a random position\n        j = np.random.randint(1, n-1)\n        if j != i:\n            new_prev = new_solution[j-1]\n            new_next = new_solution[j]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, j, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8084959928855011,
            1.7869437336921692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with median average objective value\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment shuffle\n    num_segments = np.random.randint(2, min(5, n//2))\n    segment_points = sorted(np.random.choice(range(1, n-1), size=num_segments+1, replace=False))\n\n    segments = []\n    for i in range(num_segments):\n        start, end = segment_points[i], segment_points[i+1]\n        segments.append(new_solution[start:end])\n\n    np.random.shuffle(segments)\n\n    new_solution = np.concatenate([new_solution[:segment_points[0]]] +\n                                 segments +\n                                 [new_solution[segment_points[-1]:]])\n\n    # Conditional node relocation\n    for _ in range(3):\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n\n        # Calculate current costs\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i+1]\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting at a random position\n        j = np.random.randint(1, n-1)\n        if j != i:\n            new_prev = new_solution[j-1]\n            new_next = new_solution[j]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, j, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a Pareto dominance criterion, then applies a hybrid local search combining a novel segment crossover with dynamic segment lengths and a biased edge insertion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol_i)\n\n    if not non_dominated:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = non_dominated[np.random.randint(len(non_dominated))].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment crossover with dynamic lengths\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, min(a+5, n-1))\n    segment1 = new_solution[a:b+1]\n\n    c = np.random.randint(1, n-2)\n    d = np.random.randint(c+1, min(c+5, n-1))\n    segment2 = new_solution[c:d+1]\n\n    # Crossover segments\n    new_segment = np.concatenate([segment1, segment2])\n    np.random.shuffle(new_segment)\n\n    # Insert new segment\n    e = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge insertion\n    f = np.random.randint(1, n-1)\n    if np.random.rand() < 0.7:  # Higher probability to insert edges from better objectives\n        if distance_matrix_1[new_solution[f-1], new_solution[f+1]] < distance_matrix_2[new_solution[f-1], new_solution[f+1]]:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n        else:\n            new_solution = np.concatenate([new_solution[:f], new_solution[f+1:f+2], new_solution[f:f+1], new_solution[f+2:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining a novel segment inversion with adaptive segment lengths and a biased node relocation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    if len(archive) == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Normalize objectives\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distances\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(normalized[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        selected_solution = solutions[selected_idx].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with adaptive lengths\n    length = min(5, n // 3)\n    a = np.random.randint(0, n-length)\n    segment = new_solution[a:a+length]\n\n    # Invert segment with probability based on objective balance\n    obj_balance = objectives[selected_idx][0] / (objectives[selected_idx][0] + objectives[selected_idx][1] + 1e-10)\n    if np.random.rand() < obj_balance:\n        new_solution[a:a+length] = segment[::-1]\n\n    # Biased node relocation\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i != j:\n            # Calculate potential improvement\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[i+1]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[i+1]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n            # Accept if improves at least one objective\n            if delta1 < 0 or delta2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6638442837798967,
            1.8682987689971924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    if len(archive) == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Normalize objectives\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distances\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(normalized[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        selected_solution = solutions[selected_idx].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with adaptive lengths\n    length = min(5, n // 3)\n    a = np.random.randint(0, n-length)\n    segment = new_solution[a:a+length]\n\n    # Invert segment with probability based on objective balance\n    obj_balance = objectives[selected_idx][0] / (objectives[selected_idx][0] + objectives[selected_idx][1] + 1e-10)\n    if np.random.rand() < obj_balance:\n        new_solution[a:a+length] = segment[::-1]\n\n    # Biased node relocation\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i != j:\n            # Calculate potential improvement\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[i+1]] -\n                      distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[i+1]] -\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                      distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n            # Accept if improves at least one objective\n            if delta1 < 0 or delta2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion that prioritizes improving both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with best weighted sum\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        selected_solution = archive[0][0].copy()\n    else:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n        selected_solution = archive_sorted[len(archive_sorted)//2][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated\n\n    # Node insertion: try to insert a node in a better position\n    node_pos = np.random.randint(1, n-1)\n    node = new_solution[node_pos]\n    best_pos = node_pos\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == node_pos:\n            continue\n        old_cost1 = (distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]] +\n                     distance_matrix_1[new_solution[node_pos], new_solution[node_pos+1]])\n        new_cost1 = (distance_matrix_1[new_solution[pos-1], node] +\n                    distance_matrix_1[node, new_solution[pos]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]] +\n                    distance_matrix_2[new_solution[node_pos], new_solution[node_pos+1]])\n        new_cost2 = (distance_matrix_2[new_solution[pos-1], node] +\n                    distance_matrix_2[node, new_solution[pos]])\n\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6169061468655926,
            1.8930798768997192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with best weighted sum\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        selected_solution = archive[0][0].copy()\n    else:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n        selected_solution = archive_sorted[len(archive_sorted)//2][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated\n\n    # Node insertion: try to insert a node in a better position\n    node_pos = np.random.randint(1, n-1)\n    node = new_solution[node_pos]\n    best_pos = node_pos\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == node_pos:\n            continue\n        old_cost1 = (distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]] +\n                     distance_matrix_1[new_solution[node_pos], new_solution[node_pos+1]])\n        new_cost1 = (distance_matrix_1[new_solution[pos-1], node] +\n                    distance_matrix_1[node, new_solution[pos]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]] +\n                    distance_matrix_2[new_solution[node_pos], new_solution[node_pos+1]])\n        new_cost2 = (distance_matrix_2[new_solution[pos-1], node] +\n                    distance_matrix_2[node, new_solution[pos]])\n\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This new algorithm combines a multi-objective-aware segment permutation with a distance-based node relocation, selecting solutions with good combined objective values and applying a hybrid local search that intelligently reorders segments based on their relative distances in both objective spaces while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with good combined objective value\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation based on distance in both spaces\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment distances in both spaces\n    seg_dist1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    seg_dist2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Permute segment based on distance balance\n    if seg_dist1 > seg_dist2:\n        new_solution[a:b+1] = segment[::-1]  # Reverse if first space is heavier\n    else:\n        new_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))  # Random rotation\n\n    # Distance-based node relocation\n    c = np.random.choice(range(1, n-1))\n    node = new_solution[c]\n\n    # Find best position based on combined distance\n    best_pos = c\n    min_total_dist = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        prev = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        dist1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n        total_dist = dist1 + dist2\n\n        if total_dist < min_total_dist:\n            min_total_dist = total_dist\n            best_pos = pos\n\n    if best_pos != c:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.515602503621849,
            2.306287705898285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with good combined objective value\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation based on distance in both spaces\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment distances in both spaces\n    seg_dist1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    seg_dist2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Permute segment based on distance balance\n    if seg_dist1 > seg_dist2:\n        new_solution[a:b+1] = segment[::-1]  # Reverse if first space is heavier\n    else:\n        new_solution[a:b+1] = np.roll(segment, np.random.randint(1, len(segment)))  # Random rotation\n\n    # Distance-based node relocation\n    c = np.random.choice(range(1, n-1))\n    node = new_solution[c]\n\n    # Find best position based on combined distance\n    best_pos = c\n    min_total_dist = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        prev = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        dist1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n        total_dist = dist1 + dist2\n\n        if total_dist < min_total_dist:\n            min_total_dist = total_dist\n            best_pos = pos\n\n    if best_pos != c:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node replacement strategy to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    c = np.random.choice(range(1, n-1))\n    node_to_replace = new_solution[c]\n\n    best_pos = c\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_replace] + distance_matrix_1[node_to_replace, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_replace] + distance_matrix_2[node_to_replace, new_next]\n\n        improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != c:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:best_pos], [node_to_replace], new_solution[best_pos:]])\n\n    if np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6604115208994799,
            1.6435471177101135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    c = np.random.choice(range(1, n-1))\n    node_to_replace = new_solution[c]\n\n    best_pos = c\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_replace] + distance_matrix_1[node_to_replace, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_replace] + distance_matrix_2[node_to_replace, new_next]\n\n        improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != c:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:best_pos], [node_to_replace], new_solution[best_pos:]])\n\n    if np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This new algorithm selects a solution from the archive based on its diversity in the objective space, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node relocation to explore the solution space while balancing both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives (farthest from the centroid)\n    objectives = np.array([x[1] for x in archive])\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node relocation: move node to a position that improves both objectives\n    node_pos = np.random.randint(1, n-1)\n    node = new_solution[node_pos]\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == node_pos:\n            continue\n\n        # Calculate cost change for both objectives\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        if pos > node_pos:\n            prev_prev = new_solution[pos-2]\n            cost1 = distance_matrix_1[prev_prev, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_prev, node] + distance_matrix_2[node, next_node]\n        else:\n            cost1 = distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, next_node]\n\n        improvement1 = current_cost1 - cost1\n        improvement2 = current_cost2 - cost2\n\n        if (improvement1 > 0 and improvement2 > 0) or (np.random.random() < 0.3):\n            total_improvement = improvement1 + improvement2\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n    if best_pos != -1 and best_pos != node_pos:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4655181713150342,
            2.2147034406661987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives (farthest from the centroid)\n    objectives = np.array([x[1] for x in archive])\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node relocation: move node to a position that improves both objectives\n    node_pos = np.random.randint(1, n-1)\n    node = new_solution[node_pos]\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == node_pos:\n            continue\n\n        # Calculate cost change for both objectives\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        if pos > node_pos:\n            prev_prev = new_solution[pos-2]\n            cost1 = distance_matrix_1[prev_prev, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_prev, node] + distance_matrix_2[node, next_node]\n        else:\n            cost1 = distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, next_node]\n\n        improvement1 = current_cost1 - cost1\n        improvement2 = current_cost2 - cost2\n\n        if (improvement1 > 0 and improvement2 > 0) or (np.random.random() < 0.3):\n            total_improvement = improvement1 + improvement2\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n    if best_pos != -1 and best_pos != node_pos:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.940049927737807,
            0.5670558214187622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a novel segment transposition with a multi-objective-aware node swap to explore the solution space by strategically repositioning segments and swapping nodes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment transposition with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = b - a + 1\n\n    # Find a random position to transpose the segment\n    c = np.random.choice(range(1, n - segment_length))\n    if c >= a:\n        c += segment_length\n\n    # Transpose the segment\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Node swap: swap two nodes to improve both objectives if possible\n    x, y = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_x = new_solution[x]\n    node_y = new_solution[y]\n\n    current_cost1 = (distance_matrix_1[new_solution[x-1], node_x] + distance_matrix_1[node_x, new_solution[x+1]] +\n                     distance_matrix_1[new_solution[y-1], node_y] + distance_matrix_1[node_y, new_solution[y+1]])\n    current_cost2 = (distance_matrix_2[new_solution[x-1], node_x] + distance_matrix_2[node_x, new_solution[x+1]] +\n                     distance_matrix_2[new_solution[y-1], node_y] + distance_matrix_2[node_y, new_solution[y+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[x-1], node_y] + distance_matrix_1[node_y, new_solution[x+1]] +\n                distance_matrix_1[new_solution[y-1], node_x] + distance_matrix_1[node_x, new_solution[y+1]])\n    new_cost2 = (distance_matrix_2[new_solution[x-1], node_y] + distance_matrix_2[node_y, new_solution[x+1]] +\n                distance_matrix_2[new_solution[y-1], node_x] + distance_matrix_2[node_x, new_solution[y+1]])\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[x], new_solution[y] = new_solution[y], new_solution[x]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9005468736190381,
            1.3476431965827942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment transposition with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = b - a + 1\n\n    # Find a random position to transpose the segment\n    c = np.random.choice(range(1, n - segment_length))\n    if c >= a:\n        c += segment_length\n\n    # Transpose the segment\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Node swap: swap two nodes to improve both objectives if possible\n    x, y = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_x = new_solution[x]\n    node_y = new_solution[y]\n\n    current_cost1 = (distance_matrix_1[new_solution[x-1], node_x] + distance_matrix_1[node_x, new_solution[x+1]] +\n                     distance_matrix_1[new_solution[y-1], node_y] + distance_matrix_1[node_y, new_solution[y+1]])\n    current_cost2 = (distance_matrix_2[new_solution[x-1], node_x] + distance_matrix_2[node_x, new_solution[x+1]] +\n                     distance_matrix_2[new_solution[y-1], node_y] + distance_matrix_2[node_y, new_solution[y+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[x-1], node_y] + distance_matrix_1[node_y, new_solution[x+1]] +\n                distance_matrix_1[new_solution[y-1], node_x] + distance_matrix_1[node_x, new_solution[y+1]])\n    new_cost2 = (distance_matrix_2[new_solution[x-1], node_y] + distance_matrix_2[node_y, new_solution[x+1]] +\n                distance_matrix_2[new_solution[y-1], node_x] + distance_matrix_2[node_x, new_solution[y+1]])\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[x], new_solution[y] = new_solution[y], new_solution[x]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a novel local search combining segment reversal with a probabilistic edge swap to balance improvement across both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted sum of objectives (weighted by inverse of current objective)\n    weights = [1/(obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel local search: Segment reversal with probabilistic edge swap\n    # Select two random segments and reverse them\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments with probability based on segment lengths\n    if np.random.rand() < abs(b - a) / n:\n        new_solution[a:b] = new_solution[b-1:a-1:-1]\n    if np.random.rand() < abs(d - c) / n:\n        new_solution[c:d] = new_solution[d-1:c-1:-1]\n\n    # Probabilistic edge swap to balance objectives\n    for i in range(1, n-1):\n        if np.random.rand() < 0.3:  # 30% chance of swap\n            j = np.random.randint(1, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7417739535923578,
            2.170110821723938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted sum of objectives (weighted by inverse of current objective)\n    weights = [1/(obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel local search: Segment reversal with probabilistic edge swap\n    # Select two random segments and reverse them\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segments with probability based on segment lengths\n    if np.random.rand() < abs(b - a) / n:\n        new_solution[a:b] = new_solution[b-1:a-1:-1]\n    if np.random.rand() < abs(d - c) / n:\n        new_solution[c:d] = new_solution[d-1:c-1:-1]\n\n    # Probabilistic edge swap to balance objectives\n    for i in range(1, n-1):\n        if np.random.rand() < 0.3:  # 30% chance of swap\n            j = np.random.randint(1, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects a solution from the archive using a novel multi-objective selection criterion that balances both objectives with randomness, then applies a hybrid local search combining a dynamic segment relocation with a directed edge perturbation to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted randomness based on objective balance\n    weights = [ (obj[0] + obj[1]) * (1 + np.random.random()) for (_, obj) in archive ]\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: dynamic segment relocation with directed edge perturbation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Relocate segment to a new position\n    new_pos = np.random.randint(1, n-1)\n    if new_pos < a:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:a], new_solution[b+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:new_pos], segment, new_solution[new_pos:]])\n\n    # Directed edge perturbation\n    c = np.random.randint(1, n-2)\n    if np.random.random() < 0.5:\n        # Swap two nodes in the same direction\n        d = (c + np.random.randint(1, min(5, n-c-1))) % n\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n    else:\n        # Invert a small segment\n        segment_len = np.random.randint(2, min(4, n-c))\n        new_solution[c:c+segment_len] = new_solution[c+segment_len-1:c-1:-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8169710171954923,
            1.8820815682411194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted randomness based on objective balance\n    weights = [ (obj[0] + obj[1]) * (1 + np.random.random()) for (_, obj) in archive ]\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: dynamic segment relocation with directed edge perturbation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Relocate segment to a new position\n    new_pos = np.random.randint(1, n-1)\n    if new_pos < a:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:a], new_solution[b+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:new_pos], segment, new_solution[new_pos:]])\n\n    # Directed edge perturbation\n    c = np.random.randint(1, n-2)\n    if np.random.random() < 0.5:\n        # Swap two nodes in the same direction\n        d = (c + np.random.randint(1, min(5, n-c-1))) % n\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n    else:\n        # Invert a small segment\n        segment_len = np.random.randint(2, min(4, n-c))\n        new_solution[c:c+segment_len] = new_solution[c+segment_len-1:c-1:-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, applies a multi-objective-aware node insertion heuristic that considers both objectives simultaneously, followed by a probabilistic edge reversal operation to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective node insertion heuristic\n    a = np.random.choice(range(1, n-1))\n    b = np.random.choice(range(1, n-1))\n\n    # Insert node at position b after position a\n    node_to_insert = new_solution[b]\n    new_solution = np.concatenate([new_solution[:a+1], [node_to_insert], new_solution[a+1:b], new_solution[b+1:]])\n\n    # Probabilistic edge reversal\n    for i in range(1, n-2):\n        if np.random.random() < 0.4:\n            # Reverse a segment of length 3\n            new_solution[i:i+3] = new_solution[i:i+3][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8529571343765602,
            1.5158770084381104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective node insertion heuristic\n    a = np.random.choice(range(1, n-1))\n    b = np.random.choice(range(1, n-1))\n\n    # Insert node at position b after position a\n    node_to_insert = new_solution[b]\n    new_solution = np.concatenate([new_solution[:a+1], [node_to_insert], new_solution[a+1:b], new_solution[b+1:]])\n\n    # Probabilistic edge reversal\n    for i in range(1, n-2):\n        if np.random.random() < 0.4:\n            # Reverse a segment of length 3\n            new_solution[i:i+3] = new_solution[i:i+3][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a novel local search combining 3-opt with a segment rotation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment rotation\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j] = new_solution[j-1:i-1:-1]\n    new_solution[j:k] = new_solution[k-1:j-1:-1]\n\n    # Rotate a segment to balance objectives\n    segment_start = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    segment = new_solution[segment_start:segment_start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    new_solution[segment_start:segment_start+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8850546597203979,
            2.4584843516349792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment rotation\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j] = new_solution[j-1:i-1:-1]\n    new_solution[j:k] = new_solution[k-1:j-1:-1]\n\n    # Rotate a segment to balance objectives\n    segment_start = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    segment = new_solution[segment_start:segment_start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    new_solution[segment_start:segment_start+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Multi-objective node swap: swap nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    prev_i = new_solution[i-1]\n    next_i = new_solution[(i+1)%n]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[(j+1)%n]\n\n    original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                      distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n    original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                      distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n    new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n    new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7136078818371601,
            2.5814807415008545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Multi-objective node swap: swap nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    prev_i = new_solution[i-1]\n    next_i = new_solution[(i+1)%n]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[(j+1)%n]\n\n    original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                      distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n    original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                      distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n    new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n    new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge exchange to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n\n    # Multi-objective edge exchange: try to find an edge swap that improves both objectives\n    for i in range(1, n-2):\n        for j in range(i+1, n-1):\n            node_i_prev = new_solution[i-1]\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            node_j_next = new_solution[j+1]\n\n            current_cost1 = (distance_matrix_1[node_i_prev, node_i] + distance_matrix_1[node_j, node_j_next] +\n                            distance_matrix_1[node_i, node_j])\n            current_cost2 = (distance_matrix_2[node_i_prev, node_i] + distance_matrix_2[node_j, node_j_next] +\n                            distance_matrix_2[node_i, node_j])\n\n            new_cost1 = (distance_matrix_1[node_i_prev, node_j] + distance_matrix_1[node_i, node_j_next] +\n                         distance_matrix_1[node_j, node_i])\n            new_cost2 = (distance_matrix_2[node_i_prev, node_j] + distance_matrix_2[node_i, node_j_next] +\n                         distance_matrix_2[node_j, node_i])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6903976928404926,
            4.723857641220093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n\n    # Multi-objective edge exchange: try to find an edge swap that improves both objectives\n    for i in range(1, n-2):\n        for j in range(i+1, n-1):\n            node_i_prev = new_solution[i-1]\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            node_j_next = new_solution[j+1]\n\n            current_cost1 = (distance_matrix_1[node_i_prev, node_i] + distance_matrix_1[node_j, node_j_next] +\n                            distance_matrix_1[node_i, node_j])\n            current_cost2 = (distance_matrix_2[node_i_prev, node_i] + distance_matrix_2[node_j, node_j_next] +\n                            distance_matrix_2[node_i, node_j])\n\n            new_cost1 = (distance_matrix_1[node_i_prev, node_j] + distance_matrix_1[node_i, node_j_next] +\n                         distance_matrix_1[node_j, node_i])\n            new_cost2 = (distance_matrix_2[node_i_prev, node_j] + distance_matrix_2[node_i, node_j_next] +\n                         distance_matrix_2[node_j, node_i])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swapping that explores the solution space by strategically reversing segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted objective value (0.7 for first objective, 0.3 for second)\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Node swapping: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Calculate original costs\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[original_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], original_next_c] +\n                      distance_matrix_1[original_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], original_next_d])\n    original_cost2 = (distance_matrix_2[original_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], original_next_c] +\n                      distance_matrix_2[original_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], original_next_d])\n\n    # Calculate new costs if swapped\n    if c+1 == d:\n        new_prev_c = new_solution[d-1]\n        new_next_c = new_solution[d+1] if d+1 < n else new_solution[0]\n        new_prev_d = new_solution[c-1]\n        new_next_d = new_solution[c+1] if c+1 < n else new_solution[0]\n    else:\n        new_prev_c = new_solution[d-1]\n        new_next_c = new_solution[d+1] if d+1 < n else new_solution[0]\n        new_prev_d = new_solution[c-1]\n        new_next_d = new_solution[c+1] if c+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[new_prev_c, new_solution[d]] + distance_matrix_1[new_solution[d], new_next_c] +\n                distance_matrix_1[new_prev_d, new_solution[c]] + distance_matrix_1[new_solution[c], new_next_d])\n    new_cost2 = (distance_matrix_2[new_prev_c, new_solution[d]] + distance_matrix_2[new_solution[d], new_next_c] +\n                distance_matrix_2[new_prev_d, new_solution[c]] + distance_matrix_2[new_solution[c], new_next_d])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9051148636822383,
            1.2631529569625854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted objective value (0.7 for first objective, 0.3 for second)\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Node swapping: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Calculate original costs\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[original_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], original_next_c] +\n                      distance_matrix_1[original_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], original_next_d])\n    original_cost2 = (distance_matrix_2[original_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], original_next_c] +\n                      distance_matrix_2[original_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], original_next_d])\n\n    # Calculate new costs if swapped\n    if c+1 == d:\n        new_prev_c = new_solution[d-1]\n        new_next_c = new_solution[d+1] if d+1 < n else new_solution[0]\n        new_prev_d = new_solution[c-1]\n        new_next_d = new_solution[c+1] if c+1 < n else new_solution[0]\n    else:\n        new_prev_c = new_solution[d-1]\n        new_next_c = new_solution[d+1] if d+1 < n else new_solution[0]\n        new_prev_d = new_solution[c-1]\n        new_next_d = new_solution[c+1] if c+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[new_prev_c, new_solution[d]] + distance_matrix_1[new_solution[d], new_next_c] +\n                distance_matrix_1[new_prev_d, new_solution[c]] + distance_matrix_1[new_solution[c], new_next_d])\n    new_cost2 = (distance_matrix_2[new_prev_c, new_solution[d]] + distance_matrix_2[new_solution[d], new_next_c] +\n                distance_matrix_2[new_prev_d, new_solution[c]] + distance_matrix_2[new_solution[c], new_next_d])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a novel local search combining a multi-objective-aware segment swap with a dynamic node relocation strategy to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective value\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:]\n\n    # Dynamic node relocation\n    if np.random.random() < 0.5:\n        # Swap segments\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n    else:\n        # Relocate nodes based on objective improvement\n        for i in range(a, b):\n            node = new_solution[i]\n            prev = new_solution[i-1]\n            next_node = new_solution[i+1]\n\n            original_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            original_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n            new_pos = np.random.choice(range(1, n-1))\n            if new_pos != i:\n                new_prev = new_solution[new_pos-1]\n                new_next = new_solution[new_pos]\n\n                new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n                new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n                if (new_cost1 + new_cost2) < (original_cost1 + original_cost2) or np.random.random() < 0.3:\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8590455462716144,
            2.204029142856598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective value\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:]\n\n    # Dynamic node relocation\n    if np.random.random() < 0.5:\n        # Swap segments\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n    else:\n        # Relocate nodes based on objective improvement\n        for i in range(a, b):\n            node = new_solution[i]\n            prev = new_solution[i-1]\n            next_node = new_solution[i+1]\n\n            original_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            original_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n            new_pos = np.random.choice(range(1, n-1))\n            if new_pos != i:\n                new_prev = new_solution[new_pos-1]\n                new_next = new_solution[new_pos]\n\n                new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n                new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n                if (new_cost1 + new_cost2) < (original_cost1 + original_cost2) or np.random.random() < 0.3:\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in positions that improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: remove a node and insert it in a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.944828931222757,
            0.7339372634887695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: remove a node and insert it in a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate costs for the original and swapped positions\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_cost1_c = distance_matrix_1[original_prev_c, node_c] + distance_matrix_1[node_c, original_next_c]\n    original_cost2_c = distance_matrix_2[original_prev_c, node_c] + distance_matrix_2[node_c, original_next_c]\n\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n    original_cost1_d = distance_matrix_1[original_prev_d, node_d] + distance_matrix_1[node_d, original_next_d]\n    original_cost2_d = distance_matrix_2[original_prev_d, node_d] + distance_matrix_2[node_d, original_next_d]\n\n    new_cost1_c = distance_matrix_1[original_prev_c, node_d] + distance_matrix_1[node_d, original_next_c]\n    new_cost2_c = distance_matrix_2[original_prev_c, node_d] + distance_matrix_2[node_d, original_next_c]\n\n    new_cost1_d = distance_matrix_1[original_prev_d, node_c] + distance_matrix_1[node_c, original_next_d]\n    new_cost2_d = distance_matrix_2[original_prev_d, node_c] + distance_matrix_2[node_c, original_next_d]\n\n    # Compare costs\n    if ((new_cost1_c < original_cost1_c and new_cost2_c < original_cost2_c) and\n        (new_cost1_d < original_cost1_d and new_cost2_d < original_cost2_d)) or (np.random.random() < 0.15):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8076664683123078,
            1.6970757246017456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate costs for the original and swapped positions\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_cost1_c = distance_matrix_1[original_prev_c, node_c] + distance_matrix_1[node_c, original_next_c]\n    original_cost2_c = distance_matrix_2[original_prev_c, node_c] + distance_matrix_2[node_c, original_next_c]\n\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n    original_cost1_d = distance_matrix_1[original_prev_d, node_d] + distance_matrix_1[node_d, original_next_d]\n    original_cost2_d = distance_matrix_2[original_prev_d, node_d] + distance_matrix_2[node_d, original_next_d]\n\n    new_cost1_c = distance_matrix_1[original_prev_c, node_d] + distance_matrix_1[node_d, original_next_c]\n    new_cost2_c = distance_matrix_2[original_prev_c, node_d] + distance_matrix_2[node_d, original_next_c]\n\n    new_cost1_d = distance_matrix_1[original_prev_d, node_c] + distance_matrix_1[node_c, original_next_d]\n    new_cost2_d = distance_matrix_2[original_prev_d, node_c] + distance_matrix_2[node_c, original_next_d]\n\n    # Compare costs\n    if ((new_cost1_c < original_cost1_c and new_cost2_c < original_cost2_c) and\n        (new_cost1_d < original_cost1_d and new_cost2_d < original_cost2_d)) or (np.random.random() < 0.15):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives with adaptive weights, applies a hybrid local search combining a novel segment rotation with a multi-objective-aware edge expansion, and then performs a targeted swap of non-adjacent nodes to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with adaptive weighted objective balance\n    weights = np.random.random(2)\n    weights /= weights.sum()\n    archive_sorted = sorted(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective edge expansion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Edge expansion: split a node into two adjacent nodes\n    c = np.random.choice(range(1, n-1))\n    node = new_solution[c]\n\n    # Find best insertion points for split nodes\n    best_pos1, best_pos2 = -1, -1\n    best_improvement = 0\n\n    for pos1 in range(1, n-1):\n        for pos2 in range(pos1+1, n):\n            if pos1 == c or pos2 == c or abs(pos1-pos2) > 2:\n                continue\n\n            # Calculate potential improvement\n            prev1 = new_solution[pos1-1]\n            next1 = new_solution[pos1]\n            prev2 = new_solution[pos2-1]\n            next2 = new_solution[pos2]\n\n            cost1 = distance_matrix_1[prev1, node] + distance_matrix_1[node, next1] + distance_matrix_1[prev2, node] + distance_matrix_1[node, next2]\n            cost2 = distance_matrix_2[prev1, node] + distance_matrix_2[node, next1] + distance_matrix_2[prev2, node] + distance_matrix_2[node, next2]\n\n            current_cost1 = distance_matrix_1[prev1, next1] + distance_matrix_1[prev2, next2]\n            current_cost2 = distance_matrix_2[prev1, next1] + distance_matrix_2[prev2, next2]\n\n            improvement = (current_cost1 - cost1) + (current_cost2 - cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos1, best_pos2 = pos1, pos2\n\n    if best_pos1 != -1 and best_pos2 != -1 and best_improvement > 0:\n        # Insert two copies of the node at best positions\n        new_solution = np.insert(new_solution, best_pos1, node)\n        if best_pos2 > best_pos1:\n            best_pos2 += 1\n        new_solution = np.insert(new_solution, best_pos2, node)\n\n    # Targeted non-adjacent node swap\n    for i in range(1, n-2):\n        for j in range(i+2, n-1):\n            if np.random.random() < 0.2:\n                node1 = new_solution[i]\n                node2 = new_solution[j]\n\n                cost1 = distance_matrix_1[new_solution[i-1], node2] + distance_matrix_1[node2, new_solution[i+1]] + distance_matrix_1[new_solution[j-1], node1] + distance_matrix_1[node1, new_solution[j+1]]\n                cost2 = distance_matrix_2[new_solution[i-1], node2] + distance_matrix_2[node2, new_solution[i+1]] + distance_matrix_2[new_solution[j-1], node1] + distance_matrix_2[node1, new_solution[j+1]]\n\n                current_cost1 = distance_matrix_1[new_solution[i-1], node1] + distance_matrix_1[node1, new_solution[i+1]] + distance_matrix_1[new_solution[j-1], node2] + distance_matrix_1[node2, new_solution[j+1]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], node1] + distance_matrix_2[node1, new_solution[i+1]] + distance_matrix_2[new_solution[j-1], node2] + distance_matrix_2[node2, new_solution[j+1]]\n\n                if (cost1 < current_cost1 and cost2 < current_cost2) or (np.random.random() < 0.1):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6831833568215339,
            7.724197268486023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with adaptive weighted objective balance\n    weights = np.random.random(2)\n    weights /= weights.sum()\n    archive_sorted = sorted(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective edge expansion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Edge expansion: split a node into two adjacent nodes\n    c = np.random.choice(range(1, n-1))\n    node = new_solution[c]\n\n    # Find best insertion points for split nodes\n    best_pos1, best_pos2 = -1, -1\n    best_improvement = 0\n\n    for pos1 in range(1, n-1):\n        for pos2 in range(pos1+1, n):\n            if pos1 == c or pos2 == c or abs(pos1-pos2) > 2:\n                continue\n\n            # Calculate potential improvement\n            prev1 = new_solution[pos1-1]\n            next1 = new_solution[pos1]\n            prev2 = new_solution[pos2-1]\n            next2 = new_solution[pos2]\n\n            cost1 = distance_matrix_1[prev1, node] + distance_matrix_1[node, next1] + distance_matrix_1[prev2, node] + distance_matrix_1[node, next2]\n            cost2 = distance_matrix_2[prev1, node] + distance_matrix_2[node, next1] + distance_matrix_2[prev2, node] + distance_matrix_2[node, next2]\n\n            current_cost1 = distance_matrix_1[prev1, next1] + distance_matrix_1[prev2, next2]\n            current_cost2 = distance_matrix_2[prev1, next1] + distance_matrix_2[prev2, next2]\n\n            improvement = (current_cost1 - cost1) + (current_cost2 - cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos1, best_pos2 = pos1, pos2\n\n    if best_pos1 != -1 and best_pos2 != -1 and best_improvement > 0:\n        # Insert two copies of the node at best positions\n        new_solution = np.insert(new_solution, best_pos1, node)\n        if best_pos2 > best_pos1:\n            best_pos2 += 1\n        new_solution = np.insert(new_solution, best_pos2, node)\n\n    # Targeted non-adjacent node swap\n    for i in range(1, n-2):\n        for j in range(i+2, n-1):\n            if np.random.random() < 0.2:\n                node1 = new_solution[i]\n                node2 = new_solution[j]\n\n                cost1 = distance_matrix_1[new_solution[i-1], node2] + distance_matrix_1[node2, new_solution[i+1]] + distance_matrix_1[new_solution[j-1], node1] + distance_matrix_1[node1, new_solution[j+1]]\n                cost2 = distance_matrix_2[new_solution[i-1], node2] + distance_matrix_2[node2, new_solution[i+1]] + distance_matrix_2[new_solution[j-1], node1] + distance_matrix_2[node1, new_solution[j+1]]\n\n                current_cost1 = distance_matrix_1[new_solution[i-1], node1] + distance_matrix_1[node1, new_solution[i+1]] + distance_matrix_1[new_solution[j-1], node2] + distance_matrix_1[node2, new_solution[j+1]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], node1] + distance_matrix_2[node1, new_solution[i+1]] + distance_matrix_2[new_solution[j-1], node2] + distance_matrix_2[node2, new_solution[j+1]]\n\n                if (cost1 < current_cost1 and cost2 < current_cost2) or (np.random.random() < 0.1):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest combined objective value, then applies a hybrid local search combining a novel node swap with a multi-objective-aware segment inversion, which swaps two nodes and inverts a segment to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node swap with segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Invert a segment to explore different configurations\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Multi-objective node insertion: find the best position for a node to improve both objectives\n    node_to_move = new_solution[np.random.choice(range(1, n-1))]\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n\n    best_pos = current_pos\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == current_pos:\n            continue\n        # Calculate cost if node is moved to position pos\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n        cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n\n        if (cost1 < best_cost1 and cost2 < best_cost2) or (np.random.random() < 0.1):\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = pos\n\n    if best_pos != current_pos:\n        # Remove from current position and insert at best position\n        new_solution = np.concatenate([new_solution[:current_pos], new_solution[current_pos+1:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8618744820809948,
            1.9452340006828308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node swap with segment inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Invert a segment to explore different configurations\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Multi-objective node insertion: find the best position for a node to improve both objectives\n    node_to_move = new_solution[np.random.choice(range(1, n-1))]\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n\n    best_pos = current_pos\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == current_pos:\n            continue\n        # Calculate cost if node is moved to position pos\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n        cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n\n        if (cost1 < best_cost1 and cost2 < best_cost2) or (np.random.random() < 0.1):\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = pos\n\n    if best_pos != current_pos:\n        # Remove from current position and insert at best position\n        new_solution = np.concatenate([new_solution[:current_pos], new_solution[current_pos+1:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment permutation with a multi-objective-aware node relocation that explores the solution space by strategically reordering segments and repositioning nodes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node relocation: move a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7486742481367274,
            0.32343071699142456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node relocation: move a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment permutation with a multi-objective-aware node relocation that explores the solution space by strategically reordering segments and repositioning nodes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node relocation: move a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7486742481367274,
            0.32343071699142456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node relocation: move a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective trade-off metric, then applies a novel hybrid local search that combines a probabilistic segment rotation with a multi-objective-aware edge insertion, ensuring feasibility while exploring diverse solution spaces to improve both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on multi-objective trade-off metric\n    def tradeoff_metric(obj):\n        return (obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-8)  # Harmonic mean-like metric\n\n    archive_sorted = sorted(archive, key=lambda x: tradeoff_metric(x[1]))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment rotation\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, n-1)\n    rotation = np.random.randint(1, b-a+1)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective-aware edge insertion\n    c = np.random.randint(1, n-1)\n    node_to_insert = new_solution[c]\n\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n\n        # Calculate improvement for both objectives\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        current_cost1 = distance_matrix_1[prev_node, new_solution[c]] + distance_matrix_1[new_solution[c], next_node]\n        new_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n\n        current_cost2 = distance_matrix_2[prev_node, new_solution[c]] + distance_matrix_2[new_solution[c], next_node]\n        new_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        # Combined improvement metric\n        combined_improvement = (improvement1 * improvement2) / (improvement1 + improvement2 + 1e-8)\n\n        if combined_improvement > best_improvement:\n            best_improvement = combined_improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:best_pos], [node_to_insert], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6508236617528946,
            2.1183353662490845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on multi-objective trade-off metric\n    def tradeoff_metric(obj):\n        return (obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-8)  # Harmonic mean-like metric\n\n    archive_sorted = sorted(archive, key=lambda x: tradeoff_metric(x[1]))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment rotation\n    a = np.random.randint(1, n-2)\n    b = np.random.randint(a+1, n-1)\n    rotation = np.random.randint(1, b-a+1)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective-aware edge insertion\n    c = np.random.randint(1, n-1)\n    node_to_insert = new_solution[c]\n\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n\n        # Calculate improvement for both objectives\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        current_cost1 = distance_matrix_1[prev_node, new_solution[c]] + distance_matrix_1[new_solution[c], next_node]\n        new_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n\n        current_cost2 = distance_matrix_2[prev_node, new_solution[c]] + distance_matrix_2[new_solution[c], next_node]\n        new_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        # Combined improvement metric\n        combined_improvement = (improvement1 * improvement2) / (improvement1 + improvement2 + 1e-8)\n\n        if combined_improvement > best_improvement:\n            best_improvement = combined_improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:best_pos], [node_to_insert], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive based on crowding distance to promote diversity, then applies a hybrid local search combining segment rotation, node insertion, and edge reversal to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance for diversity\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n        obj1 = [s[1][0] for s in solutions]\n        obj2 = [s[1][1] for s in solutions]\n        sorted_idx1 = np.argsort(obj1)\n        sorted_idx2 = np.argsort(obj2)\n\n        distances = [0.0] * len(solutions)\n        for i in range(len(solutions)):\n            if i == 0 or i == len(solutions)-1:\n                distances[i] = float('inf')\n            else:\n                distances[i] = (obj1[sorted_idx1[i+1]] - obj1[sorted_idx1[i-1]]) / (max(obj1) - min(obj1)) + \\\n                              (obj2[sorted_idx2[i+1]] - obj2[sorted_idx2[i-1]]) / (max(obj2) - min(obj2))\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Node insertion\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Edge reversal\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7142139484583802,
            3.828895688056946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance for diversity\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n        obj1 = [s[1][0] for s in solutions]\n        obj2 = [s[1][1] for s in solutions]\n        sorted_idx1 = np.argsort(obj1)\n        sorted_idx2 = np.argsort(obj2)\n\n        distances = [0.0] * len(solutions)\n        for i in range(len(solutions)):\n            if i == 0 or i == len(solutions)-1:\n                distances[i] = float('inf')\n            else:\n                distances[i] = (obj1[sorted_idx1[i+1]] - obj1[sorted_idx1[i-1]]) / (max(obj1) - min(obj1)) + \\\n                              (obj2[sorted_idx2[i+1]] - obj2[sorted_idx2[i-1]]) / (max(obj2) - min(obj2))\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Node insertion\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Edge reversal\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node exchange to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if b > 0 and b < n-1:\n        node1 = new_solution[b]\n        node2 = new_solution[b+1]\n        prev_node = new_solution[b-1]\n\n        original_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2]\n        original_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2]\n\n        new_cost1 = distance_matrix_1[prev_node, node2] + distance_matrix_1[node2, node1]\n        new_cost2 = distance_matrix_2[prev_node, node2] + distance_matrix_2[node2, node1]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[b], new_solution[b+1] = new_solution[b+1], new_solution[b]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8898473636396089,
            2.318533778190613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if b > 0 and b < n-1:\n        node1 = new_solution[b]\n        node2 = new_solution[b+1]\n        prev_node = new_solution[b-1]\n\n        original_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2]\n        original_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2]\n\n        new_cost1 = distance_matrix_1[prev_node, node2] + distance_matrix_1[node2, node1]\n        new_cost2 = distance_matrix_2[prev_node, node2] + distance_matrix_2[node2, node1]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[b], new_solution[b+1] = new_solution[b+1], new_solution[b]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a novel hybrid local search combining a multi-objective-aware segment inversion with a probabilistic node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            if np.random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9672901438437483,
            4.541620969772339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            if np.random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search that combines adaptive segment merging with biased edge reinsertion, guided by the relative strengths of each objective, while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a novel hybrid local search that combines adaptive path inversion with guided node swapping, weighted by the relative performance of each objective, while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum((objectives[:, None, :] < objectives[None, :, :]), axis=2)\n    dominance_scores = np.sum(dominance, axis=1)\n    selection_probs = dominance_scores / np.sum(dominance_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive path inversion\n    segment_size = max(2, min(5, n // 3))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    new_solution[a:b] = new_solution[b-1:a-1:-1]\n\n    # Guided node swapping based on objective weights\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.6) or (cost2 < cost1 and np.random.rand() < 0.4):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Probabilistic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if np.random.rand() < 0.7 and e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6852452213711254,
            1.9022241234779358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum((objectives[:, None, :] < objectives[None, :, :]), axis=2)\n    dominance_scores = np.sum(dominance, axis=1)\n    selection_probs = dominance_scores / np.sum(dominance_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive path inversion\n    segment_size = max(2, min(5, n // 3))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    new_solution[a:b] = new_solution[b-1:a-1:-1]\n\n    # Guided node swapping based on objective weights\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.6) or (cost2 < cost1 and np.random.rand() < 0.4):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Probabilistic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if np.random.rand() < 0.7 and e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, applies a novel segment rotation with multi-objective edge insertion, and then performs a probabilistic inversion of random segments to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted combination of objectives\n    archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation with multi-objective edge insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n\n    # Calculate the cost of the rotated segment\n    cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n    cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n    new_cost1 = sum(distance_matrix_1[rotated_segment[i-1], rotated_segment[i]] for i in range(len(rotated_segment)))\n    new_cost2 = sum(distance_matrix_2[rotated_segment[i-1], rotated_segment[i]] for i in range(len(rotated_segment)))\n\n    if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n        new_solution[a:b+1] = rotated_segment\n\n    # Edge insertion: move a random node to a better position\n    node_pos = np.random.choice(range(1, n-1))\n    node = new_solution[node_pos]\n    best_pos = node_pos\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == node_pos:\n            continue\n        # Calculate the cost of inserting the node at this position\n        cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n        cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n        if cost1 < best_cost1 and cost2 < best_cost2:\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = pos\n\n    if best_pos != node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Probabilistic inversion of random segments\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if np.random.random() < 0.4:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8672276771829563,
            1.6382660269737244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted combination of objectives\n    archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation with multi-objective edge insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, b-a+1))\n\n    # Calculate the cost of the rotated segment\n    cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n    cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n    new_cost1 = sum(distance_matrix_1[rotated_segment[i-1], rotated_segment[i]] for i in range(len(rotated_segment)))\n    new_cost2 = sum(distance_matrix_2[rotated_segment[i-1], rotated_segment[i]] for i in range(len(rotated_segment)))\n\n    if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.3):\n        new_solution[a:b+1] = rotated_segment\n\n    # Edge insertion: move a random node to a better position\n    node_pos = np.random.choice(range(1, n-1))\n    node = new_solution[node_pos]\n    best_pos = node_pos\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == node_pos:\n            continue\n        # Calculate the cost of inserting the node at this position\n        cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n        cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n        if cost1 < best_cost1 and cost2 < best_cost2:\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = pos\n\n    if best_pos != node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Probabilistic inversion of random segments\n    for _ in range(2):\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if np.random.random() < 0.4:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion, which rotates a segment of the tour and then inserts nodes in a way that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node insertion: try to insert nodes in a way that improves both objectives\n    for _ in range(2):\n        i = np.random.choice(range(1, n-1))\n        node = new_solution[i]\n\n        # Find the best position to insert this node\n        best_pos = -1\n        best_cost = (float('inf'), float('inf'))\n\n        for pos in range(1, n-1):\n            if pos == i or pos == i+1:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            # Calculate costs if we insert the node here\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next] - distance_matrix_1[new_prev, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next] - distance_matrix_2[new_prev, new_next]\n\n            if new_cost1 < best_cost[0] and new_cost2 < best_cost[1]:\n                best_pos = pos\n                best_cost = (new_cost1, new_cost2)\n\n        if best_pos != -1:\n            # Remove the node and insert it at the best position\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6676712871845609,
            1.5301509499549866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node insertion: try to insert nodes in a way that improves both objectives\n    for _ in range(2):\n        i = np.random.choice(range(1, n-1))\n        node = new_solution[i]\n\n        # Find the best position to insert this node\n        best_pos = -1\n        best_cost = (float('inf'), float('inf'))\n\n        for pos in range(1, n-1):\n            if pos == i or pos == i+1:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            # Calculate costs if we insert the node here\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next] - distance_matrix_1[new_prev, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next] - distance_matrix_2[new_prev, new_next]\n\n            if new_cost1 < best_cost[0] and new_cost2 < best_cost[1]:\n                best_pos = pos\n                best_cost = (new_cost1, new_cost2)\n\n        if best_pos != -1:\n            # Remove the node and insert it at the best position\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes with an adaptive probability based on the solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select based on weighted sum\n    objectives = np.array([x[1] for x in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = [0.6, 0.4]  # Higher weight for first objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)  # Select the best normalized solution\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one with adaptive probability\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Calculate adaptive probability based on solution quality\n    quality = scores[selected_idx]\n    prob = 0.3 + 0.4 * (1 - quality)  # Higher probability for better solutions\n\n    if np.random.random() < prob:\n        for pos in range(1, n-1):\n            if pos == c or pos == c+1:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            # Calculate costs if we insert the contracted node here\n            new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n            # Compare with current cost\n            current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n            current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n                # Remove the two nodes and insert the contracted node\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n                break\n\n    # Probabilistic swap of adjacent nodes with adaptive probability\n    swap_prob = 0.2 + 0.3 * (1 - quality)\n    for i in range(1, n-1):\n        if np.random.random() < swap_prob:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.792301106136255,
            1.7037718892097473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select based on weighted sum\n    objectives = np.array([x[1] for x in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = [0.6, 0.4]  # Higher weight for first objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)  # Select the best normalized solution\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one with adaptive probability\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Calculate adaptive probability based on solution quality\n    quality = scores[selected_idx]\n    prob = 0.3 + 0.4 * (1 - quality)  # Higher probability for better solutions\n\n    if np.random.random() < prob:\n        for pos in range(1, n-1):\n            if pos == c or pos == c+1:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            # Calculate costs if we insert the contracted node here\n            new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n            # Compare with current cost\n            current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n            current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n                # Remove the two nodes and insert the contracted node\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n                break\n\n    # Probabilistic swap of adjacent nodes with adaptive probability\n    swap_prob = 0.2 + 0.3 * (1 - quality)\n    for i in range(1, n-1):\n        if np.random.random() < swap_prob:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized objective values, then applies a hybrid local search combining a multi-segment inversion with a Pareto-aware node relocation that explores the solution space by strategically reordering and repositioning multiple segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective balance\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Multi-segment inversion\n    points = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    a, b, c, d = points\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n    new_solution[c:d+1] = new_solution[d:c-1:-1]\n\n    # Pareto-aware node relocation\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        node = new_solution[i]\n\n        # Evaluate potential insertion positions\n        candidates = []\n        for pos in range(1, n-1):\n            if pos == i:\n                continue\n            cost1 = (distance_matrix_1[new_solution[pos-1], node] +\n                    distance_matrix_1[node, new_solution[pos]])\n            cost2 = (distance_matrix_2[new_solution[pos-1], node] +\n                    distance_matrix_2[node, new_solution[pos]])\n\n            # Check if this insertion dominates current position\n            if (cost1 < distance_matrix_1[new_solution[pos-1], new_solution[pos]] and\n                cost2 < distance_matrix_2[new_solution[pos-1], new_solution[pos]]):\n                candidates.append(pos)\n\n        if candidates:\n            best_pos = np.random.choice(candidates)\n            new_solution = np.concatenate([\n                new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]\n            ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5173099867319032,
            2.6584991216659546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective balance\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Multi-segment inversion\n    points = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    a, b, c, d = points\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n    new_solution[c:d+1] = new_solution[d:c-1:-1]\n\n    # Pareto-aware node relocation\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        node = new_solution[i]\n\n        # Evaluate potential insertion positions\n        candidates = []\n        for pos in range(1, n-1):\n            if pos == i:\n                continue\n            cost1 = (distance_matrix_1[new_solution[pos-1], node] +\n                    distance_matrix_1[node, new_solution[pos]])\n            cost2 = (distance_matrix_2[new_solution[pos-1], node] +\n                    distance_matrix_2[node, new_solution[pos]])\n\n            # Check if this insertion dominates current position\n            if (cost1 < distance_matrix_1[new_solution[pos-1], new_solution[pos]] and\n                cost2 < distance_matrix_2[new_solution[pos-1], new_solution[pos]]):\n                candidates.append(pos)\n\n        if candidates:\n            best_pos = np.random.choice(candidates)\n            new_solution = np.concatenate([\n                new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]\n            ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a novel local search combining a multi-objective-aware segment crossover with a probabilistic node swapping that strategically recombines and reorders segments while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment crossover\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Probabilistic node swapping\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            j = np.random.randint(1, n-1)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[i+1]])\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[i+1]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[i+1]])\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[i+1]])\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.random() < 0.1:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Reinsert the segment in a new position\n    new_pos = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Remove duplicates (if any) by reinserting missing nodes\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            pos = np.random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.874541125701721,
            0.7724201679229736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment crossover\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Probabilistic node swapping\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            j = np.random.randint(1, n-1)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[i+1]])\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[i+1]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[i+1]])\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[i+1]])\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or np.random.random() < 0.1:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Reinsert the segment in a new position\n    new_pos = np.random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Remove duplicates (if any) by reinserting missing nodes\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            pos = np.random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7143543353424266,
            1.7448411583900452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    segment_start = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-segment_start))\n    new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized objective values and applies a hybrid local search combining a novel node insertion with a multi-objective-aware edge swap, which swaps two non-adjacent edges and then inserts a node in a position that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective balance\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node insertion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node = new_solution[b]\n    new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n\n    # Find best insertion position for node\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == b or pos == b-1:\n            continue\n        prev = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n        if cost1 + cost2 < min_cost:\n            min_cost = cost1 + cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Edge swap for non-adjacent edges\n    c, d = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    if abs(c - d) > 1:\n        node1, node2 = new_solution[c], new_solution[d]\n        new_solution[c], new_solution[d] = node2, node1\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.69777545677346,
            2.0047703981399536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective balance\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node insertion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node = new_solution[b]\n    new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n\n    # Find best insertion position for node\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(1, n-1):\n        if pos == b or pos == b-1:\n            continue\n        prev = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n        if cost1 + cost2 < min_cost:\n            min_cost = cost1 + cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Edge swap for non-adjacent edges\n    c, d = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    if abs(c - d) > 1:\n        node1, node2 = new_solution[c], new_solution[d]\n        new_solution[c], new_solution[d] = node2, node1\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node permutation that explores the solution space by strategically reordering segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node permutation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node permutation: reorder a segment to improve both objectives if possible\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_permute = new_solution[c:d+1]\n    permuted_segment = segment_to_permute[np.random.permutation(len(segment_to_permute))]\n    new_solution[c:d+1] = permuted_segment\n\n    # Check feasibility and revert if invalid\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7551647334244784,
            1.7182079553604126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node permutation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node permutation: reorder a segment to improve both objectives if possible\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_permute = new_solution[c:d+1]\n    permuted_segment = segment_to_permute[np.random.permutation(len(segment_to_permute))]\n    new_solution[c:d+1] = permuted_segment\n\n    # Check feasibility and revert if invalid\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node insertion: insert a node from outside the current segment back into the segment\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(a, b+1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position within the segment\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9586453020832186,
            0.8715577721595764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node insertion: insert a node from outside the current segment back into the segment\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(a, b+1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position within the segment\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n\n    # Multi-objective node swap: swap nodes that improve both objectives if possible\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1) % n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1) % n]\n\n            current_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + \\\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n            current_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + \\\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n            new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + \\\n                        distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n            new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + \\\n                        distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8526177562775817,
            2.9716219902038574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n\n    # Multi-objective node swap: swap nodes that improve both objectives if possible\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1) % n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1) % n]\n\n            current_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + \\\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n            current_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + \\\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n            new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + \\\n                        distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n            new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + \\\n                        distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9898153387900055,
            0.6859681606292725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    l = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(5, n-l))\n    inverted_segment = new_solution[l:l+segment_length][::-1]\n    new_solution[l:l+segment_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.889624209863184,
            1.867165982723236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Invert a segment to balance objectives\n    l = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(5, n-l))\n    inverted_segment = new_solution[l:l+segment_length][::-1]\n    new_solution[l:l+segment_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search that combines adaptive segment merging with biased edge reinsertion, guided by the relative strengths of each objective, while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and spatial proximity, then applies a novel hybrid local search that combines adaptive node clustering with biased edge insertion, guided by the relative spatial characteristics of each objective, while ensuring feasibility through a dynamic repair mechanism that maintains both tour validity and objective balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective dominance and spatial proximity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    dominance = np.sum(normalized, axis=1)\n    selection_probs = dominance / np.sum(dominance)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, min(4, n // 5))\n    cluster_indices = np.random.choice(range(n), size=cluster_size, replace=False)\n    cluster_nodes = new_solution[cluster_indices]\n\n    # Spatial-aware edge insertion\n    for i in range(n):\n        if np.random.rand() < 0.5:\n            # Calculate spatial proximity in both objectives\n            node_coords = instance[new_solution[i]]\n            cluster_coords = instance[cluster_nodes]\n            dist1 = np.linalg.norm(node_coords[:2] - cluster_coords[:, :2], axis=1)\n            dist2 = np.linalg.norm(node_coords[2:] - cluster_coords[:, 2:], axis=1)\n            combined_dist = dist1 + dist2\n\n            # Insert node into cluster based on spatial proximity\n            insert_pos = np.argmin(combined_dist)\n            cluster_nodes = np.insert(cluster_nodes, insert_pos, new_solution[i])\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.concatenate([new_solution[:i], cluster_nodes, new_solution[i:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution:\n                    idx = np.where(new_solution == e)[0]\n                    if len(idx) > 0:\n                        new_solution[idx[0]] = m\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9337038181592096,
            4.627025723457336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective dominance and spatial proximity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    dominance = np.sum(normalized, axis=1)\n    selection_probs = dominance / np.sum(dominance)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, min(4, n // 5))\n    cluster_indices = np.random.choice(range(n), size=cluster_size, replace=False)\n    cluster_nodes = new_solution[cluster_indices]\n\n    # Spatial-aware edge insertion\n    for i in range(n):\n        if np.random.rand() < 0.5:\n            # Calculate spatial proximity in both objectives\n            node_coords = instance[new_solution[i]]\n            cluster_coords = instance[cluster_nodes]\n            dist1 = np.linalg.norm(node_coords[:2] - cluster_coords[:, :2], axis=1)\n            dist2 = np.linalg.norm(node_coords[2:] - cluster_coords[:, 2:], axis=1)\n            combined_dist = dist1 + dist2\n\n            # Insert node into cluster based on spatial proximity\n            insert_pos = np.argmin(combined_dist)\n            cluster_nodes = np.insert(cluster_nodes, insert_pos, new_solution[i])\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.concatenate([new_solution[:i], cluster_nodes, new_solution[i:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution:\n                    idx = np.where(new_solution == e)[0]\n                    if len(idx) > 0:\n                        new_solution[idx[0]] = m\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search combining node relocation, segment inversion, and edge swapping to explore the solution space while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (sum of objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: node relocation, segment inversion, and edge swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a node to relocate\n    node_idx = np.random.choice(range(1, n-1))\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Randomly select a new position to insert the node\n    insert_pos = np.random.choice(range(1, n))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly select a segment to invert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select two edges to swap\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rearrangement with a multi-objective-aware edge reversal to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rearrangement with multi-objective edge reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Randomly rearrange the segment\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Multi-objective edge reversal: reverse edges that improve both objectives if possible\n    for i in range(1, n-1):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[i+1]\n\n        current_cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        current_cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Try reversing the edge\n        new_cost1 = distance_matrix_1[prev, next_node] + distance_matrix_1[next_node, curr]\n        new_cost2 = distance_matrix_2[prev, next_node] + distance_matrix_2[next_node, curr]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8771486810600997,
            2.3306263089179993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rearrangement with multi-objective edge reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Randomly rearrange the segment\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Multi-objective edge reversal: reverse edges that improve both objectives if possible\n    for i in range(1, n-1):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[i+1]\n\n        current_cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        current_cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Try reversing the edge\n        new_cost1 = distance_matrix_1[prev, next_node] + distance_matrix_1[next_node, curr]\n        new_cost2 = distance_matrix_2[prev, next_node] + distance_matrix_2[next_node, curr]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9634846493260885,
            1.4763165712356567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm selects a solution with the highest individual objective value in either space, then applies a hybrid local search combining random segment reversal with a node shift to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest objective value in either space\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Random segment reversal with node shift\n    i = np.random.randint(1, n-2)\n    j = np.random.randint(i+1, min(i+5, n-1))\n    new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    # Shift a node to balance objectives\n    k = np.random.randint(1, n-1)\n    temp = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, temp)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8385203642149371,
            2.0202279090881348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest objective value in either space\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Random segment reversal with node shift\n    i = np.random.randint(1, n-2)\n    j = np.random.randint(i+1, min(i+5, n-1))\n    new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    # Shift a node to balance objectives\n    k = np.random.randint(1, n-1)\n    temp = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, temp)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate original costs\n    prev1 = new_solution[c-1]\n    next1 = new_solution[c+1] if c+1 < n else new_solution[0]\n    prev2 = new_solution[d-1]\n    next2 = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] +\n                      distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2])\n    original_cost2 = (distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] +\n                      distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2])\n\n    # Calculate new costs after swap\n    new_cost1 = (distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] +\n                 distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2])\n    new_cost2 = (distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] +\n                 distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7534901829039299,
            2.1260634064674377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate original costs\n    prev1 = new_solution[c-1]\n    next1 = new_solution[c+1] if c+1 < n else new_solution[0]\n    prev2 = new_solution[d-1]\n    next2 = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] +\n                      distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2])\n    original_cost2 = (distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] +\n                      distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2])\n\n    # Calculate new costs after swap\n    new_cost1 = (distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] +\n                 distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2])\n    new_cost2 = (distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] +\n                 distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This new algorithm selects a solution with the highest weighted sum of objectives (using adaptive weights based on objective ranges) and applies a hybrid local search combining 3-opt with a novel segment inversion to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate adaptive weights based on objective ranges\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    range1 = max(obj1_values) - min(obj1_values) if max(obj1_values) != min(obj1_values) else 1.0\n    range2 = max(obj2_values) - min(obj2_values) if max(obj2_values) != min(obj2_values) else 1.0\n    w1 = range2 / (range1 + range2)\n    w2 = range1 / (range1 + range2)\n\n    # Select solution with highest weighted sum\n    selected_solution = max(archive, key=lambda x: w1 * x[1][0] + w2 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-2), size=3, replace=False))\n\n    # Perform 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Invert a segment for better balance\n    l = np.random.randint(1, n-1)\n    m = np.random.randint(l, n)\n    new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7853144156227804,
            2.4020477533340454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate adaptive weights based on objective ranges\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    range1 = max(obj1_values) - min(obj1_values) if max(obj1_values) != min(obj1_values) else 1.0\n    range2 = max(obj2_values) - min(obj2_values) if max(obj2_values) != min(obj2_values) else 1.0\n    w1 = range2 / (range1 + range2)\n    w2 = range1 / (range1 + range2)\n\n    # Select solution with highest weighted sum\n    selected_solution = max(archive, key=lambda x: w1 * x[1][0] + w2 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(range(1, n-2), size=3, replace=False))\n\n    # Perform 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Invert a segment for better balance\n    l = np.random.randint(1, n-1)\n    m = np.random.randint(l, n)\n    new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm selects a solution from the archive with the most balanced objectives, then applies a hybrid local search combining a novel node insertion strategy with a multi-objective-aware path reversal, followed by a probabilistic segment shift to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node insertion with path reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_to_move = new_solution[a]\n\n    # Remove the node and find the best insertion point\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+1:]])\n\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n):\n        if pos == a:\n            continue\n\n        # Calculate the improvement for both objectives\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, next_node]\n\n        new_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        # Combine improvements in a balanced way\n        total_improvement = improvement1 + improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Path reversal for further improvement\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Probabilistic segment shift\n    if np.random.random() < 0.4:\n        e = np.random.randint(1, n-2)\n        segment_length = np.random.randint(2, min(5, n-e))\n        shifted_segment = np.roll(new_solution[e:e+segment_length], -1)\n        new_solution[e:e+segment_length] = shifted_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8674638143549825,
            2.178798258304596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node insertion with path reversal\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_to_move = new_solution[a]\n\n    # Remove the node and find the best insertion point\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+1:]])\n\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n):\n        if pos == a:\n            continue\n\n        # Calculate the improvement for both objectives\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, next_node]\n\n        new_cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        # Combine improvements in a balanced way\n        total_improvement = improvement1 + improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Path reversal for further improvement\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Probabilistic segment shift\n    if np.random.random() < 0.4:\n        e = np.random.randint(1, n-2)\n        segment_length = np.random.randint(2, min(5, n-e))\n        shifted_segment = np.roll(new_solution[e:e+segment_length], -1)\n        new_solution[e:e+segment_length] = shifted_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, and then performs a probabilistic swap of adjacent nodes to further improve the solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Probabilistic swap of adjacent nodes\n    for i in range(1, n-1):\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node relocation that considers both objectives' improvements simultaneously, followed by a probabilistic edge swap to further refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Multi-objective node relocation: relocate nodes to improve both objectives\n    for i in range(1, n-1):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try relocating node to a new position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != i:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Probabilistic edge swap\n    for i in range(1, n-2):\n        if np.random.random() < 0.3:\n            # Swap edges (i-1, i, i+1, i+2) to (i-1, i+1, i, i+2)\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8493410900339462,
            5.7856833934783936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Multi-objective node relocation: relocate nodes to improve both objectives\n    for i in range(1, n-1):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[i+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try relocating node to a new position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != i:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Probabilistic edge swap\n    for i in range(1, n-2):\n        if np.random.random() < 0.3:\n            # Swap edges (i-1, i, i+1, i+2) to (i-1, i+1, i, i+2)\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge exchange that explores the solution space by strategically inverting segments and exchanging edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted combination of objectives\n    weights = np.array([0.6, 0.4])  # Weight for objective 1 and 2\n    archive_sorted = sorted(archive, key=lambda x: np.dot(x[1], weights))\n    selected_solution = archive_sorted[len(archive_sorted) // 4][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge exchange: swap two edges if it improves both objectives\n    i = np.random.randint(1, n-2)\n    j = np.random.randint(i+1, n-1)\n\n    # Calculate costs for the original and new configurations\n    original_edges1 = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]],\n        distance_matrix_1[new_solution[i], new_solution[i+1]],\n        distance_matrix_1[new_solution[j-1], new_solution[j]],\n        distance_matrix_1[new_solution[j], new_solution[j+1]]\n    ]\n    original_edges2 = [\n        distance_matrix_2[new_solution[i-1], new_solution[i]],\n        distance_matrix_2[new_solution[i], new_solution[i+1]],\n        distance_matrix_2[new_solution[j-1], new_solution[j]],\n        distance_matrix_2[new_solution[j], new_solution[j+1]]\n    ]\n\n    new_edges1 = [\n        distance_matrix_1[new_solution[i-1], new_solution[j]],\n        distance_matrix_1[new_solution[j], new_solution[i+1]],\n        distance_matrix_1[new_solution[j-1], new_solution[i]],\n        distance_matrix_1[new_solution[i], new_solution[j+1]]\n    ]\n    new_edges2 = [\n        distance_matrix_2[new_solution[i-1], new_solution[j]],\n        distance_matrix_2[new_solution[j], new_solution[i+1]],\n        distance_matrix_2[new_solution[j-1], new_solution[i]],\n        distance_matrix_2[new_solution[i], new_solution[j+1]]\n    ]\n\n    original_total1 = sum(original_edges1)\n    original_total2 = sum(original_edges2)\n    new_total1 = sum(new_edges1)\n    new_total2 = sum(new_edges2)\n\n    # Compare costs\n    if (new_total1 < original_total1 and new_total2 < original_total2) or (np.random.random() < 0.3):\n        # Perform the edge exchange\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7971104901099948,
            1.6223329305648804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted combination of objectives\n    weights = np.array([0.6, 0.4])  # Weight for objective 1 and 2\n    archive_sorted = sorted(archive, key=lambda x: np.dot(x[1], weights))\n    selected_solution = archive_sorted[len(archive_sorted) // 4][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge exchange: swap two edges if it improves both objectives\n    i = np.random.randint(1, n-2)\n    j = np.random.randint(i+1, n-1)\n\n    # Calculate costs for the original and new configurations\n    original_edges1 = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]],\n        distance_matrix_1[new_solution[i], new_solution[i+1]],\n        distance_matrix_1[new_solution[j-1], new_solution[j]],\n        distance_matrix_1[new_solution[j], new_solution[j+1]]\n    ]\n    original_edges2 = [\n        distance_matrix_2[new_solution[i-1], new_solution[i]],\n        distance_matrix_2[new_solution[i], new_solution[i+1]],\n        distance_matrix_2[new_solution[j-1], new_solution[j]],\n        distance_matrix_2[new_solution[j], new_solution[j+1]]\n    ]\n\n    new_edges1 = [\n        distance_matrix_1[new_solution[i-1], new_solution[j]],\n        distance_matrix_1[new_solution[j], new_solution[i+1]],\n        distance_matrix_1[new_solution[j-1], new_solution[i]],\n        distance_matrix_1[new_solution[i], new_solution[j+1]]\n    ]\n    new_edges2 = [\n        distance_matrix_2[new_solution[i-1], new_solution[j]],\n        distance_matrix_2[new_solution[j], new_solution[i+1]],\n        distance_matrix_2[new_solution[j-1], new_solution[i]],\n        distance_matrix_2[new_solution[i], new_solution[j+1]]\n    ]\n\n    original_total1 = sum(original_edges1)\n    original_total2 = sum(original_edges2)\n    new_total1 = sum(new_edges1)\n    new_total2 = sum(new_edges2)\n\n    # Compare costs\n    if (new_total1 < original_total1 and new_total2 < original_total2) or (np.random.random() < 0.3):\n        # Perform the edge exchange\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment shuffle with a multi-objective-aware node swap that explores the solution space by randomly reordering segments and strategically swapping nodes to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shuffle with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    orig_prev_i = new_solution[i-1]\n    orig_next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_prev_j = new_solution[j-1]\n    orig_next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev_i, node_i] + distance_matrix_1[node_i, orig_next_i] +\n                  distance_matrix_1[orig_prev_j, node_j] + distance_matrix_1[node_j, orig_next_j])\n    orig_cost2 = (distance_matrix_2[orig_prev_i, node_i] + distance_matrix_2[node_i, orig_next_i] +\n                  distance_matrix_2[orig_prev_j, node_j] + distance_matrix_2[node_j, orig_next_j])\n\n    # Calculate new costs after swap\n    new_prev_i = new_solution[i-1]\n    new_next_i = new_solution[j+1] if j+1 < n else new_solution[0]\n    new_prev_j = new_solution[j-1]\n    new_next_j = new_solution[i+1] if i+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[new_prev_i, node_j] + distance_matrix_1[node_j, new_next_i] +\n                 distance_matrix_1[new_prev_j, node_i] + distance_matrix_1[node_i, new_next_j])\n    new_cost2 = (distance_matrix_2[new_prev_i, node_j] + distance_matrix_2[node_j, new_next_i] +\n                 distance_matrix_2[new_prev_j, node_i] + distance_matrix_2[node_i, new_next_j])\n\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6479053372934465,
            1.2754616141319275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shuffle with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    orig_prev_i = new_solution[i-1]\n    orig_next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_prev_j = new_solution[j-1]\n    orig_next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev_i, node_i] + distance_matrix_1[node_i, orig_next_i] +\n                  distance_matrix_1[orig_prev_j, node_j] + distance_matrix_1[node_j, orig_next_j])\n    orig_cost2 = (distance_matrix_2[orig_prev_i, node_i] + distance_matrix_2[node_i, orig_next_i] +\n                  distance_matrix_2[orig_prev_j, node_j] + distance_matrix_2[node_j, orig_next_j])\n\n    # Calculate new costs after swap\n    new_prev_i = new_solution[i-1]\n    new_next_i = new_solution[j+1] if j+1 < n else new_solution[0]\n    new_prev_j = new_solution[j-1]\n    new_next_j = new_solution[i+1] if i+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[new_prev_i, node_j] + distance_matrix_1[node_j, new_next_i] +\n                 distance_matrix_1[new_prev_j, node_i] + distance_matrix_1[node_i, new_next_j])\n    new_cost2 = (distance_matrix_2[new_prev_i, node_j] + distance_matrix_2[node_j, new_next_i] +\n                 distance_matrix_2[new_prev_j, node_i] + distance_matrix_2[node_i, new_next_j])\n\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate original costs\n    prev_c = new_solution[c-1]\n    next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                      distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n    original_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                      distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n    # Calculate new costs after swap\n    new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                 distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n    new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                 distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8251857912290886,
            1.613311231136322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate original costs\n    prev_c = new_solution[c-1]\n    next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                      distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n    original_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                      distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n    # Calculate new costs after swap\n    new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                 distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n    new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                 distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment relocation with a multi-objective-aware edge inversion to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment relocation with multi-objective edge inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge inversion: invert edges that improve both objectives if possible\n    for i in range(1, n-1):\n        node1 = new_solution[i-1]\n        node2 = new_solution[i]\n        node3 = new_solution[i+1]\n\n        current_cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node2, node3]\n        current_cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node2, node3]\n\n        # Try inverting the edge\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node3, node2]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node3, node2]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7960257915761688,
            1.2541500926017761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment relocation with multi-objective edge inversion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Relocate segment [a:b] to position c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], segment, new_solution[c:]])\n\n    # Multi-objective edge inversion: invert edges that improve both objectives if possible\n    for i in range(1, n-1):\n        node1 = new_solution[i-1]\n        node2 = new_solution[i]\n        node3 = new_solution[i+1]\n\n        current_cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node2, node3]\n        current_cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node2, node3]\n\n        # Try inverting the edge\n        new_cost1 = distance_matrix_1[node1, node3] + distance_matrix_1[node3, node2]\n        new_cost2 = distance_matrix_2[node1, node3] + distance_matrix_2[node3, node2]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a novel local search combining 3-opt with a segment rotation to explore diverse improvements while maintaining feasibility through careful position swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # 3-opt with segment rotation\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Perform 3-opt exchange\n    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Rotate a segment to explore different configurations\n    segment_start = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    rotated_segment = np.roll(new_solution[segment_start:segment_start+segment_length], 1)\n    new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.683094235756178,
            1.6260865330696106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # 3-opt with segment rotation\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Perform 3-opt exchange\n    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Rotate a segment to explore different configurations\n    segment_start = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(4, n-segment_start))\n    rotated_segment = np.roll(new_solution[segment_start:segment_start+segment_length], 1)\n    new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swapping that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node swapping: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate costs for the original and new positions\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[original_prev_c, node_c] + distance_matrix_1[node_c, original_next_c] +\n                      distance_matrix_1[original_prev_d, node_d] + distance_matrix_1[node_d, original_next_d])\n    original_cost2 = (distance_matrix_2[original_prev_c, node_c] + distance_matrix_2[node_c, original_next_c] +\n                      distance_matrix_2[original_prev_d, node_d] + distance_matrix_2[node_d, original_next_d])\n\n    new_cost1 = (distance_matrix_1[original_prev_c, node_d] + distance_matrix_1[node_d, original_next_c] +\n                 distance_matrix_1[original_prev_d, node_c] + distance_matrix_1[node_c, original_next_d])\n    new_cost2 = (distance_matrix_2[original_prev_c, node_d] + distance_matrix_2[node_d, original_next_c] +\n                 distance_matrix_2[original_prev_d, node_c] + distance_matrix_2[node_c, original_next_d])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6174071247221244,
            1.761343538761139
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node swapping: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate costs for the original and new positions\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[original_prev_c, node_c] + distance_matrix_1[node_c, original_next_c] +\n                      distance_matrix_1[original_prev_d, node_d] + distance_matrix_1[node_d, original_next_d])\n    original_cost2 = (distance_matrix_2[original_prev_c, node_c] + distance_matrix_2[node_c, original_next_c] +\n                      distance_matrix_2[original_prev_d, node_d] + distance_matrix_2[node_d, original_next_d])\n\n    new_cost1 = (distance_matrix_1[original_prev_c, node_d] + distance_matrix_1[node_d, original_next_c] +\n                 distance_matrix_1[original_prev_d, node_c] + distance_matrix_1[node_c, original_next_d])\n    new_cost2 = (distance_matrix_2[original_prev_c, node_d] + distance_matrix_2[node_d, original_next_c] +\n                 distance_matrix_2[original_prev_d, node_c] + distance_matrix_2[node_c, original_next_d])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge swapping to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swapping: swap edges that improve both objectives if possible\n    for i in range(1, n-1):\n        if i > a and i < b:\n            continue\n\n        for j in range(i+1, n-1):\n            if j > a and j < b:\n                continue\n\n            current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[j], new_solution[i]])\n\n            current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[j], new_solution[i]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                        distance_matrix_1[new_solution[i], new_solution[i+1]])\n\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                        distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7560176599981778,
            3.7079771161079407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swapping: swap edges that improve both objectives if possible\n    for i in range(1, n-1):\n        if i > a and i < b:\n            continue\n\n        for j in range(i+1, n-1):\n            if j > a and j < b:\n                continue\n\n            current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[j], new_solution[i]])\n\n            current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[j], new_solution[i]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                        distance_matrix_1[new_solution[i], new_solution[i+1]])\n\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                        distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This new algorithm selects a solution from the archive based on its trade-off between objectives (using a weighted sum with random weights) and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swapping to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with random weighted sum of objectives\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    selected_idx = np.argmin([obj[0] * weights[i] + obj[1] * (1 - weights[i]) for i, (sol, obj) in enumerate(archive)])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swapping: swap nodes that improve both objectives if possible\n    for i in range(1, n-2):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1]\n\n            current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                             distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n            current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                             distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                          distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n            new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                          distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7115926499607137,
            3.288300633430481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with random weighted sum of objectives\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    selected_idx = np.argmin([obj[0] * weights[i] + obj[1] * (1 - weights[i]) for i, (sol, obj) in enumerate(archive)])\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swapping: swap nodes that improve both objectives if possible\n    for i in range(1, n-2):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1]\n\n            current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                             distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n            current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                             distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                          distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n            new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                          distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b]\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Multi-objective node swap: swap nodes that improve both objectives if possible\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1]\n\n            # Current cost\n            current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n            current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # New cost after swap\n            new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                         distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n            new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                         distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                # Perform swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.867780986588262,
            3.3534112572669983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b]\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Multi-objective node swap: swap nodes that improve both objectives if possible\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1]\n\n            # Current cost\n            current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n            current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # New cost after swap\n            new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                         distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n            new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                         distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                # Perform swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a hybrid local search combining 2-opt with a novel segment rotation to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 2-opt with segment rotation\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Rotate a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(4, n-k))\n    rotated_segment = np.roll(new_solution[k:k+segment_length], 1)\n    new_solution[k:k+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swap to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swap: find edges that can be swapped to improve both objectives\n    for i in range(1, n-2):\n        for j in range(i+2, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1]\n\n            # Current costs\n            cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n            cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n            # Swap nodes i and j\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # New costs\n            new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n            new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n            if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.1):\n                # Keep the swap if it improves both objectives or with small probability\n                break\n            else:\n                # Revert the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6575487049619662,
            6.1767935156822205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swap: find edges that can be swapped to improve both objectives\n    for i in range(1, n-2):\n        for j in range(i+2, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1]\n\n            # Current costs\n            cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n            cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n            # Swap nodes i and j\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # New costs\n            new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n            new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n            if (new_cost1 < cost1 and new_cost2 < cost2) or (np.random.random() < 0.1):\n                # Keep the swap if it improves both objectives or with small probability\n                break\n            else:\n                # Revert the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node insertion that explores the solution space by strategically reversing segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted sum of objectives (weighted by 0.6 for first objective)\n    archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node insertion: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs with a stricter improvement condition\n        if (new_cost1 < original_cost1 - 0.1 * original_cost1 and new_cost2 < original_cost2 - 0.1 * original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5133460366076406,
            0.7746028900146484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted sum of objectives (weighted by 0.6 for first objective)\n    archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node insertion: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs with a stricter improvement condition\n        if (new_cost1 < original_cost1 - 0.1 * original_cost1 and new_cost2 < original_cost2 - 0.1 * original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node swapping that explores the solution space by strategically rotating segments and swapping nodes while maintaining feasibility, ensuring both objectives are improved if possible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, k)\n\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swapping: swap two nodes to improve both objectives if possible\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs if we swap the nodes\n    prev_c = new_solution[c-1]\n    next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[prev_c, node2] + distance_matrix_1[node2, next_c] +\n                 distance_matrix_1[prev_d, node1] + distance_matrix_1[node1, next_d])\n    new_cost2 = (distance_matrix_2[prev_c, node2] + distance_matrix_2[node2, next_c] +\n                 distance_matrix_2[prev_d, node1] + distance_matrix_2[node1, next_d])\n\n    current_cost1 = (distance_matrix_1[prev_c, node1] + distance_matrix_1[node1, next_c] +\n                      distance_matrix_1[prev_d, node2] + distance_matrix_1[node2, next_d])\n    current_cost2 = (distance_matrix_2[prev_c, node1] + distance_matrix_2[node1, next_c] +\n                      distance_matrix_2[prev_d, node2] + distance_matrix_2[node2, next_d])\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6089066948282282,
            2.020796239376068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, k)\n\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swapping: swap two nodes to improve both objectives if possible\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs if we swap the nodes\n    prev_c = new_solution[c-1]\n    next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[prev_c, node2] + distance_matrix_1[node2, next_c] +\n                 distance_matrix_1[prev_d, node1] + distance_matrix_1[node1, next_d])\n    new_cost2 = (distance_matrix_2[prev_c, node2] + distance_matrix_2[node2, next_c] +\n                 distance_matrix_2[prev_d, node1] + distance_matrix_2[node1, next_d])\n\n    current_cost1 = (distance_matrix_1[prev_c, node1] + distance_matrix_1[node1, next_c] +\n                      distance_matrix_1[prev_d, node2] + distance_matrix_1[node2, next_d])\n    current_cost2 = (distance_matrix_2[prev_c, node1] + distance_matrix_2[node1, next_c] +\n                      distance_matrix_2[prev_d, node2] + distance_matrix_2[node2, next_d])\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0023958341632264,
            0.8338179588317871
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0023958341632264,
            0.8338179588317871
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment permutation with a multi-objective-aware node swapping, which rearranges segments of the tour while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Multi-objective node swapping: swap nodes that improve both objectives if possible\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Current cost\n            current_cost1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] + \\\n                           distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] + \\\n                           distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]]\n\n            # Swapped cost\n            swapped_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] + \\\n                           distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]]\n            swapped_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] + \\\n                           distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]]\n\n            if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.630019878160458,
            2.769276440143585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Multi-objective node swapping: swap nodes that improve both objectives if possible\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Current cost\n            current_cost1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] + \\\n                           distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] + \\\n                           distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]]\n\n            # Swapped cost\n            swapped_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] + \\\n                           distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]]\n            swapped_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] + \\\n                           distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]]\n\n            if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid local search combining a novel path-shifting operation with a multi-objective-aware segment rotation that explores the solution space by shifting segments of the tour and rotating them in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path-shifting with segment rotation\n    # Randomly select a segment to shift\n    start = np.random.randint(1, n-2)\n    length = np.random.randint(2, min(5, n-start))\n    segment = new_solution[start:start+length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n\n    # Randomly insert the segment at a new position\n    insert_pos = np.random.randint(1, n-length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Rotate the segment by a random amount\n    rotation = np.random.randint(1, length)\n    segment_rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[insert_pos:insert_pos+length] = segment_rotated\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3306668106204956,
            1.7000153064727783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path-shifting with segment rotation\n    # Randomly select a segment to shift\n    start = np.random.randint(1, n-2)\n    length = np.random.randint(2, min(5, n-start))\n    segment = new_solution[start:start+length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n\n    # Randomly insert the segment at a new position\n    insert_pos = np.random.randint(1, n-length)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Rotate the segment by a random amount\n    rotation = np.random.randint(1, length)\n    segment_rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[insert_pos:insert_pos+length] = segment_rotated\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This algorithm selects a solution with the highest average objective value from the archive, then applies a novel local search combining a 3-opt move with a segment rotation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest average objective value\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt move with segment rotation\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i:j] = new_solution[j-1:i-1:-1]\n    new_solution[j:k] = new_solution[k-1:j-1:-1]\n\n    # Rotate a segment to balance objectives\n    l = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(4, n-l))\n    rotation = np.random.randint(1, segment_length)\n    segment = new_solution[l:l+segment_length]\n    new_solution[l:l+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8428536196766637,
            1.8196421265602112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest average objective value\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt move with segment rotation\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i:j] = new_solution[j-1:i-1:-1]\n    new_solution[j:k] = new_solution[k-1:j-1:-1]\n\n    # Rotate a segment to balance objectives\n    l = np.random.randint(1, n-3)\n    segment_length = np.random.randint(2, min(4, n-l))\n    rotation = np.random.randint(1, segment_length)\n    segment = new_solution[l:l+segment_length]\n    new_solution[l:l+segment_length] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node swap that explores the solution space by strategically reordering and exchanging segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = min(5, b - a + 1)\n    rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, segment_length))\n\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swap: exchange two nodes to improve both objectives if possible\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c, node_d = new_solution[c], new_solution[d]\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] + \\\n                    distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]]\n    current_cost2 = distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] + \\\n                    distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.73504830440008,
            2.0510788559913635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = min(5, b - a + 1)\n    rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, segment_length))\n\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swap: exchange two nodes to improve both objectives if possible\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c, node_d = new_solution[c], new_solution[d]\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] + \\\n                    distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]]\n    current_cost2 = distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] + \\\n                    distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate original costs\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[original_prev_c, node_c] + distance_matrix_1[node_c, original_next_c] +\n                      distance_matrix_1[original_prev_d, node_d] + distance_matrix_1[node_d, original_next_d])\n    original_cost2 = (distance_matrix_2[original_prev_c, node_c] + distance_matrix_2[node_c, original_next_c] +\n                      distance_matrix_2[original_prev_d, node_d] + distance_matrix_2[node_d, original_next_d])\n\n    # Calculate new costs after swap\n    new_prev_c = new_solution[d-1]\n    new_next_c = new_solution[d+1] if d+1 < n else new_solution[0]\n    new_prev_d = new_solution[c-1]\n    new_next_d = new_solution[c+1] if c+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[new_prev_c, node_d] + distance_matrix_1[node_d, new_next_c] +\n                 distance_matrix_1[new_prev_d, node_c] + distance_matrix_1[node_c, new_next_d])\n    new_cost2 = (distance_matrix_2[new_prev_c, node_d] + distance_matrix_2[node_d, new_next_c] +\n                 distance_matrix_2[new_prev_d, node_c] + distance_matrix_2[node_c, new_next_d])\n\n    # Accept swap if it improves both objectives or with a small probability\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8824352098755073,
            1.8192631006240845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate original costs\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[original_prev_c, node_c] + distance_matrix_1[node_c, original_next_c] +\n                      distance_matrix_1[original_prev_d, node_d] + distance_matrix_1[node_d, original_next_d])\n    original_cost2 = (distance_matrix_2[original_prev_c, node_c] + distance_matrix_2[node_c, original_next_c] +\n                      distance_matrix_2[original_prev_d, node_d] + distance_matrix_2[node_d, original_next_d])\n\n    # Calculate new costs after swap\n    new_prev_c = new_solution[d-1]\n    new_next_c = new_solution[d+1] if d+1 < n else new_solution[0]\n    new_prev_d = new_solution[c-1]\n    new_next_d = new_solution[c+1] if c+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[new_prev_c, node_d] + distance_matrix_1[node_d, new_next_c] +\n                 distance_matrix_1[new_prev_d, node_c] + distance_matrix_1[node_c, new_next_d])\n    new_cost2 = (distance_matrix_2[new_prev_c, node_d] + distance_matrix_2[node_d, new_next_c] +\n                 distance_matrix_2[new_prev_d, node_c] + distance_matrix_2[node_c, new_next_d])\n\n    # Accept swap if it improves both objectives or with a small probability\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swapping that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    original_cost1 = distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] + \\\n                     distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]]\n    original_cost2 = distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]]\n\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    new_cost1 = distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]]\n\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6458495211002082,
            2.082292377948761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    original_cost1 = distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] + \\\n                     distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]]\n    original_cost2 = distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]]\n\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    new_cost1 = distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]]\n\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective Pareto dominance criterion, then applies a hybrid local search combining a novel segment inversion with a Pareto-aware edge exchange that explores the solution space by strategically inverting segments and exchanging edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best Pareto front dominance\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with Pareto-aware edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge exchange: swap two edges if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1, node2 = new_solution[c], new_solution[d]\n\n    original_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] + \\\n                     distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]]\n    original_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]]\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8620621809937862,
            1.3865981101989746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best Pareto front dominance\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with Pareto-aware edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge exchange: swap two edges if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1, node2 = new_solution[c], new_solution[d]\n\n    original_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] + \\\n                     distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]]\n    original_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]]\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This algorithm selects a solution with the lowest combined objective value from the archive, then applies a novel local search combining a 3-opt-like move with a segment rotation to explore diverse improvements while maintaining feasibility, ensuring balanced progress across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt-like move with segment rotation\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform a 3-opt-like move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Rotate a segment to balance objectives\n    rot_pos = np.random.randint(1, n-2)\n    rot_length = np.random.randint(2, min(4, n-rot_pos))\n    rot_segment = new_solution[rot_pos:rot_pos+rot_length]\n    rotated = np.roll(rot_segment, np.random.randint(1, rot_length))\n    new_solution[rot_pos:rot_pos+rot_length] = rotated\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9353565319022376,
            1.4052726030349731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 3-opt-like move with segment rotation\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform a 3-opt-like move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Rotate a segment to balance objectives\n    rot_pos = np.random.randint(1, n-2)\n    rot_length = np.random.randint(2, min(4, n-rot_pos))\n    rot_segment = new_solution[rot_pos:rot_pos+rot_length]\n    rotated = np.roll(rot_segment, np.random.randint(1, rot_length))\n    new_solution[rot_pos:rot_pos+rot_length] = rotated\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swapping to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Multi-objective node swapping: swap two nodes that improve both objectives if possible\n    if n > 2:\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n        current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                         distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                         distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                     distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                     distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.827327914480004,
            1.4519861340522766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Multi-objective node swapping: swap two nodes that improve both objectives if possible\n    if n > 2:\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n        current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                         distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                         distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                     distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                     distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a novel hybrid local search that combines adaptive segment merging with biased edge reinsertion, guided by the relative strengths of each objective, while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on both objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n    diversity_scores = np.sum(diversity, axis=1)\n    selection_probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment merging\n    segment_size = max(2, min(5, n // 4))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    segment = new_solution[a:b]\n\n    # Merge with another segment\n    c = np.random.randint(1, n - segment_size)\n    d = c + segment_size\n    new_segment = np.concatenate([segment, new_solution[c:d]])\n    np.random.shuffle(new_segment)\n\n    # Insert merged segment\n    e = np.random.randint(1, n - 1)\n    new_solution = np.concatenate([new_solution[:e], new_segment, new_solution[e:]])\n\n    # Biased edge reinsertion based on objective dominance\n    for i in range(1, n-1):\n        if np.random.rand() < 0.6:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.7) or (cost2 < cost1 and np.random.rand() < 0.3):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a hybrid local search combining adaptive segment reversal with objective-biased edge swapping, ensuring feasibility through comprehensive validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])\n    scores = np.sum(normalized * weights, axis=1)\n    selection_probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal\n    segment_size = max(2, min(4, n // 3))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    reversed_segment = new_solution[a:b][::-1]\n    new_solution[a:b] = reversed_segment\n\n    # Objective-biased edge swapping\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.4) or (cost2 < cost1 and np.random.rand() < 0.6):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7711223367681421,
            1.6097205877304077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])\n    scores = np.sum(normalized * weights, axis=1)\n    selection_probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal\n    segment_size = max(2, min(4, n // 3))\n    a = np.random.randint(1, n - segment_size)\n    b = a + segment_size\n    reversed_segment = new_solution[a:b][::-1]\n    new_solution[a:b] = reversed_segment\n\n    # Objective-biased edge swapping\n    for i in range(1, n-1):\n        if np.random.rand() < 0.5:\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]]\n            if (cost1 < cost2 and np.random.rand() < 0.4) or (cost2 < cost1 and np.random.rand() < 0.6):\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(unique_nodes) - set(range(n))\n        for m in missing:\n            for e in extra:\n                if e not in selected_solution[:n]:\n                    idx = np.where(new_solution == e)[0][0]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)\n    selected_solution = archive_sorted[min(len(archive_sorted) // 3, len(archive_sorted) - 1)][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Multi-objective node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if c != d:\n        node_c = new_solution[c]\n        node_d = new_solution[d]\n\n        prev_c = new_solution[c-1]\n        next_c = new_solution[(c+1) % n]\n        prev_d = new_solution[d-1]\n        next_d = new_solution[(d+1) % n]\n\n        original_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                          distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n        original_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                          distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n        new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                    distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n        new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                    distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6834064709749215,
            1.6556441187858582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)\n    selected_solution = archive_sorted[min(len(archive_sorted) // 3, len(archive_sorted) - 1)][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Multi-objective node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if c != d:\n        node_c = new_solution[c]\n        node_d = new_solution[d]\n\n        prev_c = new_solution[c-1]\n        next_c = new_solution[(c+1) % n]\n        prev_d = new_solution[d-1]\n        next_d = new_solution[(d+1) % n]\n\n        original_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                          distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n        original_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                          distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n        new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                    distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n        new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                    distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node exchange that explores the solution space by cyclically rotating segments and exchanging nodes in a way that balances improvements across both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective combination\n    weights = [0.6, 0.4]  # Weight for each objective\n    archive_sorted = sorted(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment by random amount\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node exchange: swap nodes between segments if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    d = np.random.choice(range(1, n-1))\n\n    if c != d:\n        # Calculate original costs\n        orig_prev_c = new_solution[c-1]\n        orig_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n        orig_cost_c1 = distance_matrix_1[orig_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], orig_next_c]\n        orig_cost_c2 = distance_matrix_2[orig_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], orig_next_c]\n\n        orig_prev_d = new_solution[d-1]\n        orig_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n        orig_cost_d1 = distance_matrix_1[orig_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], orig_next_d]\n        orig_cost_d2 = distance_matrix_2[orig_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], orig_next_d]\n\n        # Calculate new costs if swapped\n        new_prev_c = new_solution[d-1]\n        new_next_c = new_solution[d+1] if d+1 < n else new_solution[0]\n        new_cost_c1 = distance_matrix_1[new_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], new_next_c]\n        new_cost_c2 = distance_matrix_2[new_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], new_next_c]\n\n        new_prev_d = new_solution[c-1]\n        new_next_d = new_solution[c+1] if c+1 < n else new_solution[0]\n        new_cost_d1 = distance_matrix_1[new_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], new_next_d]\n        new_cost_d2 = distance_matrix_2[new_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], new_next_d]\n\n        # Check if swap improves both objectives\n        if (new_cost_c1 + new_cost_d1 < orig_cost_c1 + orig_cost_d1 and\n            new_cost_c2 + new_cost_d2 < orig_cost_c2 + orig_cost_d2) or (np.random.random() < 0.1):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7085200093790027,
            1.893548846244812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective combination\n    weights = [0.6, 0.4]  # Weight for each objective\n    archive_sorted = sorted(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate segment by random amount\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node exchange: swap nodes between segments if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    d = np.random.choice(range(1, n-1))\n\n    if c != d:\n        # Calculate original costs\n        orig_prev_c = new_solution[c-1]\n        orig_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n        orig_cost_c1 = distance_matrix_1[orig_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], orig_next_c]\n        orig_cost_c2 = distance_matrix_2[orig_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], orig_next_c]\n\n        orig_prev_d = new_solution[d-1]\n        orig_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n        orig_cost_d1 = distance_matrix_1[orig_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], orig_next_d]\n        orig_cost_d2 = distance_matrix_2[orig_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], orig_next_d]\n\n        # Calculate new costs if swapped\n        new_prev_c = new_solution[d-1]\n        new_next_c = new_solution[d+1] if d+1 < n else new_solution[0]\n        new_cost_c1 = distance_matrix_1[new_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], new_next_c]\n        new_cost_c2 = distance_matrix_2[new_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], new_next_c]\n\n        new_prev_d = new_solution[c-1]\n        new_next_d = new_solution[c+1] if c+1 < n else new_solution[0]\n        new_cost_d1 = distance_matrix_1[new_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], new_next_d]\n        new_cost_d2 = distance_matrix_2[new_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], new_next_d]\n\n        # Check if swap improves both objectives\n        if (new_cost_c1 + new_cost_d1 < orig_cost_c1 + orig_cost_d1 and\n            new_cost_c2 + new_cost_d2 < orig_cost_c2 + orig_cost_d2) or (np.random.random() < 0.1):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = (distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1] if c+1 < n else new_solution[0]] +\n                      distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1] if d+1 < n else new_solution[0]])\n    original_cost2 = (distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1] if c+1 < n else new_solution[0]] +\n                      distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1] if d+1 < n else new_solution[0]])\n\n    new_cost1 = (distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1] if c+1 < n else new_solution[0]] +\n                 distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1] if d+1 < n else new_solution[0]])\n    new_cost2 = (distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1] if c+1 < n else new_solution[0]] +\n                 distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1] if d+1 < n else new_solution[0]])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8107765489509686,
            1.5594514608383179
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = (distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1] if c+1 < n else new_solution[0]] +\n                      distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1] if d+1 < n else new_solution[0]])\n    original_cost2 = (distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1] if c+1 < n else new_solution[0]] +\n                      distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1] if d+1 < n else new_solution[0]])\n\n    new_cost1 = (distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1] if c+1 < n else new_solution[0]] +\n                 distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1] if d+1 < n else new_solution[0]])\n    new_cost2 = (distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1] if c+1 < n else new_solution[0]] +\n                 distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1] if d+1 < n else new_solution[0]])\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution with the highest crowding distance in the objective space from the archive, then applies a novel local search combining node reinsertion with a segment reversal, using adaptive segment lengths based on the solution's objective values to balance improvements across both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance\n    def crowding_distance(solutions):\n        objectives = [obj for _, obj in solutions]\n        obj1 = [o[0] for o in objectives]\n        obj2 = [o[1] for o in objectives]\n        sorted_indices1 = np.argsort(obj1)\n        sorted_indices2 = np.argsort(obj2)\n        crowding = np.zeros(len(solutions))\n        for i in range(1, len(solutions)-1):\n            crowding[i] += (obj1[sorted_indices1[i+1]] - obj1[sorted_indices1[i-1]]) / (max(obj1) - min(obj1) + 1e-10)\n            crowding[i] += (obj2[sorted_indices2[i+1]] - obj2[sorted_indices2[i-1]]) / (max(obj2) - min(obj2) + 1e-10)\n        return crowding\n\n    crowding = crowding_distance(archive)\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with adaptive parameters\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Adaptive segment length based on objective values\n    obj1, obj2 = archive[selected_idx][1]\n    segment_length = max(2, int((obj1 + obj2) / (2 * max(obj1, obj2, 1e-10)) * n))\n    segment_length = min(segment_length, n-2)\n\n    k = np.random.randint(1, n-segment_length)\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9118613327755254,
            4.764686763286591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance\n    def crowding_distance(solutions):\n        objectives = [obj for _, obj in solutions]\n        obj1 = [o[0] for o in objectives]\n        obj2 = [o[1] for o in objectives]\n        sorted_indices1 = np.argsort(obj1)\n        sorted_indices2 = np.argsort(obj2)\n        crowding = np.zeros(len(solutions))\n        for i in range(1, len(solutions)-1):\n            crowding[i] += (obj1[sorted_indices1[i+1]] - obj1[sorted_indices1[i-1]]) / (max(obj1) - min(obj1) + 1e-10)\n            crowding[i] += (obj2[sorted_indices2[i+1]] - obj2[sorted_indices2[i-1]]) / (max(obj2) - min(obj2) + 1e-10)\n        return crowding\n\n    crowding = crowding_distance(archive)\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with adaptive parameters\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Adaptive segment length based on objective values\n    obj1, obj2 = archive[selected_idx][1]\n    segment_length = max(2, int((obj1 + obj2) / (2 * max(obj1, obj2, 1e-10)) * n))\n    segment_length = min(segment_length, n-2)\n\n    k = np.random.randint(1, n-segment_length)\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swapping to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    selected_solution = archive_sorted[len(archive_sorted) // 4][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if np.random.random() < 0.3:\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        prev_i, next_i = new_solution[i-1], new_solution[i+1]\n        prev_j, next_j = new_solution[j-1], new_solution[j+1]\n\n        original_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n        original_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n        new_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n        new_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7217792227693759,
            1.2915372252464294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)\n    selected_solution = archive_sorted[len(archive_sorted) // 4][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if np.random.random() < 0.3:\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        prev_i, next_i = new_solution[i-1], new_solution[i+1]\n        prev_j, next_j = new_solution[j-1], new_solution[j+1]\n\n        original_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n        original_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n        new_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n        new_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node swap that explores the solution space by strategically rotating segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    original_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n    original_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n    new_prev_i = prev_i if i != j-1 else node_j\n    new_next_i = node_j if i+1 == j else next_i\n    new_prev_j = node_i if j-1 == i else prev_j\n    new_next_j = next_j if j+1 != i else node_i\n\n    new_cost1 = distance_matrix_1[new_prev_i, node_i] + distance_matrix_1[node_i, new_next_i] + distance_matrix_1[new_prev_j, node_j] + distance_matrix_1[node_j, new_next_j]\n    new_cost2 = distance_matrix_2[new_prev_i, node_i] + distance_matrix_2[node_i, new_next_i] + distance_matrix_2[new_prev_j, node_j] + distance_matrix_2[node_j, new_next_j]\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7665577104030512,
            1.4098434448242188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    original_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n    original_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n    new_prev_i = prev_i if i != j-1 else node_j\n    new_next_i = node_j if i+1 == j else next_i\n    new_prev_j = node_i if j-1 == i else prev_j\n    new_next_j = next_j if j+1 != i else node_i\n\n    new_cost1 = distance_matrix_1[new_prev_i, node_i] + distance_matrix_1[node_i, new_next_i] + distance_matrix_1[new_prev_j, node_j] + distance_matrix_1[node_j, new_next_j]\n    new_cost2 = distance_matrix_2[new_prev_i, node_i] + distance_matrix_2[node_i, new_next_i] + distance_matrix_2[new_prev_j, node_j] + distance_matrix_2[node_j, new_next_j]\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Calculate original costs\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[original_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], original_next_c] +\n                      distance_matrix_1[original_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], original_next_d])\n    original_cost2 = (distance_matrix_2[original_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], original_next_c] +\n                      distance_matrix_2[original_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], original_next_d])\n\n    # Swap nodes\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Calculate new costs\n    new_prev_c = new_solution[c-1]\n    new_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    new_prev_d = new_solution[d-1]\n    new_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[new_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], new_next_c] +\n                  distance_matrix_1[new_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], new_next_d])\n    new_cost2 = (distance_matrix_2[new_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], new_next_c] +\n                  distance_matrix_2[new_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], new_next_d])\n\n    # Revert if not improving both objectives\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7278675841073021,
            1.7938215136528015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Calculate original costs\n    original_prev_c = new_solution[c-1]\n    original_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    original_prev_d = new_solution[d-1]\n    original_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[original_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], original_next_c] +\n                      distance_matrix_1[original_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], original_next_d])\n    original_cost2 = (distance_matrix_2[original_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], original_next_c] +\n                      distance_matrix_2[original_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], original_next_d])\n\n    # Swap nodes\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Calculate new costs\n    new_prev_c = new_solution[c-1]\n    new_next_c = new_solution[c+1] if c+1 < n else new_solution[0]\n    new_prev_d = new_solution[d-1]\n    new_next_d = new_solution[d+1] if d+1 < n else new_solution[0]\n\n    new_cost1 = (distance_matrix_1[new_prev_c, new_solution[c]] + distance_matrix_1[new_solution[c], new_next_c] +\n                  distance_matrix_1[new_prev_d, new_solution[d]] + distance_matrix_1[new_solution[d], new_next_d])\n    new_cost2 = (distance_matrix_2[new_prev_c, new_solution[c]] + distance_matrix_2[new_solution[c], new_next_c] +\n                  distance_matrix_2[new_prev_d, new_solution[d]] + distance_matrix_2[new_solution[d], new_next_d])\n\n    # Revert if not improving both objectives\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining a novel segment cross-exchange with a multi-objective-aware node swap that explores the solution space by strategically exchanging segments and swapping nodes in a way that balances improvement across both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance between objectives and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment cross-exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    if len(segment1) != len(segment2):\n        # Ensure segments are of same length for cross-exchange\n        min_len = min(len(segment1), len(segment2))\n        segment1 = segment1[:min_len]\n        segment2 = segment2[:min_len]\n        b = a + min_len - 1\n        d = c + min_len - 1\n\n    # Cross the segments\n    new_solution[a:b+1] = segment2\n    new_solution[c:d+1] = segment1\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n\n    original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n    original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                distance_matrix_1[new_solution[i], new_solution[j+1]])\n\n    new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7287367621622063,
            2.645292282104492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance between objectives and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment cross-exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    if len(segment1) != len(segment2):\n        # Ensure segments are of same length for cross-exchange\n        min_len = min(len(segment1), len(segment2))\n        segment1 = segment1[:min_len]\n        segment2 = segment2[:min_len]\n        b = a + min_len - 1\n        d = c + min_len - 1\n\n    # Cross the segments\n    new_solution[a:b+1] = segment2\n    new_solution[c:d+1] = segment1\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n\n    original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n    original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                distance_matrix_1[new_solution[i], new_solution[j+1]])\n\n    new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment shuffle with a multi-objective-aware edge swap that explores the solution space by strategically reordering segments and swapping edges while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment shuffle\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Multi-objective edge swap\n    i = np.random.choice(range(1, n-1))\n    j = np.random.choice(range(1, n-1))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check if swap improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost1 += distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost1 += distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 += distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 += distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6759310841466099,
            1.9346770644187927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment shuffle\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Multi-objective edge swap\n    i = np.random.choice(range(1, n-1))\n    j = np.random.choice(range(1, n-1))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check if swap improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost1 += distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost1 += distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 += distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 += distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0068891280727752,
            0.7655899524688721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0068891280727752,
            0.7655899524688721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance, then applies a novel hybrid local search combining a multi-objective-aware segment inversion with a probabilistic node swap to explore the solution space while balancing improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Multi-objective segment inversion with probabilistic node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] if it improves both objectives\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate original and inverted costs\n    prev_node = new_solution[a-1]\n    next_node = new_solution[b+1] if b+1 < n else new_solution[0]\n\n    original_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n    original_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n    inverted_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n    inverted_cost2 = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n    if (inverted_cost1 <= original_cost1 and inverted_cost2 <= original_cost2) or (np.random.random() < 0.3):\n        new_solution[a:b+1] = inverted_segment\n\n    # Probabilistic node swap to further improve objectives\n    c, d = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate swap costs\n    prev_c = new_solution[c-1]\n    next_c = new_solution[(c+1) % n]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[(d+1) % n]\n\n    original_links1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                       distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n    swapped_links1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                      distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n\n    original_links2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                       distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n    swapped_links2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                     distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n    if (swapped_links1 <= original_links1 and swapped_links2 <= original_links2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5889794190698179,
            2.196265697479248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Multi-objective segment inversion with probabilistic node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b] if it improves both objectives\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate original and inverted costs\n    prev_node = new_solution[a-1]\n    next_node = new_solution[b+1] if b+1 < n else new_solution[0]\n\n    original_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n    original_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n    inverted_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n    inverted_cost2 = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n    if (inverted_cost1 <= original_cost1 and inverted_cost2 <= original_cost2) or (np.random.random() < 0.3):\n        new_solution[a:b+1] = inverted_segment\n\n    # Probabilistic node swap to further improve objectives\n    c, d = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    # Calculate swap costs\n    prev_c = new_solution[c-1]\n    next_c = new_solution[(c+1) % n]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[(d+1) % n]\n\n    original_links1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                       distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n    swapped_links1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                      distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n\n    original_links2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                       distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n    swapped_links2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                     distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n    if (swapped_links1 <= original_links1 and swapped_links2 <= original_links2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid local search combining a novel segment shuffle with a multi-objective-aware node exchange that explores the solution space by randomly shuffling segments and exchanging nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shuffle with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Shuffle the segment\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node exchange: swap two nodes if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                      distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n    original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                      distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n    # Calculate new costs if swapped\n    new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n    new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n    # Apply swap if beneficial\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4689296958615188,
            2.005059242248535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shuffle with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Shuffle the segment\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node exchange: swap two nodes if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                      distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n    original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                      distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n    # Calculate new costs if swapped\n    new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n    new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n    # Apply swap if beneficial\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining edge swapping with a segment inversion to improve both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Edge swapping with segment inversion\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform edge swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Invert a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining a multi-segment inversion with a node displacement to create diverse neighborhoods while balancing improvements across both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(2, 4)\n    for _ in range(num_segments):\n        k = np.random.randint(1, n-2)\n        segment_length = np.random.randint(2, min(6, n-k))\n        new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Node displacement\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9058043019306656,
            1.7799389958381653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(2, 4)\n    for _ in range(num_segments):\n        k = np.random.randint(1, n-2)\n        segment_length = np.random.randint(2, min(6, n-k))\n        new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Node displacement\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted sum of objectives\n    archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_move = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_move] + distance_matrix_1[node_to_move, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_move] + distance_matrix_2[node_to_move, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_move] + distance_matrix_1[node_to_move, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_move] + distance_matrix_2[node_to_move, new_next]\n\n        # Compare costs with some randomness\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_move], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5449153704581565,
            0.6073781251907349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted sum of objectives\n    archive_sorted = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_move = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_move] + distance_matrix_1[node_to_move, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_move] + distance_matrix_2[node_to_move, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_move] + distance_matrix_1[node_to_move, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_move] + distance_matrix_2[node_to_move, new_next]\n\n        # Compare costs with some randomness\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_move], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9364848042029965,
            0.5580185055732727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node exchange that explores the solution space by strategically inverting segments and exchanging nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node exchange: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] + \\\n                     distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]]\n    original_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]]\n\n    swapped_cost1 = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] + \\\n                    distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]]\n    swapped_cost2 = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] + \\\n                   distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]]\n\n    # Compare costs\n    if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9532889044414291,
            2.1969563364982605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node exchange: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] + \\\n                     distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]]\n    original_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]]\n\n    swapped_cost1 = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] + \\\n                    distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]]\n    swapped_cost2 = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] + \\\n                   distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]]\n\n    # Compare costs\n    if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This new algorithm selects solutions based on their normalized objective values, then applies a hybrid local search combining segment reversal with a multi-objective-aware edge swap that explores the solution space by reversing segments and swapping edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective trade-off\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Edge swap: swap two edges if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if c != d:\n        # Calculate original costs\n        orig_cost1 = (distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                      distance_matrix_1[new_solution[d-1], new_solution[d]])\n        orig_cost2 = (distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[d-1], new_solution[d]])\n\n        # Calculate swapped costs\n        swap_cost1 = (distance_matrix_1[new_solution[c-1], new_solution[d]] +\n                      distance_matrix_1[new_solution[d-1], new_solution[c]])\n        swap_cost2 = (distance_matrix_2[new_solution[c-1], new_solution[d]] +\n                      distance_matrix_2[new_solution[d-1], new_solution[c]])\n\n        if (swap_cost1 < orig_cost1 and swap_cost2 < orig_cost2) or (np.random.random() < 0.1):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5582163822951505,
            1.2586495876312256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective trade-off\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Edge swap: swap two edges if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if c != d:\n        # Calculate original costs\n        orig_cost1 = (distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                      distance_matrix_1[new_solution[d-1], new_solution[d]])\n        orig_cost2 = (distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[d-1], new_solution[d]])\n\n        # Calculate swapped costs\n        swap_cost1 = (distance_matrix_1[new_solution[c-1], new_solution[d]] +\n                      distance_matrix_1[new_solution[d-1], new_solution[c]])\n        swap_cost2 = (distance_matrix_2[new_solution[c-1], new_solution[d]] +\n                      distance_matrix_2[new_solution[d-1], new_solution[c]])\n\n        if (swap_cost1 < orig_cost1 and swap_cost2 < orig_cost2) or (np.random.random() < 0.1):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Multi-objective node swap: find a swap that improves both objectives if possible\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1]\n\n            # Current costs\n            current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n            current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # Swapped costs\n            new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                        distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n            new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                        distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9212178804236086,
            2.4474578499794006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b]\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Multi-objective node swap: find a swap that improves both objectives if possible\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1]\n\n            # Current costs\n            current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n            current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # Swapped costs\n            new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                        distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n            new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                        distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel node swapping with a multi-objective-aware segment insertion, which strategically swaps nodes between segments and inserts them in positions that improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Node swapping between segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap nodes between segments\n    temp = new_solution[a]\n    new_solution[a] = new_solution[c]\n    new_solution[c] = temp\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    segment_length = np.random.randint(2, min(5, n // 2))\n    start = np.random.randint(1, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    for pos in range(1, n - segment_length + 1):\n        if pos == start:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[start-1]\n        original_next = new_solution[start+segment_length]\n        original_cost1 = distance_matrix_1[original_prev, segment[0]] + distance_matrix_1[segment[-1], original_next]\n        original_cost2 = distance_matrix_2[original_prev, segment[0]] + distance_matrix_2[segment[-1], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, segment[0]] + distance_matrix_1[segment[-1], new_next]\n        new_cost2 = distance_matrix_2[new_prev, segment[0]] + distance_matrix_2[segment[-1], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:pos], segment, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6253658130204741,
            0.6025123000144958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Node swapping between segments\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap nodes between segments\n    temp = new_solution[a]\n    new_solution[a] = new_solution[c]\n    new_solution[c] = temp\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    segment_length = np.random.randint(2, min(5, n // 2))\n    start = np.random.randint(1, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    for pos in range(1, n - segment_length + 1):\n        if pos == start:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[start-1]\n        original_next = new_solution[start+segment_length]\n        original_cost1 = distance_matrix_1[original_prev, segment[0]] + distance_matrix_1[segment[-1], original_next]\n        original_cost2 = distance_matrix_2[original_prev, segment[0]] + distance_matrix_2[segment[-1], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, segment[0]] + distance_matrix_1[segment[-1], new_next]\n        new_cost2 = distance_matrix_2[new_prev, segment[0]] + distance_matrix_2[segment[-1], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:pos], segment, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge exchange that explores the solution space by strategically inverting segments and exchanging edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective (0.6 for first objective, 0.4 for second)\n    archive_sorted = sorted(archive, key=lambda x: 0.6*x[1][0] + 0.4*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Edge exchange: swap two edges if it improves both objectives\n    for _ in range(3):\n        c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if c == d:\n            continue\n\n        # Current edges: (c-1, c), (c, c+1), (d-1, d), (d, d+1)\n        # New edges: (c-1, d), (d, c+1), (d-1, c), (c, d+1)\n        original_cost1 = (distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                          distance_matrix_1[new_solution[c], new_solution[c+1]] +\n                          distance_matrix_1[new_solution[d-1], new_solution[d]] +\n                          distance_matrix_1[new_solution[d], new_solution[d+1]])\n        original_cost2 = (distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                          distance_matrix_2[new_solution[c], new_solution[c+1]] +\n                          distance_matrix_2[new_solution[d-1], new_solution[d]] +\n                          distance_matrix_2[new_solution[d], new_solution[d+1]])\n\n        new_cost1 = (distance_matrix_1[new_solution[c-1], new_solution[d]] +\n                    distance_matrix_1[new_solution[d], new_solution[c+1]] +\n                    distance_matrix_1[new_solution[d-1], new_solution[c]] +\n                    distance_matrix_1[new_solution[c], new_solution[d+1]])\n        new_cost2 = (distance_matrix_2[new_solution[c-1], new_solution[d]] +\n                    distance_matrix_2[new_solution[d], new_solution[c+1]] +\n                    distance_matrix_2[new_solution[d-1], new_solution[c]] +\n                    distance_matrix_2[new_solution[c], new_solution[d+1]])\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n            # Perform the edge exchange\n            temp = new_solution[c]\n            new_solution[c] = new_solution[d]\n            new_solution[d] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6357192703910495,
            2.0651451349258423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective (0.6 for first objective, 0.4 for second)\n    archive_sorted = sorted(archive, key=lambda x: 0.6*x[1][0] + 0.4*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Edge exchange: swap two edges if it improves both objectives\n    for _ in range(3):\n        c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if c == d:\n            continue\n\n        # Current edges: (c-1, c), (c, c+1), (d-1, d), (d, d+1)\n        # New edges: (c-1, d), (d, c+1), (d-1, c), (c, d+1)\n        original_cost1 = (distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                          distance_matrix_1[new_solution[c], new_solution[c+1]] +\n                          distance_matrix_1[new_solution[d-1], new_solution[d]] +\n                          distance_matrix_1[new_solution[d], new_solution[d+1]])\n        original_cost2 = (distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                          distance_matrix_2[new_solution[c], new_solution[c+1]] +\n                          distance_matrix_2[new_solution[d-1], new_solution[d]] +\n                          distance_matrix_2[new_solution[d], new_solution[d+1]])\n\n        new_cost1 = (distance_matrix_1[new_solution[c-1], new_solution[d]] +\n                    distance_matrix_1[new_solution[d], new_solution[c+1]] +\n                    distance_matrix_1[new_solution[d-1], new_solution[c]] +\n                    distance_matrix_1[new_solution[c], new_solution[d+1]])\n        new_cost2 = (distance_matrix_2[new_solution[c-1], new_solution[d]] +\n                    distance_matrix_2[new_solution[d], new_solution[c+1]] +\n                    distance_matrix_2[new_solution[d-1], new_solution[c]] +\n                    distance_matrix_2[new_solution[c], new_solution[d+1]])\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n            # Perform the edge exchange\n            temp = new_solution[c]\n            new_solution[c] = new_solution[d]\n            new_solution[d] = temp\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This new algorithm selects a non-dominated solution from the archive based on a crowding distance metric, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware 2.5-opt move to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for exploration)\n    def calculate_crowding_distance(solutions):\n        if len(solutions) <= 2:\n            return [1.0 for _ in solutions]\n        sorted_solutions = sorted(solutions, key=lambda x: x[1][0])\n        crowding_distances = [0.0] * len(solutions)\n        for i in range(2):\n            sorted_solutions = sorted(solutions, key=lambda x: x[1][i])\n            crowding_distances[0] = crowding_distances[-1] = float('inf')\n            for j in range(1, len(solutions)-1):\n                crowding_distances[j] += (sorted_solutions[j+1][1][i] - sorted_solutions[j-1][1][i])\n        return crowding_distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 6:\n        return new_solution\n\n    # Hybrid local search: segment inversion with 2.5-opt move\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 2.5-opt move: reorder segment [b:c] to minimize both objectives\n    segment = new_solution[b:c+1]\n    segment_costs = []\n    for i in range(len(segment)):\n        for j in range(i+1, len(segment)):\n            temp_segment = segment.copy()\n            temp_segment[i:j+1] = temp_segment[i:j+1][::-1]\n            cost1 = sum(distance_matrix_1[temp_segment[k-1], temp_segment[k]] for k in range(1, len(temp_segment)))\n            cost2 = sum(distance_matrix_2[temp_segment[k-1], temp_segment[k]] for k in range(1, len(temp_segment)))\n            segment_costs.append((cost1 + cost2, temp_segment))\n\n    if segment_costs:\n        best_segment = min(segment_costs, key=lambda x: x[0])[1]\n        new_solution[b:c+1] = best_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.883127689227645,
            12.27571552991867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for exploration)\n    def calculate_crowding_distance(solutions):\n        if len(solutions) <= 2:\n            return [1.0 for _ in solutions]\n        sorted_solutions = sorted(solutions, key=lambda x: x[1][0])\n        crowding_distances = [0.0] * len(solutions)\n        for i in range(2):\n            sorted_solutions = sorted(solutions, key=lambda x: x[1][i])\n            crowding_distances[0] = crowding_distances[-1] = float('inf')\n            for j in range(1, len(solutions)-1):\n                crowding_distances[j] += (sorted_solutions[j+1][1][i] - sorted_solutions[j-1][1][i])\n        return crowding_distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 6:\n        return new_solution\n\n    # Hybrid local search: segment inversion with 2.5-opt move\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # 2.5-opt move: reorder segment [b:c] to minimize both objectives\n    segment = new_solution[b:c+1]\n    segment_costs = []\n    for i in range(len(segment)):\n        for j in range(i+1, len(segment)):\n            temp_segment = segment.copy()\n            temp_segment[i:j+1] = temp_segment[i:j+1][::-1]\n            cost1 = sum(distance_matrix_1[temp_segment[k-1], temp_segment[k]] for k in range(1, len(temp_segment)))\n            cost2 = sum(distance_matrix_2[temp_segment[k-1], temp_segment[k]] for k in range(1, len(temp_segment)))\n            segment_costs.append((cost1 + cost2, temp_segment))\n\n    if segment_costs:\n        best_segment = min(segment_costs, key=lambda x: x[0])[1]\n        new_solution[b:c+1] = best_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment permutation with a multi-objective-aware node swapping that explores the solution space by strategically reordering segments and swapping nodes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node swapping: swap nodes to improve both objectives if possible\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    original_cost1 = (distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] +\n                       distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]])\n    original_cost2 = (distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] +\n                       distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] +\n                 distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]])\n    new_cost2 = (distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] +\n                 distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6394912845355876,
            1.5949386954307556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.5 + x[1][1] * 0.5)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment permutation with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node swapping: swap nodes to improve both objectives if possible\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    original_cost1 = (distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] +\n                       distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]])\n    original_cost2 = (distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] +\n                       distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] +\n                 distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]])\n    new_cost2 = (distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] +\n                 distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)  # Weighted sum with different coefficients\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()  # Select from a different position\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b] and swap nodes at positions c and d\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Multi-objective node swap: swap nodes that improve both objectives if possible\n    if c > 0 and c < n-1 and d > 0 and d < n-1:\n        node1 = new_solution[c]\n        node2 = new_solution[d]\n        prev1 = new_solution[c-1]\n        next1 = new_solution[c+1]\n        prev2 = new_solution[d-1]\n        next2 = new_solution[d+1]\n\n        current_cost1 = distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] + distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2]\n        current_cost2 = distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] + distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2]\n\n        new_cost1 = distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] + distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2]\n        new_cost2 = distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] + distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):  # Different probability threshold\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6958633125411908,
            1.678296148777008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)  # Weighted sum with different coefficients\n    selected_solution = archive_sorted[len(archive_sorted) // 3][0].copy()  # Select from a different position\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Reverse segment [a:b] and swap nodes at positions c and d\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Multi-objective node swap: swap nodes that improve both objectives if possible\n    if c > 0 and c < n-1 and d > 0 and d < n-1:\n        node1 = new_solution[c]\n        node2 = new_solution[d]\n        prev1 = new_solution[c-1]\n        next1 = new_solution[c+1]\n        prev2 = new_solution[d-1]\n        next2 = new_solution[d+1]\n\n        current_cost1 = distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] + distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2]\n        current_cost2 = distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] + distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2]\n\n        new_cost1 = distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] + distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2]\n        new_cost2 = distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] + distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):  # Different probability threshold\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid local search combining a novel segment crossover with a multi-objective-aware node swapping that explores the solution space by strategically exchanging segments between solutions and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment1 = new_solution[a:b+1]\n\n    # Select another solution from archive for crossover\n    other_solution = archive[np.random.randint(len(archive))][0]\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment2 = other_solution[c:d+1]\n\n    # Crossover segments\n    if len(segment1) == len(segment2):\n        crossover_point = np.random.randint(1, len(segment1))\n        new_segment = np.concatenate([segment1[:crossover_point], segment2[crossover_point:]])\n        new_solution[a:b+1] = new_segment\n\n    # Node swapping: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                      distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n    original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                      distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n    # Calculate new costs after swap\n    new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                 distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n    new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                 distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n    # Apply swap if it improves both objectives\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3325397763057467,
            2.566528856754303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment1 = new_solution[a:b+1]\n\n    # Select another solution from archive for crossover\n    other_solution = archive[np.random.randint(len(archive))][0]\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment2 = other_solution[c:d+1]\n\n    # Crossover segments\n    if len(segment1) == len(segment2):\n        crossover_point = np.random.randint(1, len(segment1))\n        new_segment = np.concatenate([segment1[:crossover_point], segment2[crossover_point:]])\n        new_solution[a:b+1] = new_segment\n\n    # Node swapping: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                      distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n    original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                      distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n    # Calculate new costs after swap\n    new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                 distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n    new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                 distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n    # Apply swap if it improves both objectives\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized objective values, then applies a hybrid local search combining a segment inversion with a multi-objective-aware edge exchange that explores the solution space by strategically inverting segments and exchanging edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective values\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / distance_matrix_1.sum()) + (x[1][1] / distance_matrix_2.sum()))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Invert the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Edge exchange: find two edges that can be swapped if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate current costs\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    current_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n    current_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n    # Calculate new costs after swapping\n    new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n    new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n    # Accept if both objectives improve or with small probability\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.05):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6113912219189045,
            2.35190886259079
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective values\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / distance_matrix_1.sum()) + (x[1][1] / distance_matrix_2.sum()))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Invert the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Edge exchange: find two edges that can be swapped if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate current costs\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    current_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n    current_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n    # Calculate new costs after swapping\n    new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n    new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n    # Accept if both objectives improve or with small probability\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.05):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This algorithm selects a solution from the archive based on crowding distance in the objective space to promote diversity, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node swap that explores the solution space by strategically rotating segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (for diversity)\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        sorted_indices = np.argsort([obj[0] for obj in objectives])\n        distances = [0.0] * len(solutions)\n\n        for i in range(2):\n            sorted_indices = np.argsort([obj[i] for obj in objectives])\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = float('inf')\n            for j in range(1, len(solutions)-1):\n                if objectives[sorted_indices[-1]][i] == objectives[sorted_indices[0]][i]:\n                    continue\n                distances[sorted_indices[j]] += (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / (objectives[sorted_indices[-1]][i] - objectives[sorted_indices[0]][i])\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swap: find two nodes that improve both objectives when swapped\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Original costs\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n            original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                             distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n            original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                             distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # Swapped costs\n            new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                        distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n            new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                        distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.43616091089258846,
            2.6110535264015198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (for diversity)\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        sorted_indices = np.argsort([obj[0] for obj in objectives])\n        distances = [0.0] * len(solutions)\n\n        for i in range(2):\n            sorted_indices = np.argsort([obj[i] for obj in objectives])\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = float('inf')\n            for j in range(1, len(solutions)-1):\n                if objectives[sorted_indices[-1]][i] == objectives[sorted_indices[0]][i]:\n                    continue\n                distances[sorted_indices[j]] += (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / (objectives[sorted_indices[-1]][i] - objectives[sorted_indices[0]][i])\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swap: find two nodes that improve both objectives when swapped\n    for i in range(1, n-1):\n        for j in range(i+1, n-1):\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Original costs\n            prev_i = new_solution[i-1]\n            next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n            original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                             distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n            original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                             distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # Swapped costs\n            new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                        distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n            new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                        distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (weighted sum)\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    original_prev_i = new_solution[i-1]\n    original_next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    original_cost_i1 = distance_matrix_1[original_prev_i, node_i] + distance_matrix_1[node_i, original_next_i]\n    original_cost_i2 = distance_matrix_2[original_prev_i, node_i] + distance_matrix_2[node_i, original_next_i]\n\n    original_prev_j = new_solution[j-1]\n    original_next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n    original_cost_j1 = distance_matrix_1[original_prev_j, node_j] + distance_matrix_1[node_j, original_next_j]\n    original_cost_j2 = distance_matrix_2[original_prev_j, node_j] + distance_matrix_2[node_j, original_next_j]\n\n    # Calculate new costs after swap\n    new_prev_i = original_prev_j\n    new_next_i = original_next_j\n    new_cost_i1 = distance_matrix_1[new_prev_i, node_i] + distance_matrix_1[node_i, new_next_i]\n    new_cost_i2 = distance_matrix_2[new_prev_i, node_i] + distance_matrix_2[node_i, new_next_i]\n\n    new_prev_j = original_prev_i\n    new_next_j = original_next_i\n    new_cost_j1 = distance_matrix_1[new_prev_j, node_j] + distance_matrix_1[node_j, new_next_j]\n    new_cost_j2 = distance_matrix_2[new_prev_j, node_j] + distance_matrix_2[node_j, new_next_j]\n\n    # Compare costs\n    if ((new_cost_i1 + new_cost_j1) < (original_cost_i1 + original_cost_j1) and\n        (new_cost_i2 + new_cost_j2) < (original_cost_i2 + original_cost_j2)) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6874630283328278,
            1.5865602493286133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (weighted sum)\n    archive_sorted = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    original_prev_i = new_solution[i-1]\n    original_next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    original_cost_i1 = distance_matrix_1[original_prev_i, node_i] + distance_matrix_1[node_i, original_next_i]\n    original_cost_i2 = distance_matrix_2[original_prev_i, node_i] + distance_matrix_2[node_i, original_next_i]\n\n    original_prev_j = new_solution[j-1]\n    original_next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n    original_cost_j1 = distance_matrix_1[original_prev_j, node_j] + distance_matrix_1[node_j, original_next_j]\n    original_cost_j2 = distance_matrix_2[original_prev_j, node_j] + distance_matrix_2[node_j, original_next_j]\n\n    # Calculate new costs after swap\n    new_prev_i = original_prev_j\n    new_next_i = original_next_j\n    new_cost_i1 = distance_matrix_1[new_prev_i, node_i] + distance_matrix_1[node_i, new_next_i]\n    new_cost_i2 = distance_matrix_2[new_prev_i, node_i] + distance_matrix_2[node_i, new_next_i]\n\n    new_prev_j = original_prev_i\n    new_next_j = original_next_i\n    new_cost_j1 = distance_matrix_1[new_prev_j, node_j] + distance_matrix_1[node_j, new_next_j]\n    new_cost_j2 = distance_matrix_2[new_prev_j, node_j] + distance_matrix_2[node_j, new_next_j]\n\n    # Compare costs\n    if ((new_cost_i1 + new_cost_j1) < (original_cost_i1 + original_cost_j1) and\n        (new_cost_i2 + new_cost_j2) < (original_cost_i2 + original_cost_j2)) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment crossover with a multi-objective-aware node swapping that explores the solution space by strategically crossing over segments from other solutions and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swapping\n    # Select a random segment from another solution in the archive\n    other_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform segment crossover\n    segment = other_solution[a:b+1]\n    new_solution[a:b+1] = segment\n\n    # Node swapping: swap nodes between the current and other solution if it improves both objectives\n    for i in range(1, n-1):\n        node_i = new_solution[i]\n        node_j = other_solution[i]\n\n        if node_i == node_j:\n            continue\n\n        # Calculate costs for the original and swapped positions\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i]\n        original_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i]\n\n        new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i]\n        new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n            # Perform the swap\n            new_solution[i] = node_j\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8928647673786073,
            2.2013657093048096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swapping\n    # Select a random segment from another solution in the archive\n    other_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Perform segment crossover\n    segment = other_solution[a:b+1]\n    new_solution[a:b+1] = segment\n\n    # Node swapping: swap nodes between the current and other solution if it improves both objectives\n    for i in range(1, n-1):\n        node_i = new_solution[i]\n        node_j = other_solution[i]\n\n        if node_i == node_j:\n            continue\n\n        # Calculate costs for the original and swapped positions\n        prev_i = new_solution[i-1]\n        next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i]\n        original_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i]\n\n        new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i]\n        new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n            # Perform the swap\n            new_solution[i] = node_j\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node swapping strategy, which rotates a segment of the tour and then swaps nodes between segments to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swapping between segments\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate potential improvement\n    cost1_before = (distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                   distance_matrix_1[new_solution[c], new_solution[c+1]] +\n                   distance_matrix_1[new_solution[d-1], new_solution[d]] +\n                   distance_matrix_1[new_solution[d], new_solution[d+1]])\n\n    cost2_before = (distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                   distance_matrix_2[new_solution[c], new_solution[c+1]] +\n                   distance_matrix_2[new_solution[d-1], new_solution[d]] +\n                   distance_matrix_2[new_solution[d], new_solution[d+1]])\n\n    cost1_after = (distance_matrix_1[new_solution[c-1], node2] +\n                  distance_matrix_1[node2, new_solution[c+1]] +\n                  distance_matrix_1[new_solution[d-1], node1] +\n                  distance_matrix_1[node1, new_solution[d+1]])\n\n    cost2_after = (distance_matrix_2[new_solution[c-1], node2] +\n                  distance_matrix_2[node2, new_solution[c+1]] +\n                  distance_matrix_2[new_solution[d-1], node1] +\n                  distance_matrix_2[node1, new_solution[d+1]])\n\n    if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.41033591744082804,
            2.2244953513145447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swapping between segments\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate potential improvement\n    cost1_before = (distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                   distance_matrix_1[new_solution[c], new_solution[c+1]] +\n                   distance_matrix_1[new_solution[d-1], new_solution[d]] +\n                   distance_matrix_1[new_solution[d], new_solution[d+1]])\n\n    cost2_before = (distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                   distance_matrix_2[new_solution[c], new_solution[c+1]] +\n                   distance_matrix_2[new_solution[d-1], new_solution[d]] +\n                   distance_matrix_2[new_solution[d], new_solution[d+1]])\n\n    cost1_after = (distance_matrix_1[new_solution[c-1], node2] +\n                  distance_matrix_1[node2, new_solution[c+1]] +\n                  distance_matrix_1[new_solution[d-1], node1] +\n                  distance_matrix_1[node1, new_solution[d+1]])\n\n    cost2_after = (distance_matrix_2[new_solution[c-1], node2] +\n                  distance_matrix_2[node2, new_solution[c+1]] +\n                  distance_matrix_2[new_solution[d-1], node1] +\n                  distance_matrix_2[node1, new_solution[d+1]])\n\n    if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node exchange that explores the solution space by strategically rotating segments and exchanging nodes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with best weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores) if np.random.random() < 0.7 else np.random.randint(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node exchange: swap nodes to improve both objectives if possible\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i, node_j = new_solution[i], new_solution[j]\n\n    # Calculate potential costs\n    cost1_before = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] + \\\n                   distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]]\n    cost2_before = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] + \\\n                   distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]]\n\n    cost1_after = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] + \\\n                 distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]]\n    cost2_after = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] + \\\n                 distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]]\n\n    if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.3):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8089302748153365,
            1.7220537662506104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with best weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores) if np.random.random() < 0.7 else np.random.randint(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node exchange\n    a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node exchange: swap nodes to improve both objectives if possible\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i, node_j = new_solution[i], new_solution[j]\n\n    # Calculate potential costs\n    cost1_before = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] + \\\n                   distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]]\n    cost2_before = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] + \\\n                   distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]]\n\n    cost1_after = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] + \\\n                 distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]]\n    cost2_after = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] + \\\n                 distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]]\n\n    if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.3):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a conditional node swap, which rotates a segment of the tour and swaps nodes between segments if it improves both objectives, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with conditional node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = min(5, b - a + 1)\n    rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, segment_length))\n\n    new_solution[a:b+1] = rotated_segment\n\n    # Conditional node swap between segments\n    c = np.random.choice(range(1, n-1))\n    d = np.random.choice(range(1, n-1))\n\n    if c != d:\n        node_c = new_solution[c]\n        node_d = new_solution[d]\n\n        # Calculate costs before swap\n        cost1_before = (distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] +\n                        distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]])\n        cost2_before = (distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] +\n                        distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]])\n\n        # Calculate costs after swap\n        cost1_after = (distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] +\n                       distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]])\n        cost2_after = (distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] +\n                       distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]])\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6349590815544932,
            1.7262728214263916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with conditional node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = min(5, b - a + 1)\n    rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, segment_length))\n\n    new_solution[a:b+1] = rotated_segment\n\n    # Conditional node swap between segments\n    c = np.random.choice(range(1, n-1))\n    d = np.random.choice(range(1, n-1))\n\n    if c != d:\n        node_c = new_solution[c]\n        node_d = new_solution[d]\n\n        # Calculate costs before swap\n        cost1_before = (distance_matrix_1[new_solution[c-1], node_c] + distance_matrix_1[node_c, new_solution[c+1]] +\n                        distance_matrix_1[new_solution[d-1], node_d] + distance_matrix_1[node_d, new_solution[d+1]])\n        cost2_before = (distance_matrix_2[new_solution[c-1], node_c] + distance_matrix_2[node_c, new_solution[c+1]] +\n                        distance_matrix_2[new_solution[d-1], node_d] + distance_matrix_2[node_d, new_solution[d+1]])\n\n        # Calculate costs after swap\n        cost1_after = (distance_matrix_1[new_solution[c-1], node_d] + distance_matrix_1[node_d, new_solution[c+1]] +\n                       distance_matrix_1[new_solution[d-1], node_c] + distance_matrix_1[node_c, new_solution[d+1]])\n        cost2_after = (distance_matrix_2[new_solution[c-1], node_d] + distance_matrix_2[node_d, new_solution[c+1]] +\n                       distance_matrix_2[new_solution[d-1], node_c] + distance_matrix_2[node_c, new_solution[d+1]])\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swapping: swap edges that improve both objectives if possible\n    if c > 0 and c < n-1:\n        node1 = new_solution[c-1]\n        node2 = new_solution[c]\n        node3 = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node2, node3]\n        current_cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node2, node3]\n\n        # Try swapping with a random edge\n        pos = np.random.choice(range(1, n-1))\n        if pos != c and pos != c-1 and pos != c+1:\n            new_node1 = new_solution[pos-1]\n            new_node2 = new_solution[pos]\n            new_cost1 = distance_matrix_1[new_node1, node2] + distance_matrix_1[node2, new_node2]\n            new_cost2 = distance_matrix_2[new_node1, node2] + distance_matrix_2[node2, new_node2]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Perform the swap\n                new_solution[c] = new_solution[pos]\n                new_solution[pos] = node2\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6920307977435943,
            2.370430827140808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge swapping: swap edges that improve both objectives if possible\n    if c > 0 and c < n-1:\n        node1 = new_solution[c-1]\n        node2 = new_solution[c]\n        node3 = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[node1, node2] + distance_matrix_1[node2, node3]\n        current_cost2 = distance_matrix_2[node1, node2] + distance_matrix_2[node2, node3]\n\n        # Try swapping with a random edge\n        pos = np.random.choice(range(1, n-1))\n        if pos != c and pos != c-1 and pos != c+1:\n            new_node1 = new_solution[pos-1]\n            new_node2 = new_solution[pos]\n            new_cost1 = distance_matrix_1[new_node1, node2] + distance_matrix_1[node2, new_node2]\n            new_cost2 = distance_matrix_2[new_node1, node2] + distance_matrix_2[node2, new_node2]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Perform the swap\n                new_solution[c] = new_solution[pos]\n                new_solution[pos] = node2\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swapping that prioritizes improving both objectives simultaneously, while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swapping\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    prev_c = new_solution[c-1]\n    next_c = new_solution[(c+1) % n]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[(d+1) % n]\n\n    current_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                      distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n    current_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                      distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n    new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                 distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n    new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                 distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.25):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3277698019874943,
            2.3322591185569763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective node swapping\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_c = new_solution[c]\n    node_d = new_solution[d]\n\n    prev_c = new_solution[c-1]\n    next_c = new_solution[(c+1) % n]\n    prev_d = new_solution[d-1]\n    next_d = new_solution[(d+1) % n]\n\n    current_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                      distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n    current_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                      distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n    new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                 distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n    new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                 distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.25):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel path reversal with a multi-objective-aware segment insertion that explores the solution space by strategically reversing segments and inserting them at new positions in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8981702684249377,
            0.5261101722717285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-dominance-aware selection criterion, then applies a hybrid local search combining a novel segment insertion with a multi-objective-aware node merging operation that intelligently combines nodes to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good Pareto front potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + 0.1 * (x[1][0] - x[1][1])**2))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment insertion and node merging\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Try inserting the segment elsewhere\n    for pos in range(1, n-1):\n        if pos >= a and pos <= b:\n            continue\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(np.unique(candidate)) == n:\n            new_solution = candidate\n            break\n\n    # Node merging: combine two adjacent nodes if beneficial\n    c = np.random.choice(range(1, n-1))\n    node1, node2 = new_solution[c], new_solution[c+1]\n\n    # Calculate potential improvement\n    cost1 = distance_matrix_1[node1, node2]\n    cost2 = distance_matrix_2[node1, node2]\n\n    # Find best insertion point for merged node\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        # Calculate improvement\n        current_cost1 = distance_matrix_1[prev_node, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_node]\n        current_cost2 = distance_matrix_2[prev_node, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_node]\n\n        new_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, next_node]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 > 0 and improvement2 > 0 and (improvement1 + improvement2) > best_improvement:\n            best_pos = pos\n            best_improvement = improvement1 + improvement2\n\n    if best_pos != -1:\n        # Apply the merge\n        new_solution = np.concatenate([\n            new_solution[:c],\n            new_solution[c+2:best_pos],\n            [node1, node2],\n            new_solution[best_pos:]\n        ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.909857617719912,
            1.309073805809021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good Pareto front potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + 0.1 * (x[1][0] - x[1][1])**2))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment insertion and node merging\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Try inserting the segment elsewhere\n    for pos in range(1, n-1):\n        if pos >= a and pos <= b:\n            continue\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(np.unique(candidate)) == n:\n            new_solution = candidate\n            break\n\n    # Node merging: combine two adjacent nodes if beneficial\n    c = np.random.choice(range(1, n-1))\n    node1, node2 = new_solution[c], new_solution[c+1]\n\n    # Calculate potential improvement\n    cost1 = distance_matrix_1[node1, node2]\n    cost2 = distance_matrix_2[node1, node2]\n\n    # Find best insertion point for merged node\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        # Calculate improvement\n        current_cost1 = distance_matrix_1[prev_node, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_node]\n        current_cost2 = distance_matrix_2[prev_node, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_node]\n\n        new_cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, next_node]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 > 0 and improvement2 > 0 and (improvement1 + improvement2) > best_improvement:\n            best_pos = pos\n            best_improvement = improvement1 + improvement2\n\n    if best_pos != -1:\n        # Apply the merge\n        new_solution = np.concatenate([\n            new_solution[:c],\n            new_solution[c+2:best_pos],\n            [node1, node2],\n            new_solution[best_pos:]\n        ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation, which rotates a segment of the tour and then relocates a node to a position that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: find the best position to relocate a node to improve both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n    best_pos = -1\n    best_improvement = (0, 0)\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 > best_improvement[0] and improvement2 > best_improvement[1]:\n            best_improvement = (improvement1, improvement2)\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:best_pos], [node_to_relocate], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9565474093786699,
            2.404634118080139
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: find the best position to relocate a node to improve both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n    best_pos = -1\n    best_improvement = (0, 0)\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 > best_improvement[0] and improvement2 > best_improvement[1]:\n            best_improvement = (improvement1, improvement2)\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:best_pos], [node_to_relocate], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge exchange that explores the solution space by strategically inverting segments and exchanging edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted sum of normalized objectives\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # More weight on first objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge exchange: swap two edges if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if i+1 != j:\n        # Calculate original costs\n        orig_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                      distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]])\n        orig_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                      distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        # Calculate new costs after exchange\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i+1], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i+1], new_solution[j]])\n\n        if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.15):\n            # Perform edge exchange\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9178856756846456,
            2.324851930141449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted sum of normalized objectives\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # More weight on first objective\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge exchange: swap two edges if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if i+1 != j:\n        # Calculate original costs\n        orig_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                      distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[j]])\n        orig_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                      distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        # Calculate new costs after exchange\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i+1], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i+1], new_solution[j]])\n\n        if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.15):\n            # Perform edge exchange\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel path reversal with a multi-objective-aware segment insertion that explores the solution space by strategically reversing segments and inserting them at new positions in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel path reversal with a multi-objective-aware segment insertion that explores the solution space by strategically reversing segments and inserting them at new positions in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9411647433972302,
            0.7583574056625366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel path reversal with a multi-objective-aware segment insertion that explores the solution space by strategically reversing segments and inserting them at new positions in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel score function that prioritizes solutions with better balance between objectives and higher diversity, then applies a hybrid local search combining a novel path reversal with a multi-objective-aware segment insertion that explores the solution space by strategically reversing segments and inserting them at new positions in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives and higher diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.var(x[0])))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs with a more aggressive improvement threshold\n        if (new_cost1 < original_cost1 * 0.95 and new_cost2 < original_cost2 * 0.95) or (np.random.random() < 0.1):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6706331967389156,
            4.4200966358184814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives and higher diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.var(x[0])))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs with a more aggressive improvement threshold\n        if (new_cost1 < original_cost1 * 0.95 and new_cost2 < original_cost2 * 0.95) or (np.random.random() < 0.1):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment crossover with a multi-objective-aware node exchange that explores the solution space by strategically recombining segments from other high-quality solutions and exchanging nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node exchange\n    # Select a random segment from another high-quality solution in the archive\n    crossover_solution = archive_sorted[min(1, len(archive_sorted)-1)][0].copy()\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = crossover_solution[a:b+1]\n\n    # Node exchange: swap two nodes if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] + \\\n                     distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] + \\\n                     distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] + \\\n                distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] + \\\n                distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]]\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5569277703644594,
            3.1363077759742737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node exchange\n    # Select a random segment from another high-quality solution in the archive\n    crossover_solution = archive_sorted[min(1, len(archive_sorted)-1)][0].copy()\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = crossover_solution[a:b+1]\n\n    # Node exchange: swap two nodes if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] + \\\n                     distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] + \\\n                     distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] + \\\n                distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] + \\\n                distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]]\n\n    # Compare costs\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node duplication and removal strategy, which strategically rotates segments and duplicates nodes to explore the solution space while ensuring feasibility through careful node management.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) - 0.3 * abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation: rotate a segment by a random amount\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = b - a + 1\n    rotation = np.random.randint(1, segment_length)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node duplication and removal: duplicate a random node and try to insert it in a better position\n    c = np.random.choice(range(1, n-1))\n    node_to_duplicate = new_solution[c]\n\n    # Find the best position to insert the duplicate node\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n):\n        if pos == c:\n            continue\n\n        # Calculate the improvement if we insert the duplicate node here\n        if pos > c:\n            # Insert after position pos-1\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n        else:\n            # Insert before position pos\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n        # Calculate the cost difference for both objectives\n        cost_diff1 = (distance_matrix_1[prev_node, node_to_duplicate] + distance_matrix_1[node_to_duplicate, next_node] -\n                      distance_matrix_1[prev_node, next_node])\n        cost_diff2 = (distance_matrix_2[prev_node, node_to_duplicate] + distance_matrix_2[node_to_duplicate, next_node] -\n                      distance_matrix_2[prev_node, next_node])\n\n        # Combine the improvements for both objectives\n        total_improvement = cost_diff1 + cost_diff2\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    # If we found a better position, insert the duplicate node there\n    if best_pos != -1:\n        if best_pos > c:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_duplicate], new_solution[best_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_duplicate], new_solution[best_pos:]])\n\n    # Remove the original node if it doesn't improve the solution too much\n    if np.random.random() < 0.3:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5071490183087348,
            2.954752564430237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) - 0.3 * abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation: rotate a segment by a random amount\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_length = b - a + 1\n    rotation = np.random.randint(1, segment_length)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node duplication and removal: duplicate a random node and try to insert it in a better position\n    c = np.random.choice(range(1, n-1))\n    node_to_duplicate = new_solution[c]\n\n    # Find the best position to insert the duplicate node\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n):\n        if pos == c:\n            continue\n\n        # Calculate the improvement if we insert the duplicate node here\n        if pos > c:\n            # Insert after position pos-1\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n        else:\n            # Insert before position pos\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n        # Calculate the cost difference for both objectives\n        cost_diff1 = (distance_matrix_1[prev_node, node_to_duplicate] + distance_matrix_1[node_to_duplicate, next_node] -\n                      distance_matrix_1[prev_node, next_node])\n        cost_diff2 = (distance_matrix_2[prev_node, node_to_duplicate] + distance_matrix_2[node_to_duplicate, next_node] -\n                      distance_matrix_2[prev_node, next_node])\n\n        # Combine the improvements for both objectives\n        total_improvement = cost_diff1 + cost_diff2\n\n        if total_improvement < best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    # If we found a better position, insert the duplicate node there\n    if best_pos != -1:\n        if best_pos > c:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_duplicate], new_solution[best_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_duplicate], new_solution[best_pos:]])\n\n    # Remove the original node if it doesn't improve the solution too much\n    if np.random.random() < 0.3:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment rotation with a multi-objective-aware edge swap, which rotates a segment of the tour and then swaps adjacent edges in a way that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.3 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap: swap adjacent edges in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-2))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n    node3 = new_solution[c+2]\n\n    # Calculate costs if we swap edges\n    new_cost1 = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, node3] + distance_matrix_1[node3, node1]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, node3] + distance_matrix_2[node3, node1]\n\n    # Compare with current cost\n    current_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, node3]\n    current_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, node3]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        # Perform the edge swap\n        new_solution[c], new_solution[c+1] = new_solution[c+1], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7617147925096456,
            2.409345269203186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.3 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap: swap adjacent edges in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-2))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n    node3 = new_solution[c+2]\n\n    # Calculate costs if we swap edges\n    new_cost1 = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, node3] + distance_matrix_1[node3, node1]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, node3] + distance_matrix_2[node3, node1]\n\n    # Compare with current cost\n    current_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, node3]\n    current_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, node3]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        # Perform the edge swap\n        new_solution[c], new_solution[c+1] = new_solution[c+1], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This new algorithm selects a solution from the archive based on its multi-objective quality, then applies a hybrid local search combining a novel segment crossover with a multi-objective-aware node swapping to explore the solution space by strategically recombining segments and swapping nodes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Segment crossover between [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    if len(segment1) > 0 and len(segment2) > 0:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Node swapping: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9805681270327329,
            0.8754016160964966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Segment crossover between [a:b] and [c:d]\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    if len(segment1) > 0 and len(segment2) > 0:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Node swapping: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] * 0.4 + x[1][1] * 0.6)\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] by one position\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective node insertion: insert node at position c if it improves both objectives\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Try inserting node at a different position\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node relocation to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7426855520982788,
            2.0848292112350464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if c > 0 and c < n-1:\n        node = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        new_pos = np.random.choice(range(1, n-1))\n        if new_pos != c:\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments and swapping edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0227630314708984,
            1.785567283630371
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments and swapping edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0227630314708984,
            1.785567283630371
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel path reversal with a multi-objective-aware segment insertion that explores the solution space by strategically reversing segments and inserting them at new positions in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware edge swap that explores the solution space by rotating segments and swapping edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted balance between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap: swap two edges if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if abs(i - j) > 1:\n        # Calculate costs for original and swapped edges\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j], new_solution[j+1]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7044865178782608,
            2.1341814398765564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted balance between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective edge swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap: swap two edges if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if abs(i - j) > 1:\n        # Calculate costs for original and swapped edges\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j], new_solution[j+1]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            # Perform the swap\n            new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize and compute weighted sum of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    weights = np.array([0.6, 0.4])  # Weighting towards first objective\n    scores = np.sum(normalized * weights, axis=1)\n\n    # Select solution with best score\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, k - a)\n    new_solution[a:b+1] = rotated\n\n    # Node relocation: find best position to improve both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:best_pos], [node_to_relocate], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6373225219704666,
            2.79932177066803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize and compute weighted sum of objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n    weights = np.array([0.6, 0.4])  # Weighting towards first objective\n    scores = np.sum(normalized * weights, axis=1)\n\n    # Select solution with best score\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment = new_solution[a:b+1]\n    rotated = np.roll(segment, k - a)\n    new_solution[a:b+1] = rotated\n\n    # Node relocation: find best position to improve both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:best_pos], [node_to_relocate], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining normalized objective values and solution diversity, then applies a multi-segment inversion with adaptive node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hybrid score (normalized objectives + diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.std(np.diff(sol)) for sol, _ in archive])\n    scores = 0.7 * normalized.mean(axis=1) + 0.3 * (diversity / diversity.max())\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment inversion\n    segments = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    a, b, c = segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Adaptive node swapping\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        if not ((cost1_after < cost1_before and cost2_after < cost2_before) or np.random.random() < 0.2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8545005410030122,
            11.857192397117615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hybrid score (normalized objectives + diversity)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.std(np.diff(sol)) for sol, _ in archive])\n    scores = 0.7 * normalized.mean(axis=1) + 0.3 * (diversity / diversity.max())\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment inversion\n    segments = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    a, b, c = segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Adaptive node swapping\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        if not ((cost1_after < cost1_before and cost2_after < cost2_before) or np.random.random() < 0.2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel path reversal with a multi-objective-aware segment insertion that explores the solution space by strategically reversing segments and inserting them at new positions in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective diversity metric, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that balances improvement across objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance between objectives and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: exchange two nodes if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                      distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n    original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                      distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n    # Calculate new costs after swap\n    new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                 distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n    new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                 distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n    # Accept swap if both objectives improve or with small probability\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8767628742501854,
            2.075075089931488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance between objectives and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Node swap: exchange two nodes if it improves both objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    prev_i = new_solution[i-1]\n    next_i = new_solution[i+1] if i+1 < n else new_solution[0]\n    prev_j = new_solution[j-1]\n    next_j = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    original_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                      distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n    original_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                      distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n    # Calculate new costs after swap\n    new_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                 distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n    new_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                 distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n    # Accept swap if both objectives improve or with small probability\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This new algorithm selects a solution from the archive based on its proximity to the knee point of the Pareto front, then applies a novel local search combining a segment inversion with a multi-objective-aware edge exchange that explores the solution space by strategically inverting segments and exchanging edges in a way that improves the trade-off between objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution closest to the knee point of the Pareto front\n    def knee_point(objectives):\n        objectives = np.array(objectives)\n        if len(objectives) <= 2:\n            return objectives[0]\n        distances = np.array([np.linalg.norm(objectives[i] - objectives[i-1]) for i in range(1, len(objectives))])\n        knee_idx = np.argmax(distances)\n        return objectives[knee_idx]\n\n    objectives = [obj for _, obj in archive]\n    knee = knee_point(objectives)\n    selected_solution = min(archive, key=lambda x: np.linalg.norm(np.array(x[1]) - knee))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Invert the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Edge exchange: swap two edges if it improves the trade-off between objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i_prev = new_solution[i-1]\n    node_i = new_solution[i]\n    node_j_prev = new_solution[j-1]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    original_cost1 = (distance_matrix_1[node_i_prev, node_i] + distance_matrix_1[node_j_prev, node_j])\n    original_cost2 = (distance_matrix_2[node_i_prev, node_i] + distance_matrix_2[node_j_prev, node_j])\n\n    # Calculate new costs after swapping edges\n    new_cost1 = (distance_matrix_1[node_i_prev, node_j] + distance_matrix_1[node_j_prev, node_i])\n    new_cost2 = (distance_matrix_2[node_i_prev, node_j] + distance_matrix_2[node_j_prev, node_i])\n\n    # Compare trade-off between objectives\n    original_tradeoff = original_cost1 / original_cost2 if original_cost2 != 0 else float('inf')\n    new_tradeoff = new_cost1 / new_cost2 if new_cost2 != 0 else float('inf')\n\n    if new_tradeoff < original_tradeoff or np.random.random() < 0.1:\n        # Perform the edge swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.48874499893737366,
            3.4403892159461975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution closest to the knee point of the Pareto front\n    def knee_point(objectives):\n        objectives = np.array(objectives)\n        if len(objectives) <= 2:\n            return objectives[0]\n        distances = np.array([np.linalg.norm(objectives[i] - objectives[i-1]) for i in range(1, len(objectives))])\n        knee_idx = np.argmax(distances)\n        return objectives[knee_idx]\n\n    objectives = [obj for _, obj in archive]\n    knee = knee_point(objectives)\n    selected_solution = min(archive, key=lambda x: np.linalg.norm(np.array(x[1]) - knee))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Invert the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Edge exchange: swap two edges if it improves the trade-off between objectives\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i_prev = new_solution[i-1]\n    node_i = new_solution[i]\n    node_j_prev = new_solution[j-1]\n    node_j = new_solution[j]\n\n    # Calculate original costs\n    original_cost1 = (distance_matrix_1[node_i_prev, node_i] + distance_matrix_1[node_j_prev, node_j])\n    original_cost2 = (distance_matrix_2[node_i_prev, node_i] + distance_matrix_2[node_j_prev, node_j])\n\n    # Calculate new costs after swapping edges\n    new_cost1 = (distance_matrix_1[node_i_prev, node_j] + distance_matrix_1[node_j_prev, node_i])\n    new_cost2 = (distance_matrix_2[node_i_prev, node_j] + distance_matrix_2[node_j_prev, node_i])\n\n    # Compare trade-off between objectives\n    original_tradeoff = original_cost1 / original_cost2 if original_cost2 != 0 else float('inf')\n    new_tradeoff = new_cost1 / new_cost2 if new_cost2 != 0 else float('inf')\n\n    if new_tradeoff < original_tradeoff or np.random.random() < 0.1:\n        # Perform the edge swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments and swapping edges in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel scoring function that combines the normalized objective values and the solution's diversity, then applies a hybrid local search combining a variable-length segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments of varying lengths and swapping edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objectives and diversity scores\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate diversity scores (average distance to other solutions)\n    diversity_scores = []\n    for sol in [sol for sol, _ in archive]:\n        distances = [np.sum(sol != other_sol) for other_sol in [s for s, _ in archive]]\n        diversity_scores.append(np.mean(distances))\n    diversity_scores = np.array(diversity_scores)\n\n    # Combine normalized objectives and diversity (weighted sum)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: variable-length segment inversion\n    seg_length = max(2, min(n//4, np.random.randint(2, n//2)))\n    a = np.random.randint(1, n - seg_length)\n    b = a + seg_length - 1\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs with tolerance\n    if (new_cost1 < orig_cost1 * 1.05 and new_cost2 < orig_cost2 * 1.05) or (np.random.random() < 0.15):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.618394530242625,
            4.988827347755432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objectives and diversity scores\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate diversity scores (average distance to other solutions)\n    diversity_scores = []\n    for sol in [sol for sol, _ in archive]:\n        distances = [np.sum(sol != other_sol) for other_sol in [s for s, _ in archive]]\n        diversity_scores.append(np.mean(distances))\n    diversity_scores = np.array(diversity_scores)\n\n    # Combine normalized objectives and diversity (weighted sum)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: variable-length segment inversion\n    seg_length = max(2, min(n//4, np.random.randint(2, n//2)))\n    a = np.random.randint(1, n - seg_length)\n    b = a + seg_length - 1\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs with tolerance\n    if (new_cost1 < orig_cost1 * 1.05 and new_cost2 < orig_cost2 * 1.05) or (np.random.random() < 0.15):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node swap that explores the solution space by strategically inverting segments and swapping nodes in a way that improves both objectives while maintaining feasibility, but with a different selection mechanism and more aggressive local search operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] + \\\n                      distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]]\n    original_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]]\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.4):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8457551232816582,
            2.043937385082245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node swap: swap two nodes if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1 = new_solution[c]\n    node2 = new_solution[d]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] + \\\n                      distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]]\n    original_cost2 = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] + \\\n                     distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]]\n\n    new_cost1 = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] + \\\n                distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] + \\\n                distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]]\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.4):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node swapping that explores the solution space by strategically rotating segments and swapping nodes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if c != d:\n        node1, node2 = new_solution[c], new_solution[d]\n\n        cost1_before = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] + \\\n                       distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]]\n        cost2_before = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] + \\\n                       distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]]\n\n        cost1_after = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] + \\\n                      distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]]\n        cost2_after = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] + \\\n                      distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7535690030828168,
            1.9545586109161377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if c != d:\n        node1, node2 = new_solution[c], new_solution[d]\n\n        cost1_before = distance_matrix_1[new_solution[c-1], node1] + distance_matrix_1[node1, new_solution[c+1]] + \\\n                       distance_matrix_1[new_solution[d-1], node2] + distance_matrix_1[node2, new_solution[d+1]]\n        cost2_before = distance_matrix_2[new_solution[c-1], node1] + distance_matrix_2[node1, new_solution[c+1]] + \\\n                       distance_matrix_2[new_solution[d-1], node2] + distance_matrix_2[node2, new_solution[d+1]]\n\n        cost1_after = distance_matrix_1[new_solution[c-1], node2] + distance_matrix_1[node2, new_solution[c+1]] + \\\n                      distance_matrix_1[new_solution[d-1], node1] + distance_matrix_1[node1, new_solution[d+1]]\n        cost2_after = distance_matrix_2[new_solution[c-1], node2] + distance_matrix_2[node2, new_solution[c+1]] + \\\n                      distance_matrix_2[new_solution[d-1], node1] + distance_matrix_2[node1, new_solution[d+1]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation, which rotates a segment of the tour and then relocates a node to a position that improves both objectives if possible, while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a position that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_move = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we move the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_move] + distance_matrix_1[node_to_move, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_move] + distance_matrix_2[node_to_move, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_move], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8924146666950444,
            1.1783180236816406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a position that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_move = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we move the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_move] + distance_matrix_1[node_to_move, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_move] + distance_matrix_2[node_to_move, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_move], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel path reversal with a multi-objective-aware segment insertion that explores the solution space by strategically reversing segments and inserting them at new positions in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: path reversal with multi-objective segment insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Segment insertion: move a segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment_to_insert = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment_to_insert, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This new algorithm selects a solution from the archive based on the worst objective values, then applies a novel local search strategy that combines a multi-objective-aware node swap with a dynamic segment rotation to explore the solution space by strategically swapping nodes and rotating segments, improving both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the worst solution based on the sum of objectives\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective-aware node swap\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9768696118682691,
            2.158623695373535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the worst solution based on the sum of objectives\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective-aware node swap\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment rotation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining a novel node reinsertion strategy with a multi-objective-aware edge swapping operation, which intelligently reorders segments of the tour while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    archive_sorted = sorted(archive, key=lambda x: 0.7*x[1][0] + 0.3*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel node reinsertion strategy\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Find best insertion point for the segment\n    best_pos = 0\n    best_score = float('inf')\n\n    for pos in range(1, len(new_solution)):\n        # Calculate cost of inserting segment at this position\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n        first_node = segment[0]\n        last_node = segment[-1]\n\n        cost1 = (distance_matrix_1[prev_node, first_node] +\n                 distance_matrix_1[last_node, next_node] -\n                 distance_matrix_1[prev_node, next_node])\n\n        cost2 = (distance_matrix_2[prev_node, first_node] +\n                 distance_matrix_2[last_node, next_node] -\n                 distance_matrix_2[prev_node, next_node])\n\n        combined_score = 0.6*cost1 + 0.4*cost2\n\n        if combined_score < best_score:\n            best_score = combined_score\n            best_pos = pos\n\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Multi-objective-aware edge swapping\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        swap_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        swap_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if improves both objectives or with probability\n        if ((swap_cost1 < current_cost1 and swap_cost2 < current_cost2) or\n            (np.random.random() < 0.2 and (swap_cost1 + swap_cost2) < (current_cost1 + current_cost2))):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6945509602348677,
            5.180107891559601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    archive_sorted = sorted(archive, key=lambda x: 0.7*x[1][0] + 0.3*x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel node reinsertion strategy\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Find best insertion point for the segment\n    best_pos = 0\n    best_score = float('inf')\n\n    for pos in range(1, len(new_solution)):\n        # Calculate cost of inserting segment at this position\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n        first_node = segment[0]\n        last_node = segment[-1]\n\n        cost1 = (distance_matrix_1[prev_node, first_node] +\n                 distance_matrix_1[last_node, next_node] -\n                 distance_matrix_1[prev_node, next_node])\n\n        cost2 = (distance_matrix_2[prev_node, first_node] +\n                 distance_matrix_2[last_node, next_node] -\n                 distance_matrix_2[prev_node, next_node])\n\n        combined_score = 0.6*cost1 + 0.4*cost2\n\n        if combined_score < best_score:\n            best_score = combined_score\n            best_pos = pos\n\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Multi-objective-aware edge swapping\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        swap_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        swap_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if improves both objectives or with probability\n        if ((swap_cost1 < current_cost1 and swap_cost2 < current_cost2) or\n            (np.random.random() < 0.2 and (swap_cost1 + swap_cost2) < (current_cost1 + current_cost2))):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, ensuring feasibility through careful validation and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted sum of normalized objectives\n    normalized_costs = [(obj[0]/distance_matrix_1.max(), obj[1]/distance_matrix_2.max()) for (_, obj) in archive]\n    weights = [0.6, 0.4]  # More weight on first objective\n    weighted_scores = [w1 * n1 + w2 * n2 for (n1, n2), (w1, w2) in zip(normalized_costs, zip(weights, [1-w for w in weights]))]\n    selected_solution = archive[np.argmin(weighted_scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with probability\n    if np.random.random() < 0.7:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction with probability\n    if np.random.random() < 0.5:\n        c = np.random.choice(range(1, n-1))\n        node1 = new_solution[c]\n        node2 = new_solution[c+1]\n\n        for pos in range(1, n-1):\n            if pos == c or pos == c+1:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            # Calculate potential improvement\n            delta1 = (distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next] -\n                     distance_matrix_1[new_prev, new_solution[pos]] - distance_matrix_1[new_solution[pos], new_solution[pos+1]])\n            delta2 = (distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next] -\n                     distance_matrix_2[new_prev, new_solution[pos]] - distance_matrix_2[new_solution[pos], new_solution[pos+1]])\n\n            if (delta1 < 0 and delta2 < 0) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7857302583793716,
            3.2052388787269592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted sum of normalized objectives\n    normalized_costs = [(obj[0]/distance_matrix_1.max(), obj[1]/distance_matrix_2.max()) for (_, obj) in archive]\n    weights = [0.6, 0.4]  # More weight on first objective\n    weighted_scores = [w1 * n1 + w2 * n2 for (n1, n2), (w1, w2) in zip(normalized_costs, zip(weights, [1-w for w in weights]))]\n    selected_solution = archive[np.argmin(weighted_scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with probability\n    if np.random.random() < 0.7:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction with probability\n    if np.random.random() < 0.5:\n        c = np.random.choice(range(1, n-1))\n        node1 = new_solution[c]\n        node2 = new_solution[c+1]\n\n        for pos in range(1, n-1):\n            if pos == c or pos == c+1:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            # Calculate potential improvement\n            delta1 = (distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next] -\n                     distance_matrix_1[new_prev, new_solution[pos]] - distance_matrix_1[new_solution[pos], new_solution[pos+1]])\n            delta2 = (distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next] -\n                     distance_matrix_2[new_prev, new_solution[pos]] - distance_matrix_2[new_solution[pos], new_solution[pos+1]])\n\n            if (delta1 < 0 and delta2 < 0) or (np.random.random() < 0.2):\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments and swapping edges in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This new algorithm selects a solution from the archive based on its Pareto dominance, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion that explores the solution space by strategically rotating segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node insertion: insert a node at a random position if it improves both objectives\n    i = np.random.choice(range(1, n-1))\n    j = np.random.choice(range(1, n-1))\n\n    # Calculate original costs\n    orig_prev = new_solution[i-1]\n    orig_node = new_solution[i]\n    orig_next = new_solution[i+1] if i+1 < n else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[orig_prev, orig_node] + distance_matrix_1[orig_node, orig_next]\n    orig_cost2 = distance_matrix_2[orig_prev, orig_node] + distance_matrix_2[orig_node, orig_next]\n\n    # Calculate new costs\n    new_prev = new_solution[j-1] if j > 0 else new_solution[-1]\n    new_next = new_solution[j] if j < n-1 else new_solution[0]\n\n    new_cost1 = distance_matrix_1[new_prev, orig_node] + distance_matrix_1[orig_node, new_next] + distance_matrix_1[new_prev, new_next]\n    new_cost2 = distance_matrix_2[new_prev, orig_node] + distance_matrix_2[orig_node, new_next] + distance_matrix_2[new_prev, new_next]\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.15):\n        # Perform the insertion\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, orig_node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.42213623981526477,
            2.6455053091049194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node insertion: insert a node at a random position if it improves both objectives\n    i = np.random.choice(range(1, n-1))\n    j = np.random.choice(range(1, n-1))\n\n    # Calculate original costs\n    orig_prev = new_solution[i-1]\n    orig_node = new_solution[i]\n    orig_next = new_solution[i+1] if i+1 < n else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[orig_prev, orig_node] + distance_matrix_1[orig_node, orig_next]\n    orig_cost2 = distance_matrix_2[orig_prev, orig_node] + distance_matrix_2[orig_node, orig_next]\n\n    # Calculate new costs\n    new_prev = new_solution[j-1] if j > 0 else new_solution[-1]\n    new_next = new_solution[j] if j < n-1 else new_solution[0]\n\n    new_cost1 = distance_matrix_1[new_prev, orig_node] + distance_matrix_1[orig_node, new_next] + distance_matrix_1[new_prev, new_next]\n    new_cost2 = distance_matrix_2[new_prev, orig_node] + distance_matrix_2[orig_node, new_next] + distance_matrix_2[new_prev, new_next]\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.15):\n        # Perform the insertion\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, orig_node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment crossover with a multi-objective-aware node swap that explores the solution space by exchanging segments between two promising solutions and strategically swapping nodes to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    crossover_point = np.random.randint(1, n-1)\n\n    # Perform segment crossover with another solution from the archive\n    other_solution = archive_sorted[np.random.randint(0, len(archive_sorted))][0].copy()\n    new_solution = np.concatenate([selected_solution[:crossover_point], other_solution[crossover_point:]])\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate costs before and after swap\n    original_cost1 = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]])\n    original_cost2 = (distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] +\n                 distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]])\n    new_cost2 = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] +\n                 distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9819291287919446,
            2.4313718676567078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    crossover_point = np.random.randint(1, n-1)\n\n    # Perform segment crossover with another solution from the archive\n    other_solution = archive_sorted[np.random.randint(0, len(archive_sorted))][0].copy()\n    new_solution = np.concatenate([selected_solution[:crossover_point], other_solution[crossover_point:]])\n\n    # Node swap: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate costs before and after swap\n    original_cost1 = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]])\n    original_cost2 = (distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] +\n                 distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]])\n    new_cost2 = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] +\n                 distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]])\n\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel local search combining node reinsertion with a segment reversal to balance improvements across both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node reinsertion with segment reversal\n    i = np.random.randint(1, n-1)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n\n    j = np.random.randint(1, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Reverse a segment to balance objectives\n    k = np.random.randint(1, n-2)\n    segment_length = np.random.randint(2, min(5, n-k))\n    new_solution[k:k+segment_length] = new_solution[k+segment_length-1:k-1:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-criteria balance score, then applies a novel local search combining adaptive segment swapping with a Pareto-aware node relocation that explores the solution space by dynamically adjusting segments and relocating nodes to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance score (normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = np.linalg.norm(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment swapping\n    segment_length = max(2, min(5, n // 4))\n    a = np.random.randint(1, n-segment_length)\n    b = np.random.randint(1, n-segment_length)\n    while abs(a - b) < segment_length:\n        b = np.random.randint(1, n-segment_length)\n\n    # Swap segments while maintaining circular structure\n    segment1 = new_solution[a:a+segment_length]\n    segment2 = new_solution[b:b+segment_length]\n    new_solution[a:a+segment_length] = segment2\n    new_solution[b:b+segment_length] = segment1\n\n    # Pareto-aware node relocation\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n\n        # Find best insertion position that doesn't dominate any existing position\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(1, n):\n            if pos == i:\n                continue\n\n            # Calculate cost change\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n            new_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            old_cost1 = distance_matrix_1[prev, next_node]\n\n            prev = new_solution[i-1]\n            next_node = new_solution[i+1] if i+1 < n else new_solution[0]\n            old_cost1 += distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n\n            improvement1 = old_cost1 - new_cost1\n\n            # Similar for second objective\n            new_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n            old_cost2 = distance_matrix_2[prev, next_node]\n\n            prev = new_solution[i-1]\n            next_node = new_solution[i+1] if i+1 < n else new_solution[0]\n            old_cost2 += distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n            improvement2 = old_cost2 - new_cost2\n\n            # Check if this is a Pareto improvement\n            if improvement1 > 0 and improvement2 > 0:\n                if improvement1 + improvement2 > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+1:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6776341454680234,
            14.649814784526825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance score (normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = np.linalg.norm(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment swapping\n    segment_length = max(2, min(5, n // 4))\n    a = np.random.randint(1, n-segment_length)\n    b = np.random.randint(1, n-segment_length)\n    while abs(a - b) < segment_length:\n        b = np.random.randint(1, n-segment_length)\n\n    # Swap segments while maintaining circular structure\n    segment1 = new_solution[a:a+segment_length]\n    segment2 = new_solution[b:b+segment_length]\n    new_solution[a:a+segment_length] = segment2\n    new_solution[b:b+segment_length] = segment1\n\n    # Pareto-aware node relocation\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n\n        # Find best insertion position that doesn't dominate any existing position\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(1, n):\n            if pos == i:\n                continue\n\n            # Calculate cost change\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n            new_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            old_cost1 = distance_matrix_1[prev, next_node]\n\n            prev = new_solution[i-1]\n            next_node = new_solution[i+1] if i+1 < n else new_solution[0]\n            old_cost1 += distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n\n            improvement1 = old_cost1 - new_cost1\n\n            # Similar for second objective\n            new_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n            old_cost2 = distance_matrix_2[prev, next_node]\n\n            prev = new_solution[i-1]\n            next_node = new_solution[i+1] if i+1 < n else new_solution[0]\n            old_cost2 += distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n            improvement2 = old_cost2 - new_cost2\n\n            # Check if this is a Pareto improvement\n            if improvement1 > 0 and improvement2 > 0:\n                if improvement1 + improvement2 > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+1:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments and swapping edges in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment shuffling with a multi-objective-aware node insertion that explores the solution space by strategically shuffling segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shuffling with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node insertion: insert a node at a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8713193909866447,
            0.7519799470901489
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment shuffling with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Node insertion: insert a node at a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.15):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments and swapping edges in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective diversity, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion that explores the solution space by rotating segments and strategically inserting nodes in a way that balances improvement across both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node insertion: find the best position to insert a node to improve both objectives\n    node_to_insert = np.random.choice(new_solution[1:-1])\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if new_solution[pos] == node_to_insert:\n            continue\n\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        # Calculate original costs\n        orig_cost1 = distance_matrix_1[prev_node, next_node]\n        orig_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # Calculate new costs if node is inserted here\n        new_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Calculate improvement\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        # Remove the node from its current position\n        current_pos = np.where(new_solution == node_to_insert)[0][0]\n        new_solution = np.concatenate([new_solution[:current_pos], new_solution[current_pos+1:]])\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.391874004979173,
            2.3963009119033813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most diverse objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[-1][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node insertion: find the best position to insert a node to improve both objectives\n    node_to_insert = np.random.choice(new_solution[1:-1])\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(1, n-1):\n        if new_solution[pos] == node_to_insert:\n            continue\n\n        prev_node = new_solution[pos-1]\n        next_node = new_solution[pos]\n\n        # Calculate original costs\n        orig_cost1 = distance_matrix_1[prev_node, next_node]\n        orig_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # Calculate new costs if node is inserted here\n        new_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        new_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Calculate improvement\n        improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        # Remove the node from its current position\n        current_pos = np.where(new_solution == node_to_insert)[0][0]\n        new_solution = np.concatenate([new_solution[:current_pos], new_solution[current_pos+1:]])\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node relocation that explores the solution space by strategically rotating segments and relocating nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Node relocation: move a node to a new position if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_relocate = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_relocate] + distance_matrix_1[node_to_relocate, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_relocate] + distance_matrix_2[node_to_relocate, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_relocate], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This new algorithm selects a non-dominated solution from the archive based on a hypervolume metric, then applies a hybrid local search combining a novel segment crossover with a multi-objective-aware node swapping that explores the solution space by strategically exchanging segments between solutions and swapping nodes in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best hypervolume contribution\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], archive[0][1][0]) * max(x[1][1], archive[0][1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment1 = new_solution[a:b+1]\n\n    # Randomly select another solution from archive for segment crossover\n    crossover_solution = archive[np.random.randint(len(archive))][0]\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment2 = crossover_solution[c:d+1]\n\n    # Combine segments with crossover\n    new_segment = np.concatenate([segment1, segment2])\n    new_segment = np.unique(new_segment)\n    new_solution[a:b+1] = new_segment[:min(len(new_segment), b-a+1)]\n\n    # Node swapping: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node1, node2 = new_solution[i], new_solution[j]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = (distance_matrix_1[new_solution[i-1], node1] + distance_matrix_1[node1, new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], node2] + distance_matrix_1[node2, new_solution[j+1]])\n    original_cost2 = (distance_matrix_2[new_solution[i-1], node1] + distance_matrix_2[node1, new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], node2] + distance_matrix_2[node2, new_solution[j+1]])\n\n    swapped_cost1 = (distance_matrix_1[new_solution[i-1], node2] + distance_matrix_1[node2, new_solution[i+1]] +\n                    distance_matrix_1[new_solution[j-1], node1] + distance_matrix_1[node1, new_solution[j+1]])\n    swapped_cost2 = (distance_matrix_2[new_solution[i-1], node2] + distance_matrix_2[node2, new_solution[i+1]] +\n                    distance_matrix_2[new_solution[j-1], node1] + distance_matrix_2[node1, new_solution[j+1]])\n\n    # Compare costs\n    if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8365000216088898,
            3.655901610851288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best hypervolume contribution\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (max(x[1][0], archive[0][1][0]) * max(x[1][1], archive[0][1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment crossover with multi-objective node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment1 = new_solution[a:b+1]\n\n    # Randomly select another solution from archive for segment crossover\n    crossover_solution = archive[np.random.randint(len(archive))][0]\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment2 = crossover_solution[c:d+1]\n\n    # Combine segments with crossover\n    new_segment = np.concatenate([segment1, segment2])\n    new_segment = np.unique(new_segment)\n    new_solution[a:b+1] = new_segment[:min(len(new_segment), b-a+1)]\n\n    # Node swapping: swap two nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    node1, node2 = new_solution[i], new_solution[j]\n\n    # Calculate costs for the original and swapped positions\n    original_cost1 = (distance_matrix_1[new_solution[i-1], node1] + distance_matrix_1[node1, new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j-1], node2] + distance_matrix_1[node2, new_solution[j+1]])\n    original_cost2 = (distance_matrix_2[new_solution[i-1], node1] + distance_matrix_2[node1, new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j-1], node2] + distance_matrix_2[node2, new_solution[j+1]])\n\n    swapped_cost1 = (distance_matrix_1[new_solution[i-1], node2] + distance_matrix_1[node2, new_solution[i+1]] +\n                    distance_matrix_1[new_solution[j-1], node1] + distance_matrix_1[node1, new_solution[j+1]])\n    swapped_cost2 = (distance_matrix_2[new_solution[i-1], node2] + distance_matrix_2[node2, new_solution[i+1]] +\n                    distance_matrix_2[new_solution[j-1], node1] + distance_matrix_2[node1, new_solution[j+1]])\n\n    # Compare costs\n    if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel node swapping strategy with a multi-objective-aware segment relocation that explores the solution space by strategically swapping nodes and relocating segments in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node swapping with segment relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap two nodes\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment relocation: move a random segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate original cost for the segment\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        # Calculate new cost for the segment at new position\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos] if pos+1 < n else new_solution[0]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8077727766322103,
            0.8930109143257141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: node swapping with segment relocation\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Swap two nodes\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment relocation: move a random segment to a new position if it improves both objectives\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[c:d+1]\n\n    for pos in range(1, n-1):\n        if pos >= c and pos <= d:\n            continue\n\n        # Calculate original cost for the segment\n        original_prev = new_solution[c-1]\n        original_next = new_solution[d+1] if d+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, new_solution[c]] + distance_matrix_1[new_solution[d], original_next]\n        original_cost2 = distance_matrix_2[original_prev, new_solution[c]] + distance_matrix_2[new_solution[d], original_next]\n\n        # Calculate new cost for the segment at new position\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos] if pos+1 < n else new_solution[0]\n        new_cost1 = distance_matrix_1[new_prev, new_solution[c]] + distance_matrix_1[new_solution[d], new_next]\n        new_cost2 = distance_matrix_2[new_prev, new_solution[c]] + distance_matrix_2[new_solution[d], new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.1):\n            # Remove the segment and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[d+1:pos], segment, new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge exchange to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Multi-objective edge exchange: swap edges that improve both objectives if possible\n    for i in range(1, n-2):\n        for j in range(i+1, n-1):\n            # Current edges\n            current_edges1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                              distance_matrix_1[new_solution[j], new_solution[j+1]])\n            current_edges2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                              distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n            # New edges if we swap i and j\n            new_edges1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[i], new_solution[j+1]])\n            new_edges2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n            if (new_edges1 < current_edges1 and new_edges2 < current_edges2) or (np.random.random() < 0.1):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.741935379061899,
            4.920476675033569
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n    # Multi-objective edge exchange: swap edges that improve both objectives if possible\n    for i in range(1, n-2):\n        for j in range(i+1, n-1):\n            # Current edges\n            current_edges1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                              distance_matrix_1[new_solution[j], new_solution[j+1]])\n            current_edges2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                              distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n            # New edges if we swap i and j\n            new_edges1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[i], new_solution[j+1]])\n            new_edges2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n            if (new_edges1 < current_edges1 and new_edges2 < current_edges2) or (np.random.random() < 0.1):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments and swapping edges in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge swapping that explores the solution space by strategically inverting segments and swapping edges in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Edge swapping: swap two edges if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev1 = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next1 = new_solution[i+1] if i+1 < n else new_solution[0]\n    orig_next2 = new_solution[j+1] if j+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev1, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next1] +\n                  distance_matrix_1[orig_node2, orig_next2])\n    orig_cost2 = (distance_matrix_2[orig_prev1, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next1] +\n                  distance_matrix_2[orig_node2, orig_next2])\n\n    # Calculate new costs\n    new_cost1 = (distance_matrix_1[orig_prev1, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_next1] +\n                 distance_matrix_1[orig_node1, orig_next2])\n    new_cost2 = (distance_matrix_2[orig_prev1, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_next1] +\n                 distance_matrix_2[orig_node1, orig_next2])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm selects a solution from the archive based on its balance between objectives, then applies a novel local search that combines segment rotation with multi-objective edge insertion, exploring the solution space by strategically rotating segments and inserting edges in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation with multi-objective edge insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge insertion: insert a node between two non-adjacent nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if abs(i - j) <= 1:\n        return new_solution\n\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next = new_solution[i+1] if i+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next] +\n                  distance_matrix_1[orig_node2, orig_next])\n    orig_cost2 = (distance_matrix_2[orig_prev, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next] +\n                  distance_matrix_2[orig_node2, orig_next])\n\n    # Calculate new costs (insert node1 between node2 and its next)\n    new_cost1 = (distance_matrix_1[orig_prev, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_node1] +\n                 distance_matrix_1[orig_node1, orig_next])\n    new_cost2 = (distance_matrix_2[orig_prev, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_node1] +\n                 distance_matrix_2[orig_node1, orig_next])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the insertion\n        new_solution = np.concatenate([\n            new_solution[:i],\n            np.array([new_solution[i]]),\n            new_solution[i+1:j+1],\n            new_solution[j+1:]\n        ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9895392714621211,
            2.5501989126205444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment rotation with multi-objective edge insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge insertion: insert a node between two non-adjacent nodes if it improves both objectives\n    i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n    if abs(i - j) <= 1:\n        return new_solution\n\n    if i > j:\n        i, j = j, i\n\n    # Calculate original costs\n    orig_prev = new_solution[i-1]\n    orig_node1 = new_solution[i]\n    orig_node2 = new_solution[j]\n    orig_next = new_solution[i+1] if i+1 < n else new_solution[0]\n\n    orig_cost1 = (distance_matrix_1[orig_prev, orig_node1] +\n                  distance_matrix_1[orig_node1, orig_next] +\n                  distance_matrix_1[orig_node2, orig_next])\n    orig_cost2 = (distance_matrix_2[orig_prev, orig_node1] +\n                  distance_matrix_2[orig_node1, orig_next] +\n                  distance_matrix_2[orig_node2, orig_next])\n\n    # Calculate new costs (insert node1 between node2 and its next)\n    new_cost1 = (distance_matrix_1[orig_prev, orig_node2] +\n                 distance_matrix_1[orig_node2, orig_node1] +\n                 distance_matrix_1[orig_node1, orig_next])\n    new_cost2 = (distance_matrix_2[orig_prev, orig_node2] +\n                 distance_matrix_2[orig_node2, orig_node1] +\n                 distance_matrix_2[orig_node1, orig_next])\n\n    # Compare costs\n    if (new_cost1 < orig_cost1 and new_cost2 < orig_cost2) or (np.random.random() < 0.1):\n        # Perform the insertion\n        new_solution = np.concatenate([\n            new_solution[:i],\n            np.array([new_solution[i]]),\n            new_solution[i+1:j+1],\n            new_solution[j+1:]\n        ])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment reversal with a multi-objective-aware edge contraction, which contracts two adjacent nodes into one and then inserts them back in a way that improves both objectives if possible, while ensuring feasibility, but with a different selection mechanism and more aggressive local search operations.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives using a different scoring function\n    archive_sorted = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - 0.5 * (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: more aggressive segment reversal and edge contraction\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge contraction: contract two adjacent nodes into one\n    c = np.random.choice(range(1, n-1))\n    node1 = new_solution[c]\n    node2 = new_solution[c+1]\n\n    # Insert the contracted node back in a way that improves both objectives if possible\n    for pos in range(1, n-1):\n        if pos == c or pos == c+1:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the contracted node here\n        new_cost1 = distance_matrix_1[new_prev, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.3):\n            # Remove the two nodes and insert the contracted node\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+2:pos], [node1, node2], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives with a dynamic bias towards the underperforming objective, then applies a hybrid local search combining a multi-segment reversal with a novel node insertion strategy that considers both objectives simultaneously to ensure balanced improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic weighted sum of objectives\n    avg_obj1 = sum(obj[0] for _, obj in archive) / len(archive)\n    avg_obj2 = sum(obj[1] for _, obj in archive) / len(archive)\n\n    def dynamic_weight(obj1, obj2):\n        weight1 = 1.0 if obj1 > avg_obj1 else 0.7\n        weight2 = 1.0 if obj2 > avg_obj2 else 0.7\n        return weight1 * obj1 + weight2 * obj2\n\n    archive_sorted = sorted(archive, key=lambda x: dynamic_weight(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment reversal\n    points = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    new_solution[points[0]:points[1]+1] = new_solution[points[0]:points[1]+1][::-1]\n    new_solution[points[1]:points[2]+1] = new_solution[points[1]:points[2]+1][::-1]\n\n    # Novel node insertion strategy\n    for _ in range(2):\n        i = np.random.choice(range(1, n-1))\n        j = np.random.choice(range(1, n-1))\n        if i == j:\n            continue\n\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.4):\n            # Perform insertion\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.random.choice(range(1, len(new_solution)-1))\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7358192041419334,
            2.3868343234062195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with dynamic weighted sum of objectives\n    avg_obj1 = sum(obj[0] for _, obj in archive) / len(archive)\n    avg_obj2 = sum(obj[1] for _, obj in archive) / len(archive)\n\n    def dynamic_weight(obj1, obj2):\n        weight1 = 1.0 if obj1 > avg_obj1 else 0.7\n        weight2 = 1.0 if obj2 > avg_obj2 else 0.7\n        return weight1 * obj1 + weight2 * obj2\n\n    archive_sorted = sorted(archive, key=lambda x: dynamic_weight(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment reversal\n    points = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    new_solution[points[0]:points[1]+1] = new_solution[points[0]:points[1]+1][::-1]\n    new_solution[points[1]:points[2]+1] = new_solution[points[1]:points[2]+1][::-1]\n\n    # Novel node insertion strategy\n    for _ in range(2):\n        i = np.random.choice(range(1, n-1))\n        j = np.random.choice(range(1, n-1))\n        if i == j:\n            continue\n\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.4):\n            # Perform insertion\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.random.choice(range(1, len(new_solution)-1))\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion that explores the solution space by strategically inverting segments and inserting nodes in a way that improves both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from outside the current segment into the solution if it improves both objectives\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        # Calculate costs for the original and new positions\n        original_prev = new_solution[c-1]\n        original_next = new_solution[c+1] if c+1 < n else new_solution[0]\n        original_cost1 = distance_matrix_1[original_prev, node_to_insert] + distance_matrix_1[node_to_insert, original_next]\n        original_cost2 = distance_matrix_2[original_prev, node_to_insert] + distance_matrix_2[node_to_insert, original_next]\n\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare costs\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or (np.random.random() < 0.2):\n            # Remove the node and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment crossover with a multi-objective-aware node relocation that explores the solution space by strategically exchanging segments between two promising solutions and relocating nodes to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the two best solutions based on Pareto dominance\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    parent1 = archive_sorted[0][0].copy()\n    parent2 = archive_sorted[len(archive_sorted) // 2][0].copy()\n\n    n = len(parent1)\n    if n < 4:\n        return parent1.copy()\n\n    # Segment crossover: exchange a segment between the two parents\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = parent2[a:b+1]\n    new_solution = np.concatenate([parent1[:a], segment, parent1[b+1:]])\n\n    # Node relocation: move nodes to improve both objectives\n    for i in range(1, n-1):\n        node = new_solution[i]\n        best_pos = i\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for j in range(1, n-1):\n            if j == i:\n                continue\n            # Calculate cost if node is moved to position j\n            prev_node = new_solution[j-1]\n            next_node = new_solution[j] if j < n-1 else new_solution[0]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            if (cost1 < best_cost1 and cost2 < best_cost2) or (np.random.random() < 0.1):\n                best_pos = j\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_pos != i:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = parent1.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9394764082858513,
            13.592902302742004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the two best solutions based on Pareto dominance\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    parent1 = archive_sorted[0][0].copy()\n    parent2 = archive_sorted[len(archive_sorted) // 2][0].copy()\n\n    n = len(parent1)\n    if n < 4:\n        return parent1.copy()\n\n    # Segment crossover: exchange a segment between the two parents\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = parent2[a:b+1]\n    new_solution = np.concatenate([parent1[:a], segment, parent1[b+1:]])\n\n    # Node relocation: move nodes to improve both objectives\n    for i in range(1, n-1):\n        node = new_solution[i]\n        best_pos = i\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for j in range(1, n-1):\n            if j == i:\n                continue\n            # Calculate cost if node is moved to position j\n            prev_node = new_solution[j-1]\n            next_node = new_solution[j] if j < n-1 else new_solution[0]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            if (cost1 < best_cost1 and cost2 < best_cost2) or (np.random.random() < 0.1):\n                best_pos = j\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_pos != i:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = parent1.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node reinsertion that explores the solution space by strategically reordering and repositioning segments while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node reinsertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Node reinsertion: reinsert a node to improve both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_reinsert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        new_cost1 = distance_matrix_1[new_prev, node_to_reinsert] + distance_matrix_1[node_to_reinsert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_reinsert] + distance_matrix_2[node_to_reinsert, new_next]\n\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_reinsert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the objective space, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node swap that explores the solution space by strategically rotating and swapping segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swap: swap two nodes to improve both objectives if possible\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i, node_j = new_solution[i], new_solution[j]\n\n    original_cost1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] + \\\n                     distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] + \\\n                     distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]]\n\n    swapped_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] + \\\n                    distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]]\n    swapped_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] + \\\n                    distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]]\n\n    if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8286781079789054,
            2.0462470650672913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node swap: swap two nodes to improve both objectives if possible\n    i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node_i, node_j = new_solution[i], new_solution[j]\n\n    original_cost1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] + \\\n                     distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[j+1]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]] + \\\n                     distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[j+1]]\n\n    swapped_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] + \\\n                    distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[j+1]]\n    swapped_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]] + \\\n                    distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[j+1]]\n\n    if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or (np.random.random() < 0.1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment reversal with a multi-objective-aware node swap to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives using a weighted sum\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Multi-objective node swap: swap two nodes if it improves both objectives\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        current_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n        current_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n        new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n        new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5937028436534082,
            1.5827473402023315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives using a weighted sum\n    archive_sorted = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multi-objective node swap\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Multi-objective node swap: swap two nodes if it improves both objectives\n    for _ in range(2):\n        i, j = np.random.choice(range(1, n-1), size=2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        current_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n        current_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n        new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n        new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its objective values and applies a hybrid local search combining a novel segment inversion with a multi-objective-aware node insertion, which inverts a segment of the tour and then inserts a node from another segment in a way that improves both objectives if possible, while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node insertion: insert a node from another segment in a way that improves both objectives if possible\n    c = np.random.choice(range(1, n-1))\n    node_to_insert = new_solution[c]\n\n    for pos in range(1, n-1):\n        if pos == c:\n            continue\n        new_prev = new_solution[pos-1]\n        new_next = new_solution[pos]\n\n        # Calculate costs if we insert the node here\n        new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n        # Compare with current cost\n        current_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        current_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.15):\n            # Remove the node from its current position and insert it at the new position\n            new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n            break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized objective values and applies a novel hybrid local search combining a multi-objective-aware segment rotation with a dynamic node swapping strategy, which rotates a segment of the tour and then swaps nodes between segments in a way that improves both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the best balance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with dynamic node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Dynamic node swapping\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1, node2 = new_solution[c], new_solution[d]\n\n    # Calculate cost changes\n    def cost_change(pos1, pos2):\n        prev1, next1 = new_solution[pos1-1], new_solution[(pos1+1)%n]\n        prev2, next2 = new_solution[pos2-1], new_solution[(pos2+1)%n]\n\n        old_cost1 = distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] + distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2]\n        new_cost1 = distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] + distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2]\n\n        old_cost2 = distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] + distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2]\n        new_cost2 = distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] + distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2]\n\n        return (new_cost1 - old_cost1, new_cost2 - old_cost2)\n\n    delta1, delta2 = cost_change(c, d)\n    if (delta1 < 0 and delta2 < 0) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6454077031712795,
            2.244081497192383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select the solution with the best balance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with dynamic node swapping\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Dynamic node swapping\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    node1, node2 = new_solution[c], new_solution[d]\n\n    # Calculate cost changes\n    def cost_change(pos1, pos2):\n        prev1, next1 = new_solution[pos1-1], new_solution[(pos1+1)%n]\n        prev2, next2 = new_solution[pos2-1], new_solution[(pos2+1)%n]\n\n        old_cost1 = distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] + distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2]\n        new_cost1 = distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] + distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2]\n\n        old_cost2 = distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] + distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2]\n        new_cost2 = distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] + distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2]\n\n        return (new_cost1 - old_cost1, new_cost2 - old_cost2)\n\n    delta1, delta2 = cost_change(c, d)\n    if (delta1 < 0 and delta2 < 0) or (np.random.random() < 0.2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment rotation with a multi-objective-aware node insertion to explore the solution space more effectively while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation with multi-objective node insertion\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c = np.random.choice(range(1, n-1))\n\n    # Rotate segment [a:b] and insert at position c\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c], rotated_segment, new_solution[c:]])\n\n    # Multi-objective node insertion: insert a node that improves both objectives if possible\n    if c > 0 and c < n-1:\n        node_to_insert = new_solution[c]\n        prev_node = new_solution[c-1]\n        next_node = new_solution[c+1]\n\n        current_cost1 = distance_matrix_1[prev_node, node_to_insert] + distance_matrix_1[node_to_insert, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node_to_insert] + distance_matrix_2[node_to_insert, next_node]\n\n        # Try inserting at different positions\n        for pos in range(1, n-1):\n            if pos == c:\n                continue\n            new_prev = new_solution[pos-1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node_to_insert] + distance_matrix_1[node_to_insert, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node_to_insert] + distance_matrix_2[node_to_insert, new_next]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.2):\n                # Remove from current position and insert at new position\n                new_solution = np.concatenate([new_solution[:c], new_solution[c+1:pos], [node_to_insert], new_solution[pos:]])\n                break\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in both objectives, then applies a hybrid local search combining a novel segment inversion with a multi-objective-aware edge exchange to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge exchange: exchange edges if they improve both objectives\n    if c != d and abs(c - d) > 1:\n        node_c = new_solution[c]\n        node_d = new_solution[d]\n\n        # Current cost\n        prev_c = new_solution[c-1]\n        next_c = new_solution[c+1]\n        prev_d = new_solution[d-1]\n        next_d = new_solution[d+1]\n\n        current_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                         distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n        current_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                         distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n        # New cost after exchange\n        new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                     distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n        new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                     distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n            # Perform edge exchange\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7185010933731115,
            1.6160995960235596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best balance between objectives (Pareto-frontier aware)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment inversion with multi-objective edge exchange\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Invert segment [a:b]\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge exchange: exchange edges if they improve both objectives\n    if c != d and abs(c - d) > 1:\n        node_c = new_solution[c]\n        node_d = new_solution[d]\n\n        # Current cost\n        prev_c = new_solution[c-1]\n        next_c = new_solution[c+1]\n        prev_d = new_solution[d-1]\n        next_d = new_solution[d+1]\n\n        current_cost1 = (distance_matrix_1[prev_c, node_c] + distance_matrix_1[node_c, next_c] +\n                         distance_matrix_1[prev_d, node_d] + distance_matrix_1[node_d, next_d])\n        current_cost2 = (distance_matrix_2[prev_c, node_c] + distance_matrix_2[node_c, next_c] +\n                         distance_matrix_2[prev_d, node_d] + distance_matrix_2[node_d, next_d])\n\n        # New cost after exchange\n        new_cost1 = (distance_matrix_1[prev_c, node_d] + distance_matrix_1[node_d, next_c] +\n                     distance_matrix_1[prev_d, node_c] + distance_matrix_1[node_c, next_d])\n        new_cost2 = (distance_matrix_2[prev_c, node_d] + distance_matrix_2[node_d, next_c] +\n                     distance_matrix_2[prev_d, node_c] + distance_matrix_2[node_c, next_d])\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.random() < 0.1):\n            # Perform edge exchange\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    }
]