[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7816941956460404,
            1.3350905776023865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7816941956460404,
            1.3350905776023865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7816941956460404,
            1.3350905776023865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8937542885085858,
            1.164538562297821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8937542885085858,
            1.164538562297821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8937542885085858,
            1.164538562297821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function selects a solution with the highest combined objective value from the archive, applies a hybrid local search operator that combines edge reinsertion with a novel node-swap strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reinsertion combined with node-swap\n    if n > 3:\n        # Randomly select a segment to reinsert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Find the best position to reinsert the segment\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            # Insert segment and calculate cost\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n        # Apply a node-swap between two random positions\n        if n > 4:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9186955388320661,
            3.8463078141212463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reinsertion combined with node-swap\n    if n > 3:\n        # Randomly select a segment to reinsert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Find the best position to reinsert the segment\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            # Insert segment and calculate cost\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n        # Apply a node-swap between two random positions\n        if n > 4:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function selects a solution with the highest combined objective value from the archive, applies a hybrid local search operator that combines edge reinsertion with a novel node-swap strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reinsertion combined with node-swap\n    if n > 3:\n        # Randomly select a segment to reinsert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Find the best position to reinsert the segment\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            # Insert segment and calculate cost\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n        # Apply a node-swap between two random positions\n        if n > 4:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9186955388320661,
            3.8463078141212463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reinsertion combined with node-swap\n    if n > 3:\n        # Randomly select a segment to reinsert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Find the best position to reinsert the segment\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            # Insert segment and calculate cost\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n        # Apply a node-swap between two random positions\n        if n > 4:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9737082715822161,
            4.018761157989502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9737082715822161,
            4.018761157989502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8090458905383213,
            2.227230727672577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9490662187144441,
            2.181000530719757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines a partial tour reversal with a segment swap to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select a solution with high potential for improvement\n    selected_sol = None\n    max_potential = -float('inf')\n    for sol, obj in archive:\n        # Calculate potential based on objective values and diversity\n        potential = (obj[0] + obj[1]) * (1 + np.random.uniform(0, 0.2))\n        if potential > max_potential:\n            max_potential = potential\n            selected_sol = sol\n\n    new_solution = selected_sol.copy()\n\n    # Novel local search operator: Partial reversal with segment swap\n    if len(new_solution) > 4:\n        # Select two random segments\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        c, d = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n\n        # Ensure segments don't overlap\n        if b < c or d < a:\n            # Reverse one segment and swap with another\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2[::-1],\n                new_solution[b+1:c],\n                segment1[::-1],\n                new_solution[d+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.8411030835841256,
            2.8087661266326904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select a solution with high potential for improvement\n    selected_sol = None\n    max_potential = -float('inf')\n    for sol, obj in archive:\n        # Calculate potential based on objective values and diversity\n        potential = (obj[0] + obj[1]) * (1 + np.random.uniform(0, 0.2))\n        if potential > max_potential:\n            max_potential = potential\n            selected_sol = sol\n\n    new_solution = selected_sol.copy()\n\n    # Novel local search operator: Partial reversal with segment swap\n    if len(new_solution) > 4:\n        # Select two random segments\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        c, d = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n\n        # Ensure segments don't overlap\n        if b < c or d < a:\n            # Reverse one segment and swap with another\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2[::-1],\n                new_solution[b+1:c],\n                segment1[::-1],\n                new_solution[d+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel local search heuristic that combines a Pareto-frontier-aware selection of solutions with a dynamic segment-shuffling operation, guided by a multi-objective improvement criterion that prioritizes both objective improvements while avoiding premature convergence.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = pareto_front[np.random.randint(len(pareto_front))][0].copy()\n\n    # Step 2: Apply dynamic segment-shuffling\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomly select a segment to shuffle\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Shuffle the segment with a probability based on objective improvements\n        if np.random.rand() < 0.7:  # 70% chance to shuffle\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n        # Optionally reverse the segment\n        if np.random.rand() < 0.3:  # 30% chance to reverse\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8915768381781201,
            3.005557656288147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        selected_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        selected_solution = pareto_front[np.random.randint(len(pareto_front))][0].copy()\n\n    # Step 2: Apply dynamic segment-shuffling\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomly select a segment to shuffle\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Shuffle the segment with a probability based on objective improvements\n        if np.random.rand() < 0.7:  # 70% chance to shuffle\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n        # Optionally reverse the segment\n        if np.random.rand() < 0.3:  # 30% chance to reverse\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8415676146486226,
            0.7211866974830627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8415676146486226,
            0.7211866974830627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The new algorithm selects a promising solution from the archive, identifies segments with high combined distance in both objectives, and performs a segment-based crossover with another solution from the archive to create a neighbor by combining promising segments from both solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select the solution with the best combined objective\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Select a random solution from the archive for crossover\n    other_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Identify segments in the best solution with high combined distance\n    segment_length = max(3, len(best_solution) // 5)\n    start = np.random.randint(0, len(best_solution) - segment_length)\n    segment = best_solution[start:start+segment_length]\n\n    # Find the best position in other_solution to insert the segment\n    best_pos = 0\n    min_cost = float('inf')\n    for i in range(len(other_solution) - segment_length + 1):\n        # Calculate the cost of inserting the segment at position i\n        cost = 0\n        for j in range(segment_length - 1):\n            cost += distance_matrix_1[segment[j], segment[j+1]] + distance_matrix_2[segment[j], segment[j+1]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create the new solution by combining the best segment with the other solution\n    new_solution = np.concatenate([\n        other_solution[:best_pos],\n        segment,\n        other_solution[best_pos+segment_length:]\n    ])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8778463334971923,
            1.9521538019180298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select the solution with the best combined objective\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Select a random solution from the archive for crossover\n    other_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Identify segments in the best solution with high combined distance\n    segment_length = max(3, len(best_solution) // 5)\n    start = np.random.randint(0, len(best_solution) - segment_length)\n    segment = best_solution[start:start+segment_length]\n\n    # Find the best position in other_solution to insert the segment\n    best_pos = 0\n    min_cost = float('inf')\n    for i in range(len(other_solution) - segment_length + 1):\n        # Calculate the cost of inserting the segment at position i\n        cost = 0\n        for j in range(segment_length - 1):\n            cost += distance_matrix_1[segment[j], segment[j+1]] + distance_matrix_2[segment[j], segment[j+1]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create the new solution by combining the best segment with the other solution\n    new_solution = np.concatenate([\n        other_solution[:best_pos],\n        segment,\n        other_solution[best_pos+segment_length:]\n    ])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.8952846942651833,
            1.647767961025238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    new_solution = best_solution.copy()\n\n    # Apply a segment inversion move: randomly select a segment and reverse it\n    if len(new_solution) > 2:\n        start = np.random.randint(0, len(new_solution) - 1)\n        end = np.random.randint(start + 1, len(new_solution))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply a random swap between two nodes in different segments to diversify the search\n    if len(new_solution) > 4:\n        split_point = np.random.randint(2, len(new_solution) - 1)\n        i = np.random.randint(0, split_point)\n        j = np.random.randint(split_point, len(new_solution))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6933627974513072,
            2.1650165915489197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    new_solution = best_solution.copy()\n\n    # Apply a segment inversion move: randomly select a segment and reverse it\n    if len(new_solution) > 2:\n        start = np.random.randint(0, len(new_solution) - 1)\n        end = np.random.randint(start + 1, len(new_solution))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply a random swap between two nodes in different segments to diversify the search\n    if len(new_solution) > 4:\n        split_point = np.random.randint(2, len(new_solution) - 1)\n        i = np.random.randint(0, split_point)\n        j = np.random.randint(split_point, len(new_solution))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n",
        "score": [
            -0.9421960677599213,
            1.7576600313186646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8501329394749659,
            0.8465039730072021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_obj = float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        combined_obj = sum(obj)\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            best_solution = sol\n\n    # If archive is empty, return a random permutation\n    if best_solution is None:\n        return np.random.permutation(len(instance))\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of random insertion and double-bridge move to generate a neighbor\n    new_solution = best_solution.copy()\n\n    # Random Insertion: Select a random node and insert it at a random position\n    if len(new_solution) > 2:\n        node_idx = np.random.randint(0, len(new_solution))\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Double-Bridge Move: Select four random edges and reconnect them in a different way\n    if len(new_solution) > 4:\n        indices = np.random.choice(len(new_solution), size=4, replace=False)\n        indices.sort()\n        a, b, c, d = indices\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            new_solution[b:c+1],\n            new_solution[a+1:b],\n            new_solution[d:],\n            new_solution[c+1:d]\n        ])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A new algorithm that prioritizes solutions with balanced objective values, applies a hybrid local search combining random segment reversal and edge exchange, and uses adaptive selection pressure based on solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate balance score for each solution\n    balance_scores = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        balance = abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n        balance_scores.append(balance)\n\n    # Select solution with best balance (lower is better)\n    best_idx = np.argmin(balance_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: segment reversal and edge exchange\n    new_solution = base_solution.copy()\n\n    # Segment reversal\n    if len(new_solution) > 2:\n        start, end = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge exchange\n    if len(new_solution) > 4:\n        a, b, c, d = np.random.choice(len(new_solution), size=4, replace=False)\n        if a > b: a, b = b, a\n        if c > d: c, d = d, c\n        if a < c < b:\n            new_solution = np.concatenate([\n                new_solution[:a+1],\n                new_solution[c:b+1],\n                new_solution[a+1:c],\n                new_solution[b+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6855373215764138,
            1.240231990814209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate balance score for each solution\n    balance_scores = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        balance = abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n        balance_scores.append(balance)\n\n    # Select solution with best balance (lower is better)\n    best_idx = np.argmin(balance_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: segment reversal and edge exchange\n    new_solution = base_solution.copy()\n\n    # Segment reversal\n    if len(new_solution) > 2:\n        start, end = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge exchange\n    if len(new_solution) > 4:\n        a, b, c, d = np.random.choice(len(new_solution), size=4, replace=False)\n        if a > b: a, b = b, a\n        if c > d: c, d = d, c\n        if a < c < b:\n            new_solution = np.concatenate([\n                new_solution[:a+1],\n                new_solution[c:b+1],\n                new_solution[a+1:c],\n                new_solution[b+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution with the highest combined objective value from the archive, applies a hybrid local search operator that combines edge reinsertion with a novel node-swap strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reinsertion combined with node-swap\n    if n > 3:\n        # Randomly select a segment to reinsert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Find the best position to reinsert the segment\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            # Insert segment and calculate cost\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n        # Apply a node-swap between two random positions\n        if n > 4:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The new heuristic function selects a solution with the lowest combined objective value from the archive, applies a hybrid local search operator that combines random node reordering with a novel segment reversal strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random node reordering combined with segment reversal\n    if n > 3:\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        segment = segment[::-1]  # Reverse the segment\n\n        # Replace the segment in the solution\n        new_solution[a:b+1] = segment\n\n        # Apply random node reordering between two positions\n        if n > 4:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7755279671268197,
            1.1021473407745361
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random node reordering combined with segment reversal\n    if n > 3:\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        segment = segment[::-1]  # Reverse the segment\n\n        # Replace the segment in the solution\n        new_solution[a:b+1] = segment\n\n        # Apply random node reordering between two positions\n        if n > 4:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel local search heuristic that combines Pareto-dominance-based selection with an adaptive segment relocation mechanism and guided node insertion, leveraging multi-objective distance metrics to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Adaptive segment relocation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Calculate combined distance metric\n        combined_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            combined_dist[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                              distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) / 2\n\n        # Select segment based on distance metric\n        segment_size = min(3, n // 3)\n        segment_start = np.argmax(combined_dist)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Insert segment in a different position\n        insertion_pos = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([\n            new_solution[:segment_start], new_solution[segment_end:],\n            new_solution[insertion_pos:insertion_pos + segment_size], segment\n        ])\n\n    # Step 3: Guided node insertion\n    if n > 4:\n        # Calculate insertion cost for each node\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and insert the node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:],\n            [node_to_move]\n        ])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9110127905056591,
            1.7052034735679626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Adaptive segment relocation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Calculate combined distance metric\n        combined_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            combined_dist[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                              distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) / 2\n\n        # Select segment based on distance metric\n        segment_size = min(3, n // 3)\n        segment_start = np.argmax(combined_dist)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Insert segment in a different position\n        insertion_pos = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([\n            new_solution[:segment_start], new_solution[segment_end:],\n            new_solution[insertion_pos:insertion_pos + segment_size], segment\n        ])\n\n    # Step 3: Guided node insertion\n    if n > 4:\n        # Calculate insertion cost for each node\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and insert the node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:],\n            [node_to_move]\n        ])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This algorithm selects a solution with the highest combined objective value from the archive, then applies a novel segment reversal operator to reverse a randomly selected segment of the tour, ensuring the neighbor remains a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select a segment to reverse\n    n = len(selected_solution)\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Reverse the selected segment\n    new_solution = selected_solution.copy()\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8539377470125336,
            1.5435330867767334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select a segment to reverse\n    n = len(selected_solution)\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n\n    # Reverse the selected segment\n    new_solution = selected_solution.copy()\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shuffling operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the search space and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected = random.choice(non_dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shuffling\n        a, b = sorted(random.sample(range(n-1), 2))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8834578176570472,
            2.158578097820282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected = random.choice(non_dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shuffling\n        a, b = sorted(random.sample(range(n-1), 2))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-phase perturbation mechanism\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8617828309316131,
            1.4324432015419006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-phase perturbation mechanism\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution with the highest combined objective value from the archive, applies a hybrid local search operator that combines edge reinsertion with a novel node-swap strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reinsertion combined with node-swap\n    if n > 3:\n        # Randomly select a segment to reinsert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Find the best position to reinsert the segment\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            # Insert segment and calculate cost\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n        # Apply a node-swap between two random positions\n        if n > 4:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel local search heuristic combines a dominance-based selection of solutions from the archive with a hybrid of node-replacement and multi-segment reversal operations, guided by a dynamic objective trade-off to explore diverse regions of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using dominance-based ranking\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol in archive:\n        is_dominated = False\n        for other in archive:\n            if dominates(other[1], sol[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        selected_solution = max(archive, key=lambda x: -sum(x[1]))[0].copy()\n    else:\n        weights = np.random.dirichlet([1, 1])\n        selected_solution = min(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search with node-replacement and multi-segment reversal\n    if n > 4:\n        # Node-replacement operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Multi-segment reversal\n        num_segments = random.randint(2, min(4, n//2))\n        segments = sorted(random.sample(range(1, n), num_segments-1))\n        segments = [0] + segments + [n]\n        for k in range(len(segments)-1):\n            if segments[k+1] - segments[k] > 1:\n                new_solution[segments[k]:segments[k+1]] = new_solution[segments[k]:segments[k+1]][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.892775108903826,
            1.8242487907409668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using dominance-based ranking\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol in archive:\n        is_dominated = False\n        for other in archive:\n            if dominates(other[1], sol[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        selected_solution = max(archive, key=lambda x: -sum(x[1]))[0].copy()\n    else:\n        weights = np.random.dirichlet([1, 1])\n        selected_solution = min(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search with node-replacement and multi-segment reversal\n    if n > 4:\n        # Node-replacement operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Multi-segment reversal\n        num_segments = random.randint(2, min(4, n//2))\n        segments = sorted(random.sample(range(1, n), num_segments-1))\n        segments = [0] + segments + [n]\n        for k in range(len(segments)-1):\n            if segments[k+1] - segments[k] > 1:\n                new_solution[segments[k]:segments[k+1]] = new_solution[segments[k]:segments[k+1]][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This novel local search heuristic combines a crowding-distance-based selection of solutions from the archive, followed by a hybrid of path relinking and dynamic segment reversal operations, guided by a multi-objective trade-off factor to explore the Pareto front while maintaining feasibility through a dynamic feasibility check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) <= 2:\n            return [float('inf')] * len(solutions)\n\n        obj1 = [obj[0] for _, obj in solutions]\n        obj2 = [obj[1] for _, obj in solutions]\n\n        crowding = [0.0] * len(solutions)\n\n        for i in range(2):\n            sorted_idx = np.argsort([obj1, obj2][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n\n            f_max = [obj1, obj2][i][sorted_idx[-1]]\n            f_min = [obj1, obj2][i][sorted_idx[0]]\n\n            if f_max == f_min:\n                continue\n\n            for j in range(1, len(solutions)-1):\n                idx = sorted_idx[j]\n                crowding[idx] += ([obj1, obj2][i][sorted_idx[j+1]] - [obj1, obj2][i][sorted_idx[j-1]]) / (f_max - f_min)\n\n        return crowding\n\n    crowding = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search with path relinking and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking operation\n    if n > 3:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Dynamic trade-off factor\n        trade_off = random.random()\n        if trade_off < 0.5:\n            # Insert segment in reverse order\n            new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[a:]])\n        else:\n            # Insert segment normally\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:]])\n\n        # Segment reversal operation\n        if n > 4:\n            c = random.randint(0, n-1)\n            d = random.randint(0, n-1)\n            while abs(d - c) < 2:\n                d = random.randint(0, n-1)\n\n            if c > d:\n                c, d = d, c\n\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Randomly swap two nodes if feasibility is violated\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.45665177260752643,
            2.6342787742614746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) <= 2:\n            return [float('inf')] * len(solutions)\n\n        obj1 = [obj[0] for _, obj in solutions]\n        obj2 = [obj[1] for _, obj in solutions]\n\n        crowding = [0.0] * len(solutions)\n\n        for i in range(2):\n            sorted_idx = np.argsort([obj1, obj2][i])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n\n            f_max = [obj1, obj2][i][sorted_idx[-1]]\n            f_min = [obj1, obj2][i][sorted_idx[0]]\n\n            if f_max == f_min:\n                continue\n\n            for j in range(1, len(solutions)-1):\n                idx = sorted_idx[j]\n                crowding[idx] += ([obj1, obj2][i][sorted_idx[j+1]] - [obj1, obj2][i][sorted_idx[j-1]]) / (f_max - f_min)\n\n        return crowding\n\n    crowding = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search with path relinking and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking operation\n    if n > 3:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Dynamic trade-off factor\n        trade_off = random.random()\n        if trade_off < 0.5:\n            # Insert segment in reverse order\n            new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[a:]])\n        else:\n            # Insert segment normally\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:]])\n\n        # Segment reversal operation\n        if n > 4:\n            c = random.randint(0, n-1)\n            d = random.randint(0, n-1)\n            while abs(d - c) < 2:\n                d = random.randint(0, n-1)\n\n            if c > d:\n                c, d = d, c\n\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Randomly swap two nodes if feasibility is violated\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9120206455226674,
            1.2364941239356995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a promising solution from the archive, identifies segments with high combined distance in both objectives, and performs a segment-based crossover with another solution from the archive to create a neighbor by combining promising segments from both solutions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select the solution with the best combined objective\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Select a random solution from the archive for crossover\n    other_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Identify segments in the best solution with high combined distance\n    segment_length = max(3, len(best_solution) // 5)\n    start = np.random.randint(0, len(best_solution) - segment_length)\n    segment = best_solution[start:start+segment_length]\n\n    # Find the best position in other_solution to insert the segment\n    best_pos = 0\n    min_cost = float('inf')\n    for i in range(len(other_solution) - segment_length + 1):\n        # Calculate the cost of inserting the segment at position i\n        cost = 0\n        for j in range(segment_length - 1):\n            cost += distance_matrix_1[segment[j], segment[j+1]] + distance_matrix_2[segment[j], segment[j+1]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = i\n\n    # Create the new solution by combining the best segment with the other solution\n    new_solution = np.concatenate([\n        other_solution[:best_pos],\n        segment,\n        other_solution[best_pos+segment_length:]\n    ])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(instance):\n        missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This new algorithm combines Pareto-optimal solution selection with a multi-segment reassembly mechanism that dynamically adapts segment lengths based on their combined objective impact, using a guided crossover approach that preserves elite segments while introducing diversity through probabilistic segment swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-optimal solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Identify high-impact segments\n    n = len(base_solution)\n    segment_lengths = [max(2, n//k) for k in range(2, 6)]  # Test different segment lengths\n    best_segments = []\n\n    for length in segment_lengths:\n        for start in range(n - length + 1):\n            segment = base_solution[start:start+length]\n            cost = sum(distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]\n                      for i in range(length-1))\n            best_segments.append((cost, start, length, segment))\n\n    if not best_segments:\n        return base_solution\n\n    # Step 3: Select top segments and perform reassembly\n    best_segments.sort()\n    selected_segments = [s[3] for s in best_segments[:min(3, len(best_segments))]]\n\n    # Create new solution by interleaving selected segments\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for seg in selected_segments:\n        new_solution.extend(seg)\n        remaining_nodes -= set(seg)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.9670385914710764,
            6.69205242395401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-optimal solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Identify high-impact segments\n    n = len(base_solution)\n    segment_lengths = [max(2, n//k) for k in range(2, 6)]  # Test different segment lengths\n    best_segments = []\n\n    for length in segment_lengths:\n        for start in range(n - length + 1):\n            segment = base_solution[start:start+length]\n            cost = sum(distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]\n                      for i in range(length-1))\n            best_segments.append((cost, start, length, segment))\n\n    if not best_segments:\n        return base_solution\n\n    # Step 3: Select top segments and perform reassembly\n    best_segments.sort()\n    selected_segments = [s[3] for s in best_segments[:min(3, len(best_segments))]]\n\n    # Create new solution by interleaving selected segments\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for seg in selected_segments:\n        new_solution.extend(seg)\n        remaining_nodes -= set(seg)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge reversal and segment rotation to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge reversal and segment rotation\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge reversal\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[j:i+1] = new_solution[j:i+1][::-1]\n\n    # Segment rotation\n    if k < i:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:], segment])\n    elif k > i:\n        segment = new_solution[i:k]\n        new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.8890480546788251,
            6.210774183273315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge reversal and segment rotation\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge reversal\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[j:i+1] = new_solution[j:i+1][::-1]\n\n    # Segment rotation\n    if k < i:\n        segment = new_solution[k:i]\n        new_solution = np.concatenate([new_solution[:k], new_solution[i:], segment])\n    elif k > i:\n        segment = new_solution[i:k]\n        new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of non-dominated status and objective diversity, then applies a hybrid 2-opt and node insertion local search to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def non_dominated(sol):\n        for other in archive:\n            if (other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and\n                (other[1][0] < sol[1][0] or other[1][1] < sol[1][1])):\n                return False\n        return True\n\n    candidates = [s for s in archive if non_dominated(s)]\n    if not candidates:\n        candidates = archive\n\n    # Select based on objective diversity\n    selected = max(candidates, key=lambda x: (x[1][0] - x[1][1])**2)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt + node insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion between k and l\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l+1], [node], new_solution[l+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.3431880484686561,
            2.2100425958633423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def non_dominated(sol):\n        for other in archive:\n            if (other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and\n                (other[1][0] < sol[1][0] or other[1][1] < sol[1][1])):\n                return False\n        return True\n\n    candidates = [s for s in archive if non_dominated(s)]\n    if not candidates:\n        candidates = archive\n\n    # Select based on objective diversity\n    selected = max(candidates, key=lambda x: (x[1][0] - x[1][1])**2)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt + node insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion between k and l\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l+1], [node], new_solution[l+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a hybrid segment relocation and edge crossover operation to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        distances = [0.0] * len(solutions)\n\n        for i in range(2):\n            sorted_indices = sorted(range(len(objectives)), key=lambda x: objectives[x][i])\n            distances[sorted_indices[0]] = float('inf')\n            distances[sorted_indices[-1]] = float('inf')\n\n            if objectives[sorted_indices[-1]][i] == objectives[sorted_indices[0]][i]:\n                continue\n\n            norm = objectives[sorted_indices[-1]][i] - objectives[sorted_indices[0]][i]\n            for j in range(1, len(solutions)-1):\n                distances[sorted_indices[j]] += (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / norm\n\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance = max(crowding_distances)\n    selected_indices = [i for i, dist in enumerate(crowding_distances) if dist == max_distance]\n    selected_solution = archive[random.choice(selected_indices)][0].copy()\n\n    # Step 2: Apply hybrid segment relocation and edge crossover\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relocation\n        segment_length = random.randint(2, min(4, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert at new position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Edge crossover\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = random.randint(0, n-1)\n\n            # Swap edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6904879038322452,
            2.250365376472473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        distances = [0.0] * len(solutions)\n\n        for i in range(2):\n            sorted_indices = sorted(range(len(objectives)), key=lambda x: objectives[x][i])\n            distances[sorted_indices[0]] = float('inf')\n            distances[sorted_indices[-1]] = float('inf')\n\n            if objectives[sorted_indices[-1]][i] == objectives[sorted_indices[0]][i]:\n                continue\n\n            norm = objectives[sorted_indices[-1]][i] - objectives[sorted_indices[0]][i]\n            for j in range(1, len(solutions)-1):\n                distances[sorted_indices[j]] += (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / norm\n\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance = max(crowding_distances)\n    selected_indices = [i for i, dist in enumerate(crowding_distances) if dist == max_distance]\n    selected_solution = archive[random.choice(selected_indices)][0].copy()\n\n    # Step 2: Apply hybrid segment relocation and edge crossover\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relocation\n        segment_length = random.randint(2, min(4, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert at new position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Edge crossover\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = random.randint(0, n-1)\n\n            # Swap edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a hybrid score combining both objectives, then applies a novel 3-opt-like local search to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a hybrid score combining both objectives\n    scores = []\n    for sol, obj in archive:\n        # Hybrid score: normalized sum of both objectives\n        score = (obj[0] / np.max(distance_matrix_1)) + (obj[1] / np.max(distance_matrix_2))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)  # Prefer solutions with lower hybrid score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply novel 3-opt-like local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Create a new segment by reversing the middle part and inserting it\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = np.random.randint(len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6196813488642415,
            2.733229398727417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a hybrid score combining both objectives\n    scores = []\n    for sol, obj in archive:\n        # Hybrid score: normalized sum of both objectives\n        score = (obj[0] / np.max(distance_matrix_1)) + (obj[1] / np.max(distance_matrix_2))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)  # Prefer solutions with lower hybrid score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply novel 3-opt-like local search\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Create a new segment by reversing the middle part and inserting it\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = np.random.randint(len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{The new algorithm selects a solution from the archive based on the highest sum of normalized objectives, then applies a hybrid local search combining partial reversal and position-based swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: partial reversal and position-based swap\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c = np.random.randint(0, n)\n\n    # Partial reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Position-based swap\n    if c != a and c != b:\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.916831339175675,
            6.3431583642959595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: partial reversal and position-based swap\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c = np.random.randint(0, n)\n\n    # Partial reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Position-based swap\n    if c != a and c != b:\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamically adjusted weighted combination of objectives, then applies a novel hybrid local search combining edge insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic weighted selection (0.6 for first objective, 0.4 for second)\n    weights = (0.6, 0.4)\n    selected = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search: edge insertion and segment rotation\n    if len(selected) > 3:\n        # Random edge insertion\n        i, j = np.random.choice(len(selected), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        node = selected[i]\n        selected = np.concatenate([selected[:i], selected[i+1:j], [node], selected[j:]])\n\n        # Segment rotation between two random points\n        a, b = sorted(np.random.choice(len(selected), size=2, replace=False))\n        segment = selected[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        selected[a:b+1] = np.roll(segment, rotation)\n\n    return selected\n\n",
        "score": [
            -0.9049909946214302,
            2.5262935757637024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic weighted selection (0.6 for first objective, 0.4 for second)\n    weights = (0.6, 0.4)\n    selected = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search: edge insertion and segment rotation\n    if len(selected) > 3:\n        # Random edge insertion\n        i, j = np.random.choice(len(selected), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        node = selected[i]\n        selected = np.concatenate([selected[:i], selected[i+1:j], [node], selected[j:]])\n\n        # Segment rotation between two random points\n        a, b = sorted(np.random.choice(len(selected), size=2, replace=False))\n        segment = selected[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        selected[a:b+1] = np.roll(segment, rotation)\n\n    return selected\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its edges (measured by the number of unique edges in the solution), then applies a novel edge-based local search that combines random edge insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with highest edge diversity (number of unique edges)\n    def edge_diversity(solution):\n        edges = set()\n        for i in range(len(solution)):\n            a, b = solution[i], solution[(i+1)%len(solution)]\n            edges.add((min(a,b), max(a,b)))\n        return len(edges)\n\n    best_solution = max(archive, key=lambda x: edge_diversity(x[0]))[0].copy()\n\n    # Apply edge-based local search: random edge insertion and segment rotation\n    if len(best_solution) > 3:\n        # Random edge insertion\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution = np.concatenate([best_solution[:i+1], best_solution[j:], best_solution[i+1:j], best_solution[j+1:]])\n\n        # Segment rotation between two random points\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rot = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rot:], segment[:rot]])\n\n        return new_solution\n\n    return best_solution\n\n",
        "score": [
            -0.8226216200074299,
            11.56540161371231
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with highest edge diversity (number of unique edges)\n    def edge_diversity(solution):\n        edges = set()\n        for i in range(len(solution)):\n            a, b = solution[i], solution[(i+1)%len(solution)]\n            edges.add((min(a,b), max(a,b)))\n        return len(edges)\n\n    best_solution = max(archive, key=lambda x: edge_diversity(x[0]))[0].copy()\n\n    # Apply edge-based local search: random edge insertion and segment rotation\n    if len(best_solution) > 3:\n        # Random edge insertion\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution = np.concatenate([best_solution[:i+1], best_solution[j:], best_solution[i+1:j], best_solution[j+1:]])\n\n        # Segment rotation between two random points\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rot = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rot:], segment[:rot]])\n\n        return new_solution\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a dynamic segment reversal and edge swapping operation to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, obj in archive]\n    objectives = [obj for sol, obj in archive]\n\n    # Calculate crowding distance for each solution\n    crowding_distances = []\n    for i in range(len(solutions)):\n        left = max(0, i-1)\n        right = min(len(solutions)-1, i+1)\n        dist = 0\n        for obj_idx in range(2):\n            if objectives[right][obj_idx] == objectives[left][obj_idx]:\n                dist += 0\n            else:\n                dist += (objectives[right][obj_idx] - objectives[left][obj_idx]) / (max(obj[obj_idx] for obj in objectives) - min(obj[obj_idx] for obj in objectives))\n        crowding_distances.append(dist)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Swap two random edges\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7993304067712488,
            10.350490272045135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, obj in archive]\n    objectives = [obj for sol, obj in archive]\n\n    # Calculate crowding distance for each solution\n    crowding_distances = []\n    for i in range(len(solutions)):\n        left = max(0, i-1)\n        right = min(len(solutions)-1, i+1)\n        dist = 0\n        for obj_idx in range(2):\n            if objectives[right][obj_idx] == objectives[left][obj_idx]:\n                dist += 0\n            else:\n                dist += (objectives[right][obj_idx] - objectives[left][obj_idx]) / (max(obj[obj_idx] for obj in objectives) - min(obj[obj_idx] for obj in objectives))\n        crowding_distances.append(dist)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Swap two random edges\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with an adaptive segment relocation mechanism and guided node insertion, leveraging multi-objective distance metrics to balance exploration and exploitation while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Adaptive segment relocation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Calculate combined distance metric\n        combined_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            combined_dist[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                              distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) / 2\n\n        # Select segment based on distance metric\n        segment_size = min(3, n // 3)\n        segment_start = np.argmax(combined_dist)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Insert segment in a different position\n        insertion_pos = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([\n            new_solution[:segment_start], new_solution[segment_end:],\n            new_solution[insertion_pos:insertion_pos + segment_size], segment\n        ])\n\n    # Step 3: Guided node insertion\n    if n > 4:\n        # Calculate insertion cost for each node\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and insert the node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:],\n            [node_to_move]\n        ])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This novel heuristic combines Pareto-dominance-based selection with a multi-criteria adaptive tour fragmentation and reconstruction mechanism, leveraging objective-space distance metrics to dynamically balance segment relocation and guided node reinsertion while maintaining feasibility through multi-phase perturbation validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Multi-criteria tour fragmentation\n    n = len(selected_solution)\n    fragments = []\n    current_fragment = [selected_solution[0]]\n\n    for i in range(1, n):\n        prev = selected_solution[i-1]\n        curr = selected_solution[i]\n        next_node = selected_solution[(i+1)%n]\n\n        # Calculate multi-criteria distance\n        dist1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        dist2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        combined_dist = (dist1 + dist2) / 2\n\n        # Fragmentation criteria\n        if (combined_dist > np.mean([distance_matrix_1[prev, curr], distance_matrix_2[prev, curr]]) and\n            random.random() < 0.3):\n            fragments.append(current_fragment)\n            current_fragment = [curr]\n        else:\n            current_fragment.append(curr)\n\n    fragments.append(current_fragment)\n\n    # Step 3: Adaptive reconstruction\n    new_solution = []\n    for frag in fragments:\n        if len(frag) > 1 and random.random() < 0.4:\n            # Reverse fragment with probability\n            new_solution.extend(frag[::-1])\n        else:\n            new_solution.extend(frag)\n\n    # Step 4: Guided node reinsertion\n    if len(new_solution) > 4:\n        # Identify nodes with high combined distance\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                                distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Reinsert problematic nodes\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:],\n            [node_to_move]\n        ])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8809235291197882,
            2.8060140013694763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Multi-criteria tour fragmentation\n    n = len(selected_solution)\n    fragments = []\n    current_fragment = [selected_solution[0]]\n\n    for i in range(1, n):\n        prev = selected_solution[i-1]\n        curr = selected_solution[i]\n        next_node = selected_solution[(i+1)%n]\n\n        # Calculate multi-criteria distance\n        dist1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n        dist2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n        combined_dist = (dist1 + dist2) / 2\n\n        # Fragmentation criteria\n        if (combined_dist > np.mean([distance_matrix_1[prev, curr], distance_matrix_2[prev, curr]]) and\n            random.random() < 0.3):\n            fragments.append(current_fragment)\n            current_fragment = [curr]\n        else:\n            current_fragment.append(curr)\n\n    fragments.append(current_fragment)\n\n    # Step 3: Adaptive reconstruction\n    new_solution = []\n    for frag in fragments:\n        if len(frag) > 1 and random.random() < 0.4:\n            # Reverse fragment with probability\n            new_solution.extend(frag[::-1])\n        else:\n            new_solution.extend(frag)\n\n    # Step 4: Guided node reinsertion\n    if len(new_solution) > 4:\n        # Identify nodes with high combined distance\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                                distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Reinsert problematic nodes\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:],\n            [node_to_move]\n        ])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel hybrid local search combining adaptive segment rotation and guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best diversity score (crowding distance approximation)\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        left = archive[i-1][1] if i > 0 else (float('inf'), float('inf'))\n        right = archive[(i+1)%len(archive)][1] if len(archive) > 1 else (float('inf'), float('inf'))\n        dist = abs(obj[0] - left[0]) + abs(obj[0] - right[0]) + abs(obj[1] - left[1]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_solution = archive[np.argmax(crowding_distances)][0].copy()\n\n    # Apply hybrid local search: adaptive segment rotation and guided node insertion\n    n = len(selected_solution)\n    if n > 3:\n        # Adaptive segment rotation\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = selected_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.roll(segment, rotation)\n        selected_solution[a:b+1] = rotated_segment\n\n        # Guided node insertion based on distance reduction\n        if n > 4:\n            candidate_nodes = np.random.choice(range(n), size=min(3, n), replace=False)\n            best_improvement = 0\n            best_insertion = None\n\n            for node in candidate_nodes:\n                original_pos = np.where(selected_solution == selected_solution[node])[0][0]\n                for i in range(n):\n                    if i != original_pos and i != (original_pos + 1) % n:\n                        # Calculate potential improvement\n                        prev = selected_solution[i-1]\n                        curr = selected_solution[node]\n                        next_node = selected_solution[(i+1)%n]\n                        improvement = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] -\n                                     (distance_matrix_1[prev, selected_solution[original_pos]] +\n                                      distance_matrix_1[selected_solution[original_pos], next_node])) + \\\n                                    (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] -\n                                     (distance_matrix_2[prev, selected_solution[original_pos]] +\n                                      distance_matrix_2[selected_solution[original_pos], next_node]))\n\n                        if improvement < best_improvement:\n                            best_improvement = improvement\n                            best_insertion = (node, i)\n\n            if best_insertion is not None:\n                node, pos = best_insertion\n                original_pos = np.where(selected_solution == selected_solution[node])[0][0]\n                if pos > original_pos:\n                    selected_solution = np.concatenate([\n                        selected_solution[:original_pos],\n                        selected_solution[original_pos+1:pos+1],\n                        [selected_solution[original_pos]],\n                        selected_solution[pos+1:]\n                    ])\n                else:\n                    selected_solution = np.concatenate([\n                        selected_solution[:pos],\n                        [selected_solution[original_pos]],\n                        selected_solution[pos:original_pos],\n                        selected_solution[original_pos+1:]\n                    ])\n\n    return selected_solution\n\n",
        "score": [
            -0.9387755605783035,
            3.8596144318580627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best diversity score (crowding distance approximation)\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        left = archive[i-1][1] if i > 0 else (float('inf'), float('inf'))\n        right = archive[(i+1)%len(archive)][1] if len(archive) > 1 else (float('inf'), float('inf'))\n        dist = abs(obj[0] - left[0]) + abs(obj[0] - right[0]) + abs(obj[1] - left[1]) + abs(obj[1] - right[1])\n        crowding_distances.append(dist)\n\n    selected_solution = archive[np.argmax(crowding_distances)][0].copy()\n\n    # Apply hybrid local search: adaptive segment rotation and guided node insertion\n    n = len(selected_solution)\n    if n > 3:\n        # Adaptive segment rotation\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = selected_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.roll(segment, rotation)\n        selected_solution[a:b+1] = rotated_segment\n\n        # Guided node insertion based on distance reduction\n        if n > 4:\n            candidate_nodes = np.random.choice(range(n), size=min(3, n), replace=False)\n            best_improvement = 0\n            best_insertion = None\n\n            for node in candidate_nodes:\n                original_pos = np.where(selected_solution == selected_solution[node])[0][0]\n                for i in range(n):\n                    if i != original_pos and i != (original_pos + 1) % n:\n                        # Calculate potential improvement\n                        prev = selected_solution[i-1]\n                        curr = selected_solution[node]\n                        next_node = selected_solution[(i+1)%n]\n                        improvement = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] -\n                                     (distance_matrix_1[prev, selected_solution[original_pos]] +\n                                      distance_matrix_1[selected_solution[original_pos], next_node])) + \\\n                                    (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node] -\n                                     (distance_matrix_2[prev, selected_solution[original_pos]] +\n                                      distance_matrix_2[selected_solution[original_pos], next_node]))\n\n                        if improvement < best_improvement:\n                            best_improvement = improvement\n                            best_insertion = (node, i)\n\n            if best_insertion is not None:\n                node, pos = best_insertion\n                original_pos = np.where(selected_solution == selected_solution[node])[0][0]\n                if pos > original_pos:\n                    selected_solution = np.concatenate([\n                        selected_solution[:original_pos],\n                        selected_solution[original_pos+1:pos+1],\n                        [selected_solution[original_pos]],\n                        selected_solution[pos+1:]\n                    ])\n                else:\n                    selected_solution = np.concatenate([\n                        selected_solution[:pos],\n                        [selected_solution[original_pos]],\n                        selected_solution[pos:original_pos],\n                        selected_solution[original_pos+1:]\n                    ])\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and path-relinking operations, guided by a dynamic objective trade-off to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        weights = np.random.dirichlet([1, 1])\n        ranked_solutions = sorted(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n        selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n        # Path relinking\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8799174520803581,
            2.443426012992859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        weights = np.random.dirichlet([1, 1])\n        ranked_solutions = sorted(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n        selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n        # Path relinking\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest product of normalized objective values, then applies a hybrid local search combining edge reversal and node insertion to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest product of normalized objectives\n    max_product = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge reversal and node insertion\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge reversal\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion\n    if k != i and k != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8691639560662524,
            5.063209593296051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest product of normalized objectives\n    max_product = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge reversal and node insertion\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge reversal\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion\n    if k != i and k != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance-based selection of solutions with a hybrid of node-swap and segment-rotation operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment rotation operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        k = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, k)\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7604395845977738,
            2.275584638118744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment rotation operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        k = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, k)\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This novel local search heuristic combines Pareto-dominance based selection with a dynamic segment reversal and multi-objective edge exchange operation to enhance solution quality by balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance with diversity consideration\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest combined improvement potential\n        selected_solution = max(non_dominated, key=lambda x: np.sum(distance_matrix_1[x[0][:-1], x[0][1:]]) + np.sum(distance_matrix_2[x[0][:-1], x[0][1:]]))[0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+3, n-1))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Exchange edges between two random segments\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Exchange edges (i, i+1) and (j, j+1)\n        if i < j:\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n        else:\n            new_solution[j+1], new_solution[i] = new_solution[i], new_solution[j+1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to multi-objective edge swap\n        i, j = random.sample(range(n), 2)\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if cost1 + cost2 < distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6784198939319905,
            1.8903657793998718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance with diversity consideration\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest combined improvement potential\n        selected_solution = max(non_dominated, key=lambda x: np.sum(distance_matrix_1[x[0][:-1], x[0][1:]]) + np.sum(distance_matrix_2[x[0][:-1], x[0][1:]]))[0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+3, n-1))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Exchange edges between two random segments\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Exchange edges (i, i+1) and (j, j+1)\n        if i < j:\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n        else:\n            new_solution[j+1], new_solution[i] = new_solution[i], new_solution[j+1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to multi-objective edge swap\n        i, j = random.sample(range(n), 2)\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if cost1 + cost2 < distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm combines crowding-distance-based selection of solutions from the archive with a hybrid of edge-swapping and path-relinking operations, dynamically adjusting the exploration of the Pareto front by leveraging both objective-specific distance matrices to generate high-quality, feasible neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n = len(solutions)\n\n    if n == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Calculate crowding distance\n        crowding = np.zeros(n)\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, n-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Edge swapping operation\n        i = random.randint(0, n_nodes-1)\n        j = random.randint(0, n_nodes-1)\n        while j == i or j == (i + 1) % n_nodes:\n            j = random.randint(0, n_nodes-1)\n\n        # Swap edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path relinking operation\n        a = random.randint(0, n_nodes-1)\n        b = random.randint(0, n_nodes-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n_nodes-1)\n\n        # Calculate distances in both objectives\n        def calculate_distance(sol):\n            d1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n_nodes))\n            d2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n_nodes))\n            return (d1, d2)\n\n        current_dist = calculate_distance(new_solution)\n        best_sol = new_solution.copy()\n        best_dist = current_dist\n\n        # Try to improve by relinking\n        for k in range(a, b+1):\n            temp_sol = new_solution.copy()\n            temp_sol[k], temp_sol[(k+1)%n_nodes] = temp_sol[(k+1)%n_nodes], temp_sol[k]\n            temp_dist = calculate_distance(temp_sol)\n\n            # Accept if better in at least one objective\n            if (temp_dist[0] < current_dist[0] or temp_dist[1] < current_dist[1]):\n                new_solution = temp_sol.copy()\n                current_dist = temp_dist\n                if temp_dist[0] <= best_dist[0] and temp_dist[1] <= best_dist[1]:\n                    best_sol = temp_sol.copy()\n                    best_dist = temp_dist\n\n        new_solution = best_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n_nodes:\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5850947676558178,
            5.504147946834564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n = len(solutions)\n\n    if n == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Calculate crowding distance\n        crowding = np.zeros(n)\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, n-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Edge swapping operation\n        i = random.randint(0, n_nodes-1)\n        j = random.randint(0, n_nodes-1)\n        while j == i or j == (i + 1) % n_nodes:\n            j = random.randint(0, n_nodes-1)\n\n        # Swap edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path relinking operation\n        a = random.randint(0, n_nodes-1)\n        b = random.randint(0, n_nodes-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n_nodes-1)\n\n        # Calculate distances in both objectives\n        def calculate_distance(sol):\n            d1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n_nodes))\n            d2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n_nodes))\n            return (d1, d2)\n\n        current_dist = calculate_distance(new_solution)\n        best_sol = new_solution.copy()\n        best_dist = current_dist\n\n        # Try to improve by relinking\n        for k in range(a, b+1):\n            temp_sol = new_solution.copy()\n            temp_sol[k], temp_sol[(k+1)%n_nodes] = temp_sol[(k+1)%n_nodes], temp_sol[k]\n            temp_dist = calculate_distance(temp_sol)\n\n            # Accept if better in at least one objective\n            if (temp_dist[0] < current_dist[0] or temp_dist[1] < current_dist[1]):\n                new_solution = temp_sol.copy()\n                current_dist = temp_dist\n                if temp_dist[0] <= best_dist[0] and temp_dist[1] <= best_dist[1]:\n                    best_sol = temp_sol.copy()\n                    best_dist = temp_dist\n\n        new_solution = best_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n_nodes:\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This novel local search heuristic selects a solution from the archive based on a diversity-aware Pareto dominance criterion, then applies a hybrid of node-swap and segment-reversal operations guided by a dynamic objective trade-off to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on diversity-aware Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest diversity (furthest from centroid in objective space)\n        centroid = np.mean([obj for _, obj in archive], axis=0)\n        selected = max(non_dominated, key=lambda x: np.linalg.norm(np.array(x[1]) - centroid))\n        selected_solution = selected[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6992607458856428,
            3.687755823135376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on diversity-aware Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        # Select solution with highest diversity (furthest from centroid in objective space)\n        centroid = np.mean([obj for _, obj in archive], axis=0)\n        selected = max(non_dominated, key=lambda x: np.linalg.norm(np.array(x[1]) - centroid))\n        selected_solution = selected[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{A novel local search heuristic that combines a dynamic Pareto-frontier biased selection with a probabilistic segment-reinsertion and edge-flip hybrid operator, guided by adaptive objective weights to balance exploration and exploitation in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance and objective diversity\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) and not (other_obj[0] == obj[0] and other_obj[1] == obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Select solution with highest crowding distance in Pareto front\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[(i+1)%len(solutions)][1] if i < len(solutions)-1 else None\n            dist = 0\n            if left:\n                dist += abs(solutions[i][1][0] - left[0]) + abs(solutions[i][1][1] - left[1])\n            if right:\n                dist += abs(right[0] - solutions[i][1][0]) + abs(right[1] - solutions[i][1][1])\n            distances.append(dist)\n        return distances\n\n    sorted_front = sorted(pareto_front, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_front)\n    selected_idx = np.argmax(distances)\n    selected_solution = sorted_front[selected_idx][0].copy()\n\n    # Step 2: Apply probabilistic hybrid operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Probabilistic segment reinsertion\n        if random.random() < 0.7:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Probabilistic edge flip\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7673574153011964,
            2.7866061329841614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance and objective diversity\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) and not (other_obj[0] == obj[0] and other_obj[1] == obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Select solution with highest crowding distance in Pareto front\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[(i+1)%len(solutions)][1] if i < len(solutions)-1 else None\n            dist = 0\n            if left:\n                dist += abs(solutions[i][1][0] - left[0]) + abs(solutions[i][1][1] - left[1])\n            if right:\n                dist += abs(right[0] - solutions[i][1][0]) + abs(right[1] - solutions[i][1][1])\n            distances.append(dist)\n        return distances\n\n    sorted_front = sorted(pareto_front, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_front)\n    selected_idx = np.argmax(distances)\n    selected_solution = sorted_front[selected_idx][0].copy()\n\n    # Step 2: Apply probabilistic hybrid operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Probabilistic segment reinsertion\n        if random.random() < 0.7:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Probabilistic edge flip\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a dynamic segment rotation and edge insertion operation, guided by a multi-objective improvement metric to explore the solution space while maintaining diversity and quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding-distance metric\n    def calculate_crowding_distance(solutions):\n        n = len(solutions)\n        if n <= 2:\n            return [float('inf')] * n\n\n        objectives = np.array([obj for _, obj in solutions])\n        crowding_dist = np.zeros(n)\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n\n            crowding_dist[sorted_idx[0]] = float('inf')\n            crowding_dist[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, n-1):\n                crowding_dist[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        return crowding_dist\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment rotation and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to rotate\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = b - a + 1\n        rotation = random.randint(1, segment_length-1)\n        rotated_segment = np.roll(new_solution[a:b+1], rotation)\n        new_solution[a:b+1] = rotated_segment\n\n        # Randomly select an edge to insert elsewhere\n        i = random.randint(0, n-2)\n        removed_node = new_solution[i+1]\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5306887583293719,
            1.3809757828712463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding-distance metric\n    def calculate_crowding_distance(solutions):\n        n = len(solutions)\n        if n <= 2:\n            return [float('inf')] * n\n\n        objectives = np.array([obj for _, obj in solutions])\n        crowding_dist = np.zeros(n)\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n\n            crowding_dist[sorted_idx[0]] = float('inf')\n            crowding_dist[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, n-1):\n                crowding_dist[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        return crowding_dist\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment rotation and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to rotate\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = b - a + 1\n        rotation = random.randint(1, segment_length-1)\n        rotated_segment = np.roll(new_solution[a:b+1], rotation)\n        new_solution[a:b+1] = rotated_segment\n\n        # Randomly select an edge to insert elsewhere\n        i = random.randint(0, n-2)\n        removed_node = new_solution[i+1]\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This new algorithm employs a non-dominated sorting-based selection to prioritize solutions with Pareto-efficient trade-offs, followed by a hybrid of node insertion and path reversal operations, dynamically adjusting the search focus between objectives to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting to select Pareto-efficient solutions\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_obj in [o for s, o in archive if s is not sol]:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with dynamic objective bias\n    weights = np.random.dirichlet([1, 1])\n    selected = min(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 3: Hybrid local search (node insertion + path reversal)\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node and insert it at a random position\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Randomly reverse a segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7641185311824609,
            2.382253050804138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting to select Pareto-efficient solutions\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_obj in [o for s, o in archive if s is not sol]:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with dynamic objective bias\n    weights = np.random.dirichlet([1, 1])\n    selected = min(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 3: Hybrid local search (node insertion + path reversal)\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node and insert it at a random position\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Randomly reverse a segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm combines a dynamic objective-weighted selection with a novel hybrid local search that alternates between segment rotation and node reinsertion, guided by a probabilistic trade-off between objectives to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic objective-weighted selection\n    weights = (0.6 + 0.4 * np.random.random(), 0.4 + 0.6 * np.random.random())\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search: alternating segment rotation and node reinsertion\n    n = len(selected_solution)\n    if n > 3:\n        # Segment rotation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = selected_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        selected_solution[a:b+1] = rotated_segment\n\n        # Node reinsertion\n        i = np.random.randint(0, n)\n        node = selected_solution[i]\n        selected_solution = np.delete(selected_solution, i)\n        j = np.random.randint(0, n-1)\n        selected_solution = np.insert(selected_solution, j, node)\n\n    return selected_solution\n\n",
        "score": [
            -0.8247653318901398,
            1.717586874961853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic objective-weighted selection\n    weights = (0.6 + 0.4 * np.random.random(), 0.4 + 0.6 * np.random.random())\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search: alternating segment rotation and node reinsertion\n    n = len(selected_solution)\n    if n > 3:\n        # Segment rotation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = selected_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        selected_solution[a:b+1] = rotated_segment\n\n        # Node reinsertion\n        i = np.random.randint(0, n)\n        node = selected_solution[i]\n        selected_solution = np.delete(selected_solution, i)\n        j = np.random.randint(0, n-1)\n        selected_solution = np.insert(selected_solution, j, node)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{A novel local search heuristic that combines crowding-distance-based selection with a dynamic multi-segment perturbation strategy, which adaptively reorders and reinserts segments of varying lengths to explore the solution space while maintaining feasibility and balancing both objectives through objective-specific segment weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Dynamic multi-segment perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Determine segment lengths based on objective weights\n        obj_weights = archive[selected_idx][1]\n        total_weight = obj_weights[0] + obj_weights[1]\n        seg_length_1 = max(2, int(n * obj_weights[0] / total_weight))\n        seg_length_2 = max(2, n - seg_length_1)\n\n        # Select two segments of different lengths\n        a = random.randint(0, n - seg_length_1)\n        b = random.randint(0, n - seg_length_2)\n\n        # Ensure segments don't overlap too much\n        if abs(a - b) < min(seg_length_1, seg_length_2):\n            b = (a + seg_length_1) % n\n\n        # Extract segments\n        seg1 = new_solution[a:a+seg_length_1]\n        seg2 = new_solution[b:b+seg_length_2]\n\n        # Reinsert segments in reverse order\n        new_solution = np.concatenate([\n            new_solution[:a],\n            seg2[::-1],\n            new_solution[a+seg_length_1:b],\n            seg1[::-1],\n            new_solution[b+seg_length_2:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.786023828231757,
            3.1664336919784546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Dynamic multi-segment perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Determine segment lengths based on objective weights\n        obj_weights = archive[selected_idx][1]\n        total_weight = obj_weights[0] + obj_weights[1]\n        seg_length_1 = max(2, int(n * obj_weights[0] / total_weight))\n        seg_length_2 = max(2, n - seg_length_1)\n\n        # Select two segments of different lengths\n        a = random.randint(0, n - seg_length_1)\n        b = random.randint(0, n - seg_length_2)\n\n        # Ensure segments don't overlap too much\n        if abs(a - b) < min(seg_length_1, seg_length_2):\n            b = (a + seg_length_1) % n\n\n        # Extract segments\n        seg1 = new_solution[a:a+seg_length_1]\n        seg2 = new_solution[b:b+seg_length_2]\n\n        # Reinsert segments in reverse order\n        new_solution = np.concatenate([\n            new_solution[:a],\n            seg2[::-1],\n            new_solution[a+seg_length_1:b],\n            seg1[::-1],\n            new_solution[b+seg_length_2:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a hybrid segment reversal and edge exchange operation to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0 for _ in solutions]\n\n        objectives = [obj for _, obj in solutions]\n        objectives_sorted = sorted(objectives, key=lambda x: x[0])\n        distances = [0.0 for _ in solutions]\n\n        for i in range(2):\n            for j in range(1, len(solutions)-1):\n                if objectives_sorted[j][i] == objectives_sorted[0][i] or objectives_sorted[j][i] == objectives_sorted[-1][i]:\n                    distances[j] = float('inf')\n                else:\n                    distances[j] += (objectives_sorted[j+1][i] - objectives_sorted[j-1][i]) / (objectives_sorted[-1][i] - objectives_sorted[0][i])\n\n        # Combine distances for both objectives\n        combined_distances = [sum(distances) for _ in solutions]\n        return combined_distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance = max(crowding_distances)\n    selected_index = crowding_distances.index(max_distance) if max_distance > 0 else random.randint(0, len(archive)-1)\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply hybrid segment reversal and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly choose between segment reversal or edge exchange\n        if random.random() < 0.5:\n            # Segment reversal\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, n-1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge exchange\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while j == i or j == (i+1) % n:\n                j = random.randint(0, n-2)\n\n            # Swap edges (i, i+1) and (j, j+1)\n            if random.random() < 0.5:\n                new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9173281743910916,
            4.321955323219299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0 for _ in solutions]\n\n        objectives = [obj for _, obj in solutions]\n        objectives_sorted = sorted(objectives, key=lambda x: x[0])\n        distances = [0.0 for _ in solutions]\n\n        for i in range(2):\n            for j in range(1, len(solutions)-1):\n                if objectives_sorted[j][i] == objectives_sorted[0][i] or objectives_sorted[j][i] == objectives_sorted[-1][i]:\n                    distances[j] = float('inf')\n                else:\n                    distances[j] += (objectives_sorted[j+1][i] - objectives_sorted[j-1][i]) / (objectives_sorted[-1][i] - objectives_sorted[0][i])\n\n        # Combine distances for both objectives\n        combined_distances = [sum(distances) for _ in solutions]\n        return combined_distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance = max(crowding_distances)\n    selected_index = crowding_distances.index(max_distance) if max_distance > 0 else random.randint(0, len(archive)-1)\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply hybrid segment reversal and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly choose between segment reversal or edge exchange\n        if random.random() < 0.5:\n            # Segment reversal\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, n-1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Edge exchange\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while j == i or j == (i+1) % n:\n                j = random.randint(0, n-2)\n\n            # Swap edges (i, i+1) and (j, j+1)\n            if random.random() < 0.5:\n                new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel edge-swapping and segment-reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n    diversity_scores = np.sum(diversity_scores, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply edge-swapping and segment-reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two non-adjacent edges\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Reverse the segment between i and j\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        # Swap the edges at i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5573820994168244,
            1.8332723379135132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n    diversity_scores = np.sum(diversity_scores, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply edge-swapping and segment-reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two non-adjacent edges\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Reverse the segment between i and j\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        # Swap the edges at i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (0.5 for each objective) and applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.5 for each objective)\n    best_solution = max(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node insertion and segment rotation\n    if len(best_solution) > 3:\n        # Random node insertion\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        node = best_solution[i]\n        best_solution = np.delete(best_solution, i)\n        best_solution = np.insert(best_solution, j, node)\n\n        # Segment rotation between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        segment = best_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        segment = np.concatenate((segment[k:], segment[:k]))\n        best_solution[a:b+1] = segment\n\n    return best_solution\n\n",
        "score": [
            -0.8284484697593024,
            2.031362473964691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.5 for each objective)\n    best_solution = max(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node insertion and segment rotation\n    if len(best_solution) > 3:\n        # Random node insertion\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        node = best_solution[i]\n        best_solution = np.delete(best_solution, i)\n        best_solution = np.insert(best_solution, j, node)\n\n        # Segment rotation between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        segment = best_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        segment = np.concatenate((segment[k:], segment[:k]))\n        best_solution[a:b+1] = segment\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{A novel local search heuristic that combines crowding-distance-based selection with a dynamic segment inversion and adaptive edge replacement mechanism to enhance exploration while maintaining feasibility in the bi-objective TSP.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance\n    crowding_dist = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            if sorted_obj[-1] == sorted_obj[0]:\n                crowding_dist[sorted_idx[i]] += 0\n            else:\n                crowding_dist[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Dynamic segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and invert it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Step 3: Adaptive edge replacement\n    if n > 4:\n        # Identify edges with high combined distance\n        total_edge_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_edge_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr]\n\n        # Replace the most problematic edge\n        problematic_node = np.argmax(total_edge_dist)\n        neighbors = [i for i in range(n) if i != problematic_node and i != (problematic_node-1)%n and i != (problematic_node+1)%n]\n        if neighbors:\n            new_neighbor = random.choice(neighbors)\n            new_solution[(problematic_node+1)%n] = new_solution[new_neighbor]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8168035855741265,
            1.667228102684021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance\n    crowding_dist = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            if sorted_obj[-1] == sorted_obj[0]:\n                crowding_dist[sorted_idx[i]] += 0\n            else:\n                crowding_dist[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Dynamic segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and invert it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Step 3: Adaptive edge replacement\n    if n > 4:\n        # Identify edges with high combined distance\n        total_edge_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_edge_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr]\n\n        # Replace the most problematic edge\n        problematic_node = np.argmax(total_edge_dist)\n        neighbors = [i for i in range(n) if i != problematic_node and i != (problematic_node-1)%n and i != (problematic_node+1)%n]\n        if neighbors:\n            new_neighbor = random.choice(neighbors)\n            new_solution[(problematic_node+1)%n] = new_solution[new_neighbor]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{The new algorithm selects a solution from the archive based on the highest product of normalized objective values, then applies a hybrid local search combining 3-opt and a novel adaptive node sequence rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest product of normalized objectives\n    max_product = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 3-opt and adaptive node sequence rotation\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # 3-opt operation\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment3, segment1])\n\n    # Adaptive node sequence rotation\n    rotation_size = np.random.randint(2, min(5, n//2))\n    if rotation_size > 1:\n        start = np.random.randint(0, n - rotation_size)\n        new_solution[start:start+rotation_size] = np.roll(new_solution[start:start+rotation_size], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.8487285443058835,
            5.631515264511108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest product of normalized objectives\n    max_product = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_product = norm_obj1 * norm_obj2\n        if current_product > max_product:\n            max_product = current_product\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 3-opt and adaptive node sequence rotation\n    n = len(new_solution)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # 3-opt operation\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n else np.array([])\n    new_solution = np.concatenate([new_solution[:i], segment2, segment3, segment1])\n\n    # Adaptive node sequence rotation\n    rotation_size = np.random.randint(2, min(5, n//2))\n    if rotation_size > 1:\n        start = np.random.randint(0, n - rotation_size)\n        new_solution[start:start+rotation_size] = np.roll(new_solution[start:start+rotation_size], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The heuristic function selects a solution from the archive with the lowest sum of normalized objective values, then applies a novel local search combining segment reversal and partial path reversal to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    min_sum = float('inf')\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum < min_sum:\n            min_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Novel local search: segment reversal and partial path reversal\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c = np.random.randint(0, n)\n\n    # Segment reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Partial path reversal\n    if c < a or c > b:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c:][::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.6953341157326216,
            2.475608766078949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    min_sum = float('inf')\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum < min_sum:\n            min_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Novel local search: segment reversal and partial path reversal\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c = np.random.randint(0, n)\n\n    # Segment reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Partial path reversal\n    if c < a or c > b:\n        new_solution = np.concatenate([new_solution[:c], new_solution[c:][::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines Pareto-dominance-based selection with an adaptive segment relocation mechanism and guided node insertion, leveraging multi-objective distance metrics to balance exploration and exploitation while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Adaptive segment relocation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Calculate combined distance metric\n        combined_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            combined_dist[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                              distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) / 2\n\n        # Select segment based on distance metric\n        segment_size = min(3, n // 3)\n        segment_start = np.argmax(combined_dist)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Insert segment in a different position\n        insertion_pos = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([\n            new_solution[:segment_start], new_solution[segment_end:],\n            new_solution[insertion_pos:insertion_pos + segment_size], segment\n        ])\n\n    # Step 3: Guided node insertion\n    if n > 4:\n        # Calculate insertion cost for each node\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and insert the node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:],\n            [node_to_move]\n        ])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{A novel local search heuristic that combines tournament selection with a hybrid of adaptive segment rotation and guided node reinsertion, using a weighted multi-objective cost metric to balance exploration and exploitation while ensuring feasibility through constrained insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Tournament selection of promising solutions\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected_solution = min(selected, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Step 2: Hybrid segment rotation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate weighted cost metric\n        weighted_cost = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            weighted_cost[i] = 0.6 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.4 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and rotate segment\n        segment_size = min(4, n // 4)\n        segment_start = np.argmax(weighted_cost)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Rotate segment\n        rotation = random.randint(1, segment_size-1) if segment_size > 1 else 0\n        rotated_segment = np.roll(segment, rotation)\n\n        new_solution = np.concatenate([\n            new_solution[:segment_start], rotated_segment, new_solution[segment_end:]\n        ])\n\n    # Step 3: Guided node reinsertion with constraints\n    if n > 5:\n        # Calculate insertion cost with constraints\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.7 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.3 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8070282096401147,
            0.7267759442329407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Tournament selection of promising solutions\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected_solution = min(selected, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Step 2: Hybrid segment rotation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate weighted cost metric\n        weighted_cost = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            weighted_cost[i] = 0.6 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.4 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and rotate segment\n        segment_size = min(4, n // 4)\n        segment_start = np.argmax(weighted_cost)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Rotate segment\n        rotation = random.randint(1, segment_size-1) if segment_size > 1 else 0\n        rotated_segment = np.roll(segment, rotation)\n\n        new_solution = np.concatenate([\n            new_solution[:segment_start], rotated_segment, new_solution[segment_end:]\n        ])\n\n    # Step 3: Guided node reinsertion with constraints\n    if n > 5:\n        # Calculate insertion cost with constraints\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.7 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.3 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{A novel local search heuristic combines a diversity-aware selection with a multi-objective edge crossover operator to generate high-quality neighbors by intelligently combining segments from promising solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select two diverse solutions from the archive\n    if len(archive) > 1:\n        # Calculate diversity metric (sum of distances between objectives)\n        diversity_metrics = []\n        for i in range(len(archive)):\n            total_diversity = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_diversity += abs(archive[i][1][0] - archive[j][1][0]) + abs(archive[i][1][1] - archive[j][1][1])\n            diversity_metrics.append(total_diversity)\n\n        # Select the two most diverse solutions\n        selected_indices = sorted(range(len(diversity_metrics)), key=lambda i: diversity_metrics[i], reverse=True)[:2]\n        sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n    else:\n        sol1 = archive[0][0]\n        sol2 = archive[0][0]\n\n    # Step 2: Perform multi-objective edge crossover\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n    visited = set()\n    current_node = sol1[0]\n    new_solution[0] = current_node\n    visited.add(current_node)\n\n    for i in range(1, n):\n        # Alternate between the two solutions for selection\n        if i % 2 == 0:\n            # Select next node from sol1\n            for node in sol1:\n                if node not in visited:\n                    # Check if the edge would improve both objectives\n                    last_node = new_solution[i-1]\n                    if (distance_matrix_1[last_node, node] + distance_matrix_2[last_node, node] <\n                        distance_matrix_1[last_node, sol2[i]] + distance_matrix_2[last_node, sol2[i]]):\n                        current_node = node\n                        break\n        else:\n            # Select next node from sol2\n            for node in sol2:\n                if node not in visited:\n                    # Check if the edge would improve both objectives\n                    last_node = new_solution[i-1]\n                    if (distance_matrix_1[last_node, node] + distance_matrix_2[last_node, node] <\n                        distance_matrix_1[last_node, sol1[i]] + distance_matrix_2[last_node, sol1[i]]):\n                        current_node = node\n                        break\n\n        # Fallback to the original solution if no improvement found\n        if current_node in visited:\n            for node in sol1:\n                if node not in visited:\n                    current_node = node\n                    break\n\n        new_solution[i] = current_node\n        visited.add(current_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4242946684180109,
            4.15789657831192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select two diverse solutions from the archive\n    if len(archive) > 1:\n        # Calculate diversity metric (sum of distances between objectives)\n        diversity_metrics = []\n        for i in range(len(archive)):\n            total_diversity = 0\n            for j in range(len(archive)):\n                if i != j:\n                    total_diversity += abs(archive[i][1][0] - archive[j][1][0]) + abs(archive[i][1][1] - archive[j][1][1])\n            diversity_metrics.append(total_diversity)\n\n        # Select the two most diverse solutions\n        selected_indices = sorted(range(len(diversity_metrics)), key=lambda i: diversity_metrics[i], reverse=True)[:2]\n        sol1, sol2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n    else:\n        sol1 = archive[0][0]\n        sol2 = archive[0][0]\n\n    # Step 2: Perform multi-objective edge crossover\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n    visited = set()\n    current_node = sol1[0]\n    new_solution[0] = current_node\n    visited.add(current_node)\n\n    for i in range(1, n):\n        # Alternate between the two solutions for selection\n        if i % 2 == 0:\n            # Select next node from sol1\n            for node in sol1:\n                if node not in visited:\n                    # Check if the edge would improve both objectives\n                    last_node = new_solution[i-1]\n                    if (distance_matrix_1[last_node, node] + distance_matrix_2[last_node, node] <\n                        distance_matrix_1[last_node, sol2[i]] + distance_matrix_2[last_node, sol2[i]]):\n                        current_node = node\n                        break\n        else:\n            # Select next node from sol2\n            for node in sol2:\n                if node not in visited:\n                    # Check if the edge would improve both objectives\n                    last_node = new_solution[i-1]\n                    if (distance_matrix_1[last_node, node] + distance_matrix_2[last_node, node] <\n                        distance_matrix_1[last_node, sol1[i]] + distance_matrix_2[last_node, sol1[i]]):\n                        current_node = node\n                        break\n\n        # Fallback to the original solution if no improvement found\n        if current_node in visited:\n            for node in sol1:\n                if node not in visited:\n                    current_node = node\n                    break\n\n        new_solution[i] = current_node\n        visited.add(current_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a combination of crowding distance and objective trade-off, then applies a hybrid local search combining adaptive node relocation and segment rotation to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select solution based on crowding distance and objective trade-off\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    crowding = np.zeros(len(solutions))\n    for m in range(2):\n        sorted_idx = np.argsort([obj[m] for obj in objectives])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        f_range = objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m]\n        if f_range == 0:\n            continue\n        for i in range(1, len(solutions)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / f_range\n\n    # Select solution with highest crowding distance (diverse) or best trade-off\n    best_idx = np.argmax(crowding)\n    if np.random.random() < 0.3:  # 30% chance to explore trade-off\n        best_idx = np.argmin([0.6*obj[0] + 0.4*obj[1] for obj in objectives])\n\n    selected_solution = solutions[best_idx].copy()\n\n    # Step 2: Apply adaptive hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive node relocation\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n:\n                j = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        # Segment rotation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8523221833888763,
            2.7248887419700623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select solution based on crowding distance and objective trade-off\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    crowding = np.zeros(len(solutions))\n    for m in range(2):\n        sorted_idx = np.argsort([obj[m] for obj in objectives])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        f_range = objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m]\n        if f_range == 0:\n            continue\n        for i in range(1, len(solutions)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / f_range\n\n    # Select solution with highest crowding distance (diverse) or best trade-off\n    best_idx = np.argmax(crowding)\n    if np.random.random() < 0.3:  # 30% chance to explore trade-off\n        best_idx = np.argmin([0.6*obj[0] + 0.4*obj[1] for obj in objectives])\n\n    selected_solution = solutions[best_idx].copy()\n\n    # Step 2: Apply adaptive hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive node relocation\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n:\n                j = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        # Segment rotation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm combines Pareto-optimal solution selection with a multi-segment reassembly mechanism that dynamically adapts segment lengths based on their combined objective impact, using a guided crossover approach that preserves elite segments while introducing diversity through probabilistic segment swaps.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-optimal solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Identify high-impact segments\n    n = len(base_solution)\n    segment_lengths = [max(2, n//k) for k in range(2, 6)]  # Test different segment lengths\n    best_segments = []\n\n    for length in segment_lengths:\n        for start in range(n - length + 1):\n            segment = base_solution[start:start+length]\n            cost = sum(distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]\n                      for i in range(length-1))\n            best_segments.append((cost, start, length, segment))\n\n    if not best_segments:\n        return base_solution\n\n    # Step 3: Select top segments and perform reassembly\n    best_segments.sort()\n    selected_segments = [s[3] for s in best_segments[:min(3, len(best_segments))]]\n\n    # Create new solution by interleaving selected segments\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for seg in selected_segments:\n        new_solution.extend(seg)\n        remaining_nodes -= set(seg)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This new algorithm uses a dynamic segment clustering approach that identifies and recombines high-impact node clusters based on their combined objective contribution, employing a probabilistic segment insertion strategy that balances exploration and exploitation by adaptively adjusting cluster sizes and insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select a solution with high combined objective diversity\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([o[0] for o in objectives])\n    mean_obj2 = np.mean([o[1] for o in objectives])\n    selected_solution = None\n    max_diversity = -1\n\n    for sol, obj in archive:\n        diversity = abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Step 2: Identify high-impact clusters\n    n = len(selected_solution)\n    cluster_sizes = [max(2, n//k) for k in range(3, 7)]\n    best_clusters = []\n\n    for size in cluster_sizes:\n        for start in range(n - size + 1):\n            cluster = selected_solution[start:start+size]\n            cost = sum(distance_matrix_1[cluster[i], cluster[i+1]] + distance_matrix_2[cluster[i], cluster[i+1]]\n                      for i in range(size-1))\n            best_clusters.append((cost, start, size, cluster))\n\n    if not best_clusters:\n        return selected_solution\n\n    # Step 3: Select top clusters and perform probabilistic insertion\n    best_clusters.sort()\n    selected_clusters = [c[3] for c in best_clusters[:min(2, len(best_clusters))]]\n\n    # Create new solution by inserting clusters at random positions\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for cluster in selected_clusters:\n        if len(new_solution) == 0:\n            new_solution.extend(cluster)\n        else:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = new_solution[:insert_pos] + list(cluster) + new_solution[insert_pos:]\n        remaining_nodes -= set(cluster)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.9690751567130645,
            7.869211196899414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select a solution with high combined objective diversity\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([o[0] for o in objectives])\n    mean_obj2 = np.mean([o[1] for o in objectives])\n    selected_solution = None\n    max_diversity = -1\n\n    for sol, obj in archive:\n        diversity = abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Step 2: Identify high-impact clusters\n    n = len(selected_solution)\n    cluster_sizes = [max(2, n//k) for k in range(3, 7)]\n    best_clusters = []\n\n    for size in cluster_sizes:\n        for start in range(n - size + 1):\n            cluster = selected_solution[start:start+size]\n            cost = sum(distance_matrix_1[cluster[i], cluster[i+1]] + distance_matrix_2[cluster[i], cluster[i+1]]\n                      for i in range(size-1))\n            best_clusters.append((cost, start, size, cluster))\n\n    if not best_clusters:\n        return selected_solution\n\n    # Step 3: Select top clusters and perform probabilistic insertion\n    best_clusters.sort()\n    selected_clusters = [c[3] for c in best_clusters[:min(2, len(best_clusters))]]\n\n    # Create new solution by inserting clusters at random positions\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for cluster in selected_clusters:\n        if len(new_solution) == 0:\n            new_solution.extend(cluster)\n        else:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = new_solution[:insert_pos] + list(cluster) + new_solution[insert_pos:]\n        remaining_nodes -= set(cluster)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines Pareto-optimal solution selection with a multi-segment reassembly mechanism that dynamically adapts segment lengths based on their combined objective impact, using a guided crossover approach that preserves elite segments while introducing diversity through probabilistic segment swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-optimal solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Identify high-impact segments\n    n = len(base_solution)\n    segment_lengths = [max(2, n//k) for k in range(2, 6)]  # Test different segment lengths\n    best_segments = []\n\n    for length in segment_lengths:\n        for start in range(n - length + 1):\n            segment = base_solution[start:start+length]\n            cost = sum(distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]\n                      for i in range(length-1))\n            best_segments.append((cost, start, length, segment))\n\n    if not best_segments:\n        return base_solution\n\n    # Step 3: Select top segments and perform reassembly\n    best_segments.sort()\n    selected_segments = [s[3] for s in best_segments[:min(3, len(best_segments))]]\n\n    # Create new solution by interleaving selected segments\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for seg in selected_segments:\n        new_solution.extend(seg)\n        remaining_nodes -= set(seg)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This new algorithm combines Pareto-dominant segment extraction with an adaptive multi-objective crossover that dynamically balances segment contributions based on their normalized objective impacts, using a guided reassembly process that preserves segment topologies while introducing diversity through probabilistic segment rotations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-dominant solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Extract objective-balanced segments\n    n = len(base_solution)\n    segment_lengths = [max(2, n//k) for k in range(2, 6)]\n    segments = []\n\n    for length in segment_lengths:\n        for start in range(n - length + 1):\n            segment = base_solution[start:start+length]\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(length-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(length-1))\n            normalized_cost = (cost1 + cost2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2))\n            segments.append((normalized_cost, start, length, segment))\n\n    if not segments:\n        return base_solution\n\n    # Step 3: Select top segments and perform adaptive reassembly\n    segments.sort()\n    selected_segments = [s[3] for s in segments[:min(3, len(segments))]]\n\n    # Create new solution by rotating and interleaving segments\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for seg in selected_segments:\n        if random.random() > 0.5:\n            seg = seg[::-1]  # Random rotation\n        new_solution.extend(seg)\n        remaining_nodes -= set(seg)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.892037853569821,
            14.874352216720581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-dominant solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Extract objective-balanced segments\n    n = len(base_solution)\n    segment_lengths = [max(2, n//k) for k in range(2, 6)]\n    segments = []\n\n    for length in segment_lengths:\n        for start in range(n - length + 1):\n            segment = base_solution[start:start+length]\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(length-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(length-1))\n            normalized_cost = (cost1 + cost2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2))\n            segments.append((normalized_cost, start, length, segment))\n\n    if not segments:\n        return base_solution\n\n    # Step 3: Select top segments and perform adaptive reassembly\n    segments.sort()\n    selected_segments = [s[3] for s in segments[:min(3, len(segments))]]\n\n    # Create new solution by rotating and interleaving segments\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for seg in selected_segments:\n        if random.random() > 0.5:\n            seg = seg[::-1]  # Random rotation\n        new_solution.extend(seg)\n        remaining_nodes -= set(seg)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This novel local search heuristic combines a crowding-distance-based selection of solutions from the archive with a hybrid of edge-swapping and path-reversal operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility through a novel validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        obj1 = [o[0] for o in objectives]\n        obj2 = [o[1] for o in objectives]\n\n        distances = [0.0] * len(solutions)\n\n        for i in range(2):\n            sorted_indices = sorted(range(len(solutions)), key=lambda k: objectives[k][i])\n            distances[sorted_indices[0]] = float('inf')\n            distances[sorted_indices[-1]] = float('inf')\n\n            if objectives[sorted_indices[-1]][i] == objectives[sorted_indices[0]][i]:\n                continue\n\n            norm = objectives[sorted_indices[-1]][i] - objectives[sorted_indices[0]][i]\n            for j in range(1, len(solutions)-1):\n                distances[sorted_indices[j]] += (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / norm\n\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = max(range(len(archive)), key=lambda i: crowding_distances[i])\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge-swapping and path-reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n or j == (i-1) % n:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i, i+1) and (j, j+1)\n        if i < j:\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n        else:\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Novel validation mechanism\n    def is_valid(solution):\n        if len(np.unique(solution)) != len(solution):\n            return False\n        return True\n\n    if not is_valid(new_solution):\n        # Fallback to random segment reversal if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.53353445486886,
            2.0756205320358276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        obj1 = [o[0] for o in objectives]\n        obj2 = [o[1] for o in objectives]\n\n        distances = [0.0] * len(solutions)\n\n        for i in range(2):\n            sorted_indices = sorted(range(len(solutions)), key=lambda k: objectives[k][i])\n            distances[sorted_indices[0]] = float('inf')\n            distances[sorted_indices[-1]] = float('inf')\n\n            if objectives[sorted_indices[-1]][i] == objectives[sorted_indices[0]][i]:\n                continue\n\n            norm = objectives[sorted_indices[-1]][i] - objectives[sorted_indices[0]][i]\n            for j in range(1, len(solutions)-1):\n                distances[sorted_indices[j]] += (objectives[sorted_indices[j+1]][i] - objectives[sorted_indices[j-1]][i]) / norm\n\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = max(range(len(archive)), key=lambda i: crowding_distances[i])\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge-swapping and path-reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n or j == (i-1) % n:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i, i+1) and (j, j+1)\n        if i < j:\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n        else:\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Novel validation mechanism\n    def is_valid(solution):\n        if len(np.unique(solution)) != len(solution):\n            return False\n        return True\n\n    if not is_valid(new_solution):\n        # Fallback to random segment reversal if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of edge-swapping and path-reversal operations, guided by a dynamic objective weighting to explore the Pareto front while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    def crowding_distance(obj_values):\n        distances = np.zeros(len(obj_values))\n        for m in range(len(obj_values[0])):\n            sorted_idx = np.argsort([obj[m] for obj in obj_values])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            if len(sorted_idx) > 2:\n                min_obj = obj_values[sorted_idx[0]][m]\n                max_obj = obj_values[sorted_idx[-1]][m]\n                for i in range(1, len(sorted_idx)-1):\n                    distances[sorted_idx[i]] += (obj_values[sorted_idx[i+1]][m] - obj_values[sorted_idx[i-1]][m]) / (max_obj - min_obj)\n        return distances\n\n    obj_values = [obj for _, obj in archive]\n    distances = crowding_distance(obj_values)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.43326913991289684,
            1.7068216800689697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    def crowding_distance(obj_values):\n        distances = np.zeros(len(obj_values))\n        for m in range(len(obj_values[0])):\n            sorted_idx = np.argsort([obj[m] for obj in obj_values])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            if len(sorted_idx) > 2:\n                min_obj = obj_values[sorted_idx[0]][m]\n                max_obj = obj_values[sorted_idx[-1]][m]\n                for i in range(1, len(sorted_idx)-1):\n                    distances[sorted_idx[i]] += (obj_values[sorted_idx[i+1]][m] - obj_values[sorted_idx[i-1]][m]) / (max_obj - min_obj)\n        return distances\n\n    obj_values = [obj for _, obj in archive]\n    distances = crowding_distance(obj_values)\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This novel local search heuristic combines a crowding-distance-based selection of solutions from the archive, followed by a hybrid of edge-swap and path-relinking operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    if len(solutions) == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Calculate crowding distances\n        sorted_indices_1 = np.argsort([obj[0] for obj in objectives])\n        sorted_indices_2 = np.argsort([obj[1] for obj in objectives])\n\n        crowding_distances = np.zeros(len(solutions))\n        for i in range(len(solutions)):\n            if i == 0 or i == len(solutions) - 1:\n                crowding_distances[i] = float('inf')\n            else:\n                dist1 = objectives[sorted_indices_1[i+1]][0] - objectives[sorted_indices_1[i-1]][0]\n                dist2 = objectives[sorted_indices_2[i+1]][1] - objectives[sorted_indices_2[i-1]][1]\n                crowding_distances[i] = dist1 + dist2\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge swap operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6557980777261656,
            1.5850738883018494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    if len(solutions) == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Calculate crowding distances\n        sorted_indices_1 = np.argsort([obj[0] for obj in objectives])\n        sorted_indices_2 = np.argsort([obj[1] for obj in objectives])\n\n        crowding_distances = np.zeros(len(solutions))\n        for i in range(len(solutions)):\n            if i == 0 or i == len(solutions) - 1:\n                crowding_distances[i] = float('inf')\n            else:\n                dist1 = objectives[sorted_indices_1[i+1]][0] - objectives[sorted_indices_1[i-1]][0]\n                dist2 = objectives[sorted_indices_2[i+1]][1] - objectives[sorted_indices_2[i-1]][1]\n                crowding_distances[i] = dist1 + dist2\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge swap operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{A novel local search heuristic that combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9747359660521875,
            2.3159790635108948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{A novel local search heuristic that combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9747359660521875,
            2.3159790635108948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of crowding distance and objective diversity metrics, then applies a novel segment-based crossover and adaptive mutation operator to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution based on crowding distance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    if n_solutions == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance\n        crowding = np.zeros(n_solutions)\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, n_solutions - 1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        # Calculate objective diversity\n        diversity = np.zeros(n_solutions)\n        for i in range(n_solutions):\n            diversity[i] = np.sum(np.abs(objectives[i] - objectives)) / (n_solutions - 1)\n\n        # Combine metrics\n        scores = crowding + diversity\n        selected_idx = np.argmax(scores)\n        selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Segment-based crossover and adaptive mutation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based crossover\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - 3)\n        seg1_end = random.randint(seg1_start + 1, n - 2)\n        seg2_start = random.randint(0, n - (seg1_end - seg1_start + 1) - 1)\n        seg2_end = seg2_start + (seg1_end - seg1_start)\n\n        # Extract segments\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Adaptive mutation\n    if random.random() < 0.3:  # 30% chance of mutation\n        # Calculate node importance based on distance contributions\n        importance = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            importance[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Mutate the least important node\n        least_important = np.argmin(importance)\n        new_pos = random.randint(0, n-1)\n        if new_pos != least_important:\n            # Move node to new position\n            node = new_solution[least_important]\n            new_solution = np.concatenate([\n                new_solution[:least_important],\n                new_solution[least_important+1:new_pos+1],\n                [node],\n                new_solution[new_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6561715483377706,
            2.8367412090301514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution based on crowding distance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    if n_solutions == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distance\n        crowding = np.zeros(n_solutions)\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, n_solutions - 1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        # Calculate objective diversity\n        diversity = np.zeros(n_solutions)\n        for i in range(n_solutions):\n            diversity[i] = np.sum(np.abs(objectives[i] - objectives)) / (n_solutions - 1)\n\n        # Combine metrics\n        scores = crowding + diversity\n        selected_idx = np.argmax(scores)\n        selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Segment-based crossover and adaptive mutation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-based crossover\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - 3)\n        seg1_end = random.randint(seg1_start + 1, n - 2)\n        seg2_start = random.randint(0, n - (seg1_end - seg1_start + 1) - 1)\n        seg2_end = seg2_start + (seg1_end - seg1_start)\n\n        # Extract segments\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Adaptive mutation\n    if random.random() < 0.3:  # 30% chance of mutation\n        # Calculate node importance based on distance contributions\n        importance = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            importance[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Mutate the least important node\n        least_important = np.argmin(importance)\n        new_pos = random.randint(0, n-1)\n        if new_pos != least_important:\n            # Move node to new position\n            node = new_solution[least_important]\n            new_solution = np.concatenate([\n                new_solution[:least_important],\n                new_solution[least_important+1:new_pos+1],\n                [node],\n                new_solution[new_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This novel heuristic combines Pareto-based solution selection with a multi-criteria edge exchange mechanism that dynamically evaluates and replaces edges based on their contribution to both objectives, while maintaining feasibility through a constrained swap-and-rearrange operation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-criteria edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Evaluate edges based on combined contribution to both objectives\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            edge_scores[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) * 0.5 + \\\n                            (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) * 0.5\n\n        # Select edges with worst combined contribution\n        worst_edges = np.argsort(edge_scores)[:max(2, n//5)]\n        for edge in worst_edges:\n            # Find a compatible replacement edge\n            candidate_pos = random.randint(0, n-1)\n            while candidate_pos == edge or candidate_pos == (edge+1)%n or candidate_pos == (edge-1)%n:\n                candidate_pos = random.randint(0, n-1)\n\n            # Perform constrained swap-and-rearrange\n            if edge < candidate_pos:\n                new_solution = np.concatenate([\n                    new_solution[:edge],\n                    new_solution[candidate_pos:candidate_pos+1],\n                    new_solution[edge+1:candidate_pos],\n                    new_solution[edge:edge+1],\n                    new_solution[candidate_pos+1:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:candidate_pos],\n                    new_solution[edge:edge+1],\n                    new_solution[candidate_pos:edge],\n                    new_solution[edge+1:candidate_pos+1],\n                    new_solution[edge+1:]\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7424779638377982,
            2.6784021854400635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-criteria edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Evaluate edges based on combined contribution to both objectives\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            edge_scores[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) * 0.5 + \\\n                            (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) * 0.5\n\n        # Select edges with worst combined contribution\n        worst_edges = np.argsort(edge_scores)[:max(2, n//5)]\n        for edge in worst_edges:\n            # Find a compatible replacement edge\n            candidate_pos = random.randint(0, n-1)\n            while candidate_pos == edge or candidate_pos == (edge+1)%n or candidate_pos == (edge-1)%n:\n                candidate_pos = random.randint(0, n-1)\n\n            # Perform constrained swap-and-rearrange\n            if edge < candidate_pos:\n                new_solution = np.concatenate([\n                    new_solution[:edge],\n                    new_solution[candidate_pos:candidate_pos+1],\n                    new_solution[edge+1:candidate_pos],\n                    new_solution[edge:edge+1],\n                    new_solution[candidate_pos+1:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:candidate_pos],\n                    new_solution[edge:edge+1],\n                    new_solution[candidate_pos:edge],\n                    new_solution[edge+1:candidate_pos+1],\n                    new_solution[edge+1:]\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This novel local search heuristic selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid of edge rotation and segment reversal operations to generate a neighbor solution while dynamically balancing the trade-off between objectives to explore the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on weighted objective combination\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge rotation operation\n        a, b, c = random.sample(range(n), 3)\n        segment = new_solution[a:b+1]\n        rotated = np.roll(segment, 1)\n        new_solution[a:b+1] = rotated\n\n        # Segment reversal operation\n        x, y = sorted(random.sample(range(n), 2))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.748072032461563,
            2.2096036672592163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on weighted objective combination\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge rotation operation\n        a, b, c = random.sample(range(n), 3)\n        segment = new_solution[a:b+1]\n        rotated = np.roll(segment, 1)\n        new_solution[a:b+1] = rotated\n\n        # Segment reversal operation\n        x, y = sorted(random.sample(range(n), 2))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm combines a crowding-distance-based selection of solutions from the archive with an adaptive segment reversal and node reinsertion operator, dynamically balancing the exploration of both objective spaces to generate high-quality, diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Compute crowding distance\n    n = len(archive)\n    crowding = np.zeros(n)\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, n-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply adaptive segment reversal and reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n        # Node reinsertion with objective-aware placement\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Evaluate possible insertion positions\n        best_pos = 0\n        best_score = float('inf')\n        for i in range(len(new_solution)):\n            temp = np.insert(new_solution, i, node)\n            cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            score = 0.5 * (cost1 + cost2)  # Simple weighted sum for placement\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5960706778561087,
            14.39599323272705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Compute crowding distance\n    n = len(archive)\n    crowding = np.zeros(n)\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, n-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply adaptive segment reversal and reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n        # Node reinsertion with objective-aware placement\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Evaluate possible insertion positions\n        best_pos = 0\n        best_score = float('inf')\n        for i in range(len(new_solution)):\n            temp = np.insert(new_solution, i, node)\n            cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            score = 0.5 * (cost1 + cost2)  # Simple weighted sum for placement\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{A novel local search heuristic that combines a crowding-distance-based selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using crowding distance\n    def crowding_distance(solutions):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        distances = []\n        objectives = [obj for _, obj in solutions]\n        for i in range(len(objectives)):\n            obj = objectives[i]\n            left = objectives[i-1] if i > 0 else objectives[0]\n            right = objectives[(i+1)%len(objectives)] if i < len(objectives)-1 else objectives[-1]\n            dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(archive)\n    max_distance = max(distances)\n    candidates = [archive[i] for i in range(len(archive)) if distances[i] == max_distance]\n    selected_solution = random.choice(candidates)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7510827882825797,
            2.234042763710022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using crowding distance\n    def crowding_distance(solutions):\n        if len(solutions) <= 2:\n            return [1.0] * len(solutions)\n        distances = []\n        objectives = [obj for _, obj in solutions]\n        for i in range(len(objectives)):\n            obj = objectives[i]\n            left = objectives[i-1] if i > 0 else objectives[0]\n            right = objectives[(i+1)%len(objectives)] if i < len(objectives)-1 else objectives[-1]\n            dist = abs(obj[0] - left[0]) + abs(obj[1] - left[1]) + abs(obj[0] - right[0]) + abs(obj[1] - right[1])\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(archive)\n    max_distance = max(distances)\n    candidates = [archive[i] for i in range(len(archive)) if distances[i] == max_distance]\n    selected_solution = random.choice(candidates)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This novel local search heuristic combines a crowding-distance-based selection of solutions from the archive with a hybrid of node-sequence-reversal and segment-reallocation operations, guided by an adaptive weighted combination of the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = np.array([obj for _, obj in solutions])\n        crowding = np.zeros(len(solutions))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            f_min = objectives[sorted_idx[0], m]\n            f_max = objectives[sorted_idx[-1], m]\n\n            if f_max == f_min:\n                continue\n\n            for i in range(1, len(solutions)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (f_max - f_min)\n\n        return crowding\n\n    crowding = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-sequence-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment-reallocation operation\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        while abs(d - c) < 2 or (c <= a <= d and c <= b <= d):\n            c = random.randint(0, n-1)\n            d = random.randint(0, n-1)\n        if c > d:\n            c, d = d, c\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5510554684467049,
            2.5362963676452637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = np.array([obj for _, obj in solutions])\n        crowding = np.zeros(len(solutions))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            f_min = objectives[sorted_idx[0], m]\n            f_max = objectives[sorted_idx[-1], m]\n\n            if f_max == f_min:\n                continue\n\n            for i in range(1, len(solutions)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (f_max - f_min)\n\n        return crowding\n\n    crowding = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-sequence-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment-reallocation operation\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        while abs(d - c) < 2 or (c <= a <= d and c <= b <= d):\n            c = random.randint(0, n-1)\n            d = random.randint(0, n-1)\n        if c > d:\n            c, d = d, c\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value in either space, then applies a novel hybrid local search combining edge insertion and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with worst objective in either space (to encourage diversity)\n    worst_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Apply hybrid local search: edge insertion and path reversal\n    if len(worst_solution) > 3:\n        # Edge insertion: remove a random edge and reinsert it\n        i = np.random.randint(1, len(worst_solution)-1)\n        node = worst_solution[i]\n        worst_solution = np.concatenate([worst_solution[:i], worst_solution[i+1:]])\n        insert_pos = np.random.randint(1, len(worst_solution)-1)\n        worst_solution = np.insert(worst_solution, insert_pos, node)\n\n        # Path reversal: reverse a random segment\n        a, b = sorted(np.random.choice(len(worst_solution)-1, size=2, replace=False))\n        worst_solution[a:b+1] = worst_solution[a:b+1][::-1]\n\n    return worst_solution\n\n",
        "score": [
            -0.9014992861691883,
            2.2037832140922546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with worst objective in either space (to encourage diversity)\n    worst_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Apply hybrid local search: edge insertion and path reversal\n    if len(worst_solution) > 3:\n        # Edge insertion: remove a random edge and reinsert it\n        i = np.random.randint(1, len(worst_solution)-1)\n        node = worst_solution[i]\n        worst_solution = np.concatenate([worst_solution[:i], worst_solution[i+1:]])\n        insert_pos = np.random.randint(1, len(worst_solution)-1)\n        worst_solution = np.insert(worst_solution, insert_pos, node)\n\n        # Path reversal: reverse a random segment\n        a, b = sorted(np.random.choice(len(worst_solution)-1, size=2, replace=False))\n        worst_solution[a:b+1] = worst_solution[a:b+1][::-1]\n\n    return worst_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{A novel local search heuristic that combines a crowding-distance based selection with a dynamic path reversal and edge exchange operation to enhance both exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        distances = [0.0] * len(objectives)\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[-1]][m] == objectives[sorted_idx[0]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance_idx = np.argmax(crowding_distances)\n    selected_solution = archive[max_distance_idx][0].copy()\n\n    # Step 2: Apply dynamic path reversal and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Reverse a random segment\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Exchange two random edges\n        a, b = random.sample(range(n), 2)\n        c, d = random.sample(range(n), 2)\n        while abs(a - b) <= 1 or abs(c - d) <= 1:\n            a, b = random.sample(range(n), 2)\n            c, d = random.sample(range(n), 2)\n\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Extract segments\n        seg1 = new_solution[a:b+1]\n        seg2 = new_solution[c:d+1]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:a],\n            seg2,\n            new_solution[b+1:c],\n            seg1,\n            new_solution[d+1:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5708365431625272,
            1.0448212027549744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [1.0] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        distances = [0.0] * len(objectives)\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[-1]][m] == objectives[sorted_idx[0]][m]:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance_idx = np.argmax(crowding_distances)\n    selected_solution = archive[max_distance_idx][0].copy()\n\n    # Step 2: Apply dynamic path reversal and edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Reverse a random segment\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Exchange two random edges\n        a, b = random.sample(range(n), 2)\n        c, d = random.sample(range(n), 2)\n        while abs(a - b) <= 1 or abs(c - d) <= 1:\n            a, b = random.sample(range(n), 2)\n            c, d = random.sample(range(n), 2)\n\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Extract segments\n        seg1 = new_solution[a:b+1]\n        seg2 = new_solution[c:d+1]\n\n        # Swap segments\n        new_solution = np.concatenate([\n            new_solution[:a],\n            seg2,\n            new_solution[b+1:c],\n            seg1,\n            new_solution[d+1:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{A novel local search heuristic that combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.86685370011563,
            1.7223145961761475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This novel algorithm combines a multi-objective diversity-based selection with a hybrid of edge reversal and node chain relocation operations, guided by a dynamic objective weighting that adapts to the archive's Pareto front structure to explore under-represented regions with targeted local improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    centroid = np.mean(objectives, axis=0)\n    selected_idx = np.argmax(np.linalg.norm(objectives - centroid, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge reversal operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node chain relocation\n        k = random.randint(1, n-3)\n        chain_length = random.randint(2, min(4, n-k-1))\n        chain = new_solution[k:k+chain_length]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+chain_length:], chain])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to node insertion if invalid\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n        new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    return new_solution\n\n",
        "score": [
            -0.546343848595819,
            2.464282512664795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    centroid = np.mean(objectives, axis=0)\n    selected_idx = np.argmax(np.linalg.norm(objectives - centroid, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge reversal operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node chain relocation\n        k = random.randint(1, n-3)\n        chain_length = random.randint(2, min(4, n-k-1))\n        chain = new_solution[k:k+chain_length]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+chain_length:], chain])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to node insertion if invalid\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n        new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{Our novel algorithm employs a dynamic, Pareto-frontier-aware selection mechanism combined with a hybrid of adaptive edge-swap and segment-reversal operations, guided by a non-uniform objective weighting scheme to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on normalized objective trade-off\n    objectives = np.array([sol[1] for sol in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    weights = np.random.beta(2, 2, size=2)  # Biased towards non-extreme weights\n    scores = np.dot(normalized, weights)\n    selected_solution = archive[np.argmin(scores)][0].copy()\n\n    # Step 2: Adaptive hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive edge-swap with objective-aware selection\n        edges = [(i, (i+1)%n) for i in range(n)]\n        edge_scores = []\n        for i, j in edges:\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            edge_scores.append(weights[0]*cost1 + weights[1]*cost2)\n        swap_idx = np.argmax(edge_scores)\n        i, j = edges[swap_idx]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal with size proportional to current solution quality\n        quality = np.mean(scores)  # Lower is better\n        segment_size = max(2, int(n * (1 - quality) * 0.5))\n        a = random.randint(0, n - segment_size)\n        new_solution[a:a+segment_size] = new_solution[a:a+segment_size][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random 3-opt if invalid\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7194756995656713,
            2.188979923725128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on normalized objective trade-off\n    objectives = np.array([sol[1] for sol in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    weights = np.random.beta(2, 2, size=2)  # Biased towards non-extreme weights\n    scores = np.dot(normalized, weights)\n    selected_solution = archive[np.argmin(scores)][0].copy()\n\n    # Step 2: Adaptive hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive edge-swap with objective-aware selection\n        edges = [(i, (i+1)%n) for i in range(n)]\n        edge_scores = []\n        for i, j in edges:\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            edge_scores.append(weights[0]*cost1 + weights[1]*cost2)\n        swap_idx = np.argmax(edge_scores)\n        i, j = edges[swap_idx]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal with size proportional to current solution quality\n        quality = np.mean(scores)  # Lower is better\n        segment_size = max(2, int(n * (1 - quality) * 0.5))\n        a = random.randint(0, n - segment_size)\n        new_solution[a:a+segment_size] = new_solution[a:a+segment_size][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random 3-opt if invalid\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective trade-off, then applies a novel hybrid local search combining segment rotation and node relocation, guided by the current best trade-off, to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamically determine objective weights based on current archive diversity\n    obj1_vals = [obj[0] for _, obj in archive]\n    obj2_vals = [obj[1] for _, obj in archive]\n    obj1_std = np.std(obj1_vals)\n    obj2_std = np.std(obj2_vals)\n    total_std = obj1_std + obj2_std\n    w1 = obj1_std / total_std if total_std > 0 else 0.5\n    w2 = obj2_std / total_std if total_std > 0 else 0.5\n\n    # Select solution with weighted objective\n    best_solution = max(archive, key=lambda x: w1 * x[1][0] + w2 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: segment rotation and node relocation\n    if len(best_solution) > 3:\n        # Segment rotation\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        segment = best_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        best_solution[a:b+1] = rotated_segment\n\n        # Node relocation\n        i = np.random.randint(len(best_solution))\n        j = np.random.randint(len(best_solution))\n        while j == i or j == (i + 1) % len(best_solution):\n            j = np.random.randint(len(best_solution))\n        node = best_solution[i]\n        best_solution = np.delete(best_solution, i)\n        best_solution = np.insert(best_solution, j, node)\n\n    return best_solution\n\n",
        "score": [
            -0.8550491530255163,
            1.9231109023094177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamically determine objective weights based on current archive diversity\n    obj1_vals = [obj[0] for _, obj in archive]\n    obj2_vals = [obj[1] for _, obj in archive]\n    obj1_std = np.std(obj1_vals)\n    obj2_std = np.std(obj2_vals)\n    total_std = obj1_std + obj2_std\n    w1 = obj1_std / total_std if total_std > 0 else 0.5\n    w2 = obj2_std / total_std if total_std > 0 else 0.5\n\n    # Select solution with weighted objective\n    best_solution = max(archive, key=lambda x: w1 * x[1][0] + w2 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: segment rotation and node relocation\n    if len(best_solution) > 3:\n        # Segment rotation\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        segment = best_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        best_solution[a:b+1] = rotated_segment\n\n        # Node relocation\n        i = np.random.randint(len(best_solution))\n        j = np.random.randint(len(best_solution))\n        while j == i or j == (i + 1) % len(best_solution):\n            j = np.random.randint(len(best_solution))\n        node = best_solution[i]\n        best_solution = np.delete(best_solution, i)\n        best_solution = np.insert(best_solution, j, node)\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This novel local search heuristic dynamically balances between Pareto-optimal solutions and high-potential candidates, employing a hybrid of path-reversal and segment-rotation operations to explore the solution space while maintaining feasibility and promoting diverse Pareto front exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on combined objective score\n    scores = []\n    for sol, obj in archive:\n        scores.append((obj[0] + obj[1]) / (1 + obj[0] * obj[1]))  # Harmonic mean of objectives\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment rotation operation\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        shift = random.randint(1, segment_size-1)\n        rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n        new_solution[start:start+segment_size] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8150415957800279,
            2.272836744785309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on combined objective score\n    scores = []\n    for sol, obj in archive:\n        scores.append((obj[0] + obj[1]) / (1 + obj[0] * obj[1]))  # Harmonic mean of objectives\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment rotation operation\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        shift = random.randint(1, segment_size-1)\n        rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n        new_solution[start:start+segment_size] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and path-relinking operations, guided by a dynamic objective trade-off to enhance solution diversity and convergence.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        weights = np.random.dirichlet([1, 1])\n        selected_solution = sorted(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Path relinking\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.82474300294334,
            2.694808542728424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        weights = np.random.dirichlet([1, 1])\n        selected_solution = sorted(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Path relinking\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a dynamic segment reversal and edge swapping operation to enhance exploration and exploitation in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(archive):\n        if len(archive) < 3:\n            return {i: float('inf') for i in range(len(archive))}\n\n        obj1 = [obj[0] for _, obj in archive]\n        obj2 = [obj[1] for _, obj in archive]\n\n        sorted_indices1 = sorted(range(len(obj1)), key=lambda i: obj1[i])\n        sorted_indices2 = sorted(range(len(obj2)), key=lambda i: obj2[i])\n\n        crowding = {i: 0.0 for i in range(len(archive))}\n\n        for obj, indices in [(obj1, sorted_indices1), (obj2, sorted_indices2)]:\n            crowding[indices[0]] = float('inf')\n            crowding[indices[-1]] = float('inf')\n            if len(obj) > 2:\n                norm = max(obj) - min(obj) if max(obj) != min(obj) else 1\n                for i in range(1, len(indices)-1):\n                    crowding[indices[i]] += (obj[indices[i+1]] - obj[indices[i-1]]) / norm\n\n        return crowding\n\n    crowding = calculate_crowding_distance(archive)\n    selected_index = max(range(len(archive)), key=lambda i: crowding[i])\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to reverse\n        i = random.randint(0, n-3)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly swap two edges\n        k = random.randint(0, n-2)\n        l = random.randint(0, n-2)\n        while l == k or l == (k+1) % n:\n            l = random.randint(0, n-2)\n\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5740383707283345,
            2.4728006720542908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(archive):\n        if len(archive) < 3:\n            return {i: float('inf') for i in range(len(archive))}\n\n        obj1 = [obj[0] for _, obj in archive]\n        obj2 = [obj[1] for _, obj in archive]\n\n        sorted_indices1 = sorted(range(len(obj1)), key=lambda i: obj1[i])\n        sorted_indices2 = sorted(range(len(obj2)), key=lambda i: obj2[i])\n\n        crowding = {i: 0.0 for i in range(len(archive))}\n\n        for obj, indices in [(obj1, sorted_indices1), (obj2, sorted_indices2)]:\n            crowding[indices[0]] = float('inf')\n            crowding[indices[-1]] = float('inf')\n            if len(obj) > 2:\n                norm = max(obj) - min(obj) if max(obj) != min(obj) else 1\n                for i in range(1, len(indices)-1):\n                    crowding[indices[i]] += (obj[indices[i+1]] - obj[indices[i-1]]) / norm\n\n        return crowding\n\n    crowding = calculate_crowding_distance(archive)\n    selected_index = max(range(len(archive)), key=lambda i: crowding[i])\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to reverse\n        i = random.randint(0, n-3)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly swap two edges\n        k = random.randint(0, n-2)\n        l = random.randint(0, n-2)\n        while l == k or l == (k+1) % n:\n            l = random.randint(0, n-2)\n\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{A novel local search heuristic that combines crowding-distance-based selection with a dynamic segment reversal mechanism and adaptive node swapping to enhance solution quality while maintaining feasibility in bi-objective TSP.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Calculate crowding distances for selection\n    objectives = np.array([obj for _, obj in archive])\n    front = objectives.copy()\n    n_points = front.shape[0]\n\n    # Normalize objectives\n    min_vals = np.min(front, axis=0)\n    max_vals = np.max(front, axis=0)\n    normalized = (front - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(n_points)\n    for m in range(2):\n        sorted_indices = np.argsort(normalized[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n_points-1):\n            crowding_distances[sorted_indices[i]] += (normalized[sorted_indices[i+1], m] - normalized[sorted_indices[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Dynamic segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Identify segments with high total distance\n        segment_scores = []\n        for i in range(n-1):\n            for j in range(i+1, min(i+5, n-1)):\n                segment = new_solution[i:j+1]\n                reversed_segment = segment[::-1]\n                original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                               distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                               distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]] +\n                               distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                               distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]])\n                segment_scores.append((i, j, reversed_cost - original_cost))\n\n        if segment_scores:\n            # Select segment with most improvement\n            best_segment = min(segment_scores, key=lambda x: x[2])\n            i, j, _ = best_segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Adaptive node swapping\n    if n > 4:\n        # Calculate node centrality\n        centrality = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            centrality[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Swap most central node with a random node\n        central_node = np.argmax(centrality)\n        swap_pos = random.randint(0, n-1)\n        if swap_pos != central_node:\n            new_solution[central_node], new_solution[swap_pos] = new_solution[swap_pos], new_solution[central_node]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9180866349330293,
            5.804148197174072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Calculate crowding distances for selection\n    objectives = np.array([obj for _, obj in archive])\n    front = objectives.copy()\n    n_points = front.shape[0]\n\n    # Normalize objectives\n    min_vals = np.min(front, axis=0)\n    max_vals = np.max(front, axis=0)\n    normalized = (front - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(n_points)\n    for m in range(2):\n        sorted_indices = np.argsort(normalized[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n_points-1):\n            crowding_distances[sorted_indices[i]] += (normalized[sorted_indices[i+1], m] - normalized[sorted_indices[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Dynamic segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Identify segments with high total distance\n        segment_scores = []\n        for i in range(n-1):\n            for j in range(i+1, min(i+5, n-1)):\n                segment = new_solution[i:j+1]\n                reversed_segment = segment[::-1]\n                original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                               distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                               distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]] +\n                               distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                               distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]])\n                segment_scores.append((i, j, reversed_cost - original_cost))\n\n        if segment_scores:\n            # Select segment with most improvement\n            best_segment = min(segment_scores, key=lambda x: x[2])\n            i, j, _ = best_segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Adaptive node swapping\n    if n > 4:\n        # Calculate node centrality\n        centrality = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            centrality[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Swap most central node with a random node\n        central_node = np.argmax(centrality)\n        swap_pos = random.randint(0, n-1)\n        if swap_pos != central_node:\n            new_solution[central_node], new_solution[swap_pos] = new_solution[swap_pos], new_solution[central_node]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{A novel local search heuristic combines a diversity-aware selection mechanism with a multi-segment inversion and adaptive edge insertion strategy, dynamically balancing exploration and exploitation by considering both objective improvements and solution diversity to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on diversity and objective trade-off\n    def diversity_score(sol):\n        unique_segments = set()\n        for i in range(len(sol)-2):\n            segment = tuple(sorted((sol[i], sol[i+1], sol[i+2])))\n            unique_segments.add(segment)\n        return len(unique_segments)\n\n    def objective_score(obj):\n        return obj[0] + obj[1]\n\n    # Combine diversity and objective score\n    candidates = [(sol, obj) for sol, obj in archive]\n    if len(candidates) > 1:\n        selected = max(candidates, key=lambda x: diversity_score(x[0]) * 0.4 + objective_score(x[1]) * 0.6)\n    else:\n        selected = candidates[0]\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply multi-segment inversion and adaptive edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion\n        k1 = random.randint(1, n-3)\n        k2 = random.randint(1, n-3)\n        while k2 == k1:\n            k2 = random.randint(1, n-3)\n        k1, k2 = min(k1, k2), max(k1, k2)\n\n        # Invert segments between k1 and k2\n        segment1 = new_solution[:k1]\n        segment2 = new_solution[k1:k2]\n        segment3 = new_solution[k2:]\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while j == i or j == (i+1) % n:\n                j = random.randint(0, n-2)\n\n            removed_node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random inversion if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8949961082151838,
            12.03332108259201
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on diversity and objective trade-off\n    def diversity_score(sol):\n        unique_segments = set()\n        for i in range(len(sol)-2):\n            segment = tuple(sorted((sol[i], sol[i+1], sol[i+2])))\n            unique_segments.add(segment)\n        return len(unique_segments)\n\n    def objective_score(obj):\n        return obj[0] + obj[1]\n\n    # Combine diversity and objective score\n    candidates = [(sol, obj) for sol, obj in archive]\n    if len(candidates) > 1:\n        selected = max(candidates, key=lambda x: diversity_score(x[0]) * 0.4 + objective_score(x[1]) * 0.6)\n    else:\n        selected = candidates[0]\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply multi-segment inversion and adaptive edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion\n        k1 = random.randint(1, n-3)\n        k2 = random.randint(1, n-3)\n        while k2 == k1:\n            k2 = random.randint(1, n-3)\n        k1, k2 = min(k1, k2), max(k1, k2)\n\n        # Invert segments between k1 and k2\n        segment1 = new_solution[:k1]\n        segment2 = new_solution[k1:k2]\n        segment3 = new_solution[k2:]\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while j == i or j == (i+1) % n:\n                j = random.randint(0, n-2)\n\n            removed_node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random inversion if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective trade-off that adapts to the current distribution of solutions, then applies a novel local search combining alternating segment reversal and node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate dynamic weights based on objective distribution\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    total_avg = obj1_avg + obj2_avg\n    weight1 = obj2_avg / total_avg if total_avg > 0 else 0.5\n    weight2 = obj1_avg / total_avg if total_avg > 0 else 0.5\n\n    # Select solution with best weighted objective\n    best_solution = max(archive, key=lambda x: weight1 * x[1][0] + weight2 * x[1][1])[0].copy()\n\n    # Apply novel local search: alternating segment reversal and node insertion\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Alternating segment reversal\n        for _ in range(2):\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Node insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.choice(n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8531989073202209,
            2.7821121215820312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate dynamic weights based on objective distribution\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    total_avg = obj1_avg + obj2_avg\n    weight1 = obj2_avg / total_avg if total_avg > 0 else 0.5\n    weight2 = obj1_avg / total_avg if total_avg > 0 else 0.5\n\n    # Select solution with best weighted objective\n    best_solution = max(archive, key=lambda x: weight1 * x[1][0] + weight2 * x[1][1])[0].copy()\n\n    # Apply novel local search: alternating segment reversal and node insertion\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Alternating segment reversal\n        for _ in range(2):\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Node insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.choice(n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm combines Pareto-optimal solution selection with a multi-segment reassembly mechanism that dynamically adapts segment lengths based on their combined objective impact, using a guided crossover approach that preserves elite segments while introducing diversity through probabilistic segment swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-optimal solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Identify high-impact segments\n    n = len(base_solution)\n    segment_lengths = [max(2, n//k) for k in range(2, 6)]  # Test different segment lengths\n    best_segments = []\n\n    for length in segment_lengths:\n        for start in range(n - length + 1):\n            segment = base_solution[start:start+length]\n            cost = sum(distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]\n                      for i in range(length-1))\n            best_segments.append((cost, start, length, segment))\n\n    if not best_segments:\n        return base_solution\n\n    # Step 3: Select top segments and perform reassembly\n    best_segments.sort()\n    selected_segments = [s[3] for s in best_segments[:min(3, len(best_segments))]]\n\n    # Create new solution by interleaving selected segments\n    new_solution = []\n    remaining_nodes = set(range(n))\n\n    for seg in selected_segments:\n        new_solution.extend(seg)\n        remaining_nodes -= set(seg)\n\n    # Add remaining nodes in random order\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm combines Pareto-optimal solution selection with a novel multi-dimensional path decomposition and reassembly mechanism that identifies critical path segments based on their combined objective impact and spatial coherence, then reconstructs the tour by strategically reordering these segments while preserving spatial proximity in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-optimal solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Decompose the tour into critical segments\n    n = len(base_solution)\n    segments = []\n    current_segment = [base_solution[0]]\n\n    for i in range(1, n):\n        prev = base_solution[i-1]\n        curr = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n\n        # Calculate combined objective impact\n        impact = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                 distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n        # Calculate spatial coherence\n        coord1_prev = instance[prev, :2]\n        coord1_curr = instance[curr, :2]\n        coord1_next = instance[next_node, :2]\n\n        coord2_prev = instance[prev, 2:]\n        coord2_curr = instance[curr, 2:]\n        coord2_next = instance[next_node, 2:]\n\n        direction1 = coord1_curr - coord1_prev\n        direction2 = coord1_next - coord1_curr\n        angle1 = np.arccos(np.clip(np.dot(direction1, direction2) /\n                          (np.linalg.norm(direction1) * np.linalg.norm(direction2) + 1e-10), -1, 1))\n\n        direction1 = coord2_curr - coord2_prev\n        direction2 = coord2_next - coord2_curr\n        angle2 = np.arccos(np.clip(np.dot(direction1, direction2) /\n                          (np.linalg.norm(direction1) * np.linalg.norm(direction2) + 1e-10), -1, 1))\n\n        # Segment boundary condition\n        if impact > 1.2 * np.mean(distance_matrix_1) or (angle1 > np.pi/2 and angle2 > np.pi/2):\n            segments.append(current_segment)\n            current_segment = [curr]\n        else:\n            current_segment.append(curr)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Step 3: Reassemble segments with spatial proximity\n    new_solution = []\n    remaining_segments = segments.copy()\n\n    while remaining_segments:\n        if not new_solution:\n            current_segment = remaining_segments.pop(0)\n        else:\n            last_node = new_solution[-1]\n            last_coord1 = instance[last_node, :2]\n            last_coord2 = instance[last_node, 2:]\n\n            best_segment = None\n            best_distance = float('inf')\n\n            for seg in remaining_segments:\n                first_node = seg[0]\n                first_coord1 = instance[first_node, :2]\n                first_coord2 = instance[first_node, 2:]\n\n                dist1 = np.linalg.norm(last_coord1 - first_coord1)\n                dist2 = np.linalg.norm(last_coord2 - first_coord2)\n                combined_dist = dist1 + dist2\n\n                if combined_dist < best_distance:\n                    best_distance = combined_dist\n                    best_segment = seg\n\n            if best_segment:\n                remaining_segments.remove(best_segment)\n                new_solution.extend(best_segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.826834822536737,
            10.090476334095001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select Pareto-optimal solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Decompose the tour into critical segments\n    n = len(base_solution)\n    segments = []\n    current_segment = [base_solution[0]]\n\n    for i in range(1, n):\n        prev = base_solution[i-1]\n        curr = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n\n        # Calculate combined objective impact\n        impact = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                 distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n        # Calculate spatial coherence\n        coord1_prev = instance[prev, :2]\n        coord1_curr = instance[curr, :2]\n        coord1_next = instance[next_node, :2]\n\n        coord2_prev = instance[prev, 2:]\n        coord2_curr = instance[curr, 2:]\n        coord2_next = instance[next_node, 2:]\n\n        direction1 = coord1_curr - coord1_prev\n        direction2 = coord1_next - coord1_curr\n        angle1 = np.arccos(np.clip(np.dot(direction1, direction2) /\n                          (np.linalg.norm(direction1) * np.linalg.norm(direction2) + 1e-10), -1, 1))\n\n        direction1 = coord2_curr - coord2_prev\n        direction2 = coord2_next - coord2_curr\n        angle2 = np.arccos(np.clip(np.dot(direction1, direction2) /\n                          (np.linalg.norm(direction1) * np.linalg.norm(direction2) + 1e-10), -1, 1))\n\n        # Segment boundary condition\n        if impact > 1.2 * np.mean(distance_matrix_1) or (angle1 > np.pi/2 and angle2 > np.pi/2):\n            segments.append(current_segment)\n            current_segment = [curr]\n        else:\n            current_segment.append(curr)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Step 3: Reassemble segments with spatial proximity\n    new_solution = []\n    remaining_segments = segments.copy()\n\n    while remaining_segments:\n        if not new_solution:\n            current_segment = remaining_segments.pop(0)\n        else:\n            last_node = new_solution[-1]\n            last_coord1 = instance[last_node, :2]\n            last_coord2 = instance[last_node, 2:]\n\n            best_segment = None\n            best_distance = float('inf')\n\n            for seg in remaining_segments:\n                first_node = seg[0]\n                first_coord1 = instance[first_node, :2]\n                first_coord2 = instance[first_node, 2:]\n\n                dist1 = np.linalg.norm(last_coord1 - first_coord1)\n                dist2 = np.linalg.norm(last_coord2 - first_coord2)\n                combined_dist = dist1 + dist2\n\n                if combined_dist < best_distance:\n                    best_distance = combined_dist\n                    best_segment = seg\n\n            if best_segment:\n                remaining_segments.remove(best_segment)\n                new_solution.extend(best_segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines tournament selection with a hybrid of adaptive segment rotation and guided node reinsertion, using a weighted multi-objective cost metric to balance exploration and exploitation while ensuring feasibility through constrained insertion points.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Tournament selection of promising solutions\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected_solution = min(selected, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Step 2: Hybrid segment rotation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate weighted cost metric\n        weighted_cost = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            weighted_cost[i] = 0.6 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.4 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and rotate segment\n        segment_size = min(4, n // 4)\n        segment_start = np.argmax(weighted_cost)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Rotate segment\n        rotation = random.randint(1, segment_size-1) if segment_size > 1 else 0\n        rotated_segment = np.roll(segment, rotation)\n\n        new_solution = np.concatenate([\n            new_solution[:segment_start], rotated_segment, new_solution[segment_end:]\n        ])\n\n    # Step 3: Guided node reinsertion with constraints\n    if n > 5:\n        # Calculate insertion cost with constraints\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.7 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.3 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of adaptive segment reversal and guided node reinsertion, using a weighted multi-objective cost metric to balance exploration and exploitation while ensuring feasibility through constrained insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Dynamic objective-based selection\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Hybrid segment reversal mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate weighted cost metric\n        weighted_cost = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            weighted_cost[i] = 0.5 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.5 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and reverse segment\n        segment_size = min(3, n // 3)\n        segment_start = np.argmax(weighted_cost)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        new_solution = np.concatenate([\n            new_solution[:segment_start], segment[::-1], new_solution[segment_end:]\n        ])\n\n    # Step 3: Guided node reinsertion with constraints\n    if n > 5:\n        # Calculate insertion cost with constraints\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.6 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.4 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6587105164780542,
            2.574852764606476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Dynamic objective-based selection\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Hybrid segment reversal mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate weighted cost metric\n        weighted_cost = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            weighted_cost[i] = 0.5 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.5 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and reverse segment\n        segment_size = min(3, n // 3)\n        segment_start = np.argmax(weighted_cost)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        new_solution = np.concatenate([\n            new_solution[:segment_start], segment[::-1], new_solution[segment_end:]\n        ])\n\n    # Step 3: Guided node reinsertion with constraints\n    if n > 5:\n        # Calculate insertion cost with constraints\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.6 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.4 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search with novel operations\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Novel node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Novel segment inversion with dynamic length\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.897083088220405,
            2.4217891693115234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search with novel operations\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Novel node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Novel segment inversion with dynamic length\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining edge insertion and node swap to generate a neighbor solution while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    max_sum = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion and node swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k = np.random.randint(0, n)\n\n    # Edge insertion\n    if i < j:\n        temp = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], temp])\n    else:\n        temp = new_solution[j:i+1]\n        new_solution = np.concatenate([new_solution[:j], new_solution[i+1:], temp])\n\n    # Node swap\n    if k != i and k != j:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This novel heuristic combines a diversity-aware selection of solutions from the archive with an adaptive local search strategy that dynamically balances between objective-specific edge swaps and global tour restructuring, guided by a hybrid objective function that considers both the current solution's quality and its potential for further improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest diversity (largest sum of normalized objectives)\n    max_diversity = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        diversity = norm_obj1 + norm_obj2\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive local search based on objective balance\n    obj1, obj2 = max_diversity, max_diversity\n    if obj1 > obj2:\n        # More focus on objective 1: perform multiple targeted edge swaps\n        for _ in range(3):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # More focus on objective 2: perform a segment inversion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8086902329373442,
            6.082861483097076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest diversity (largest sum of normalized objectives)\n    max_diversity = -1\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / np.max(distance_matrix_1)\n        norm_obj2 = obj2 / np.max(distance_matrix_2)\n        diversity = norm_obj1 + norm_obj2\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive local search based on objective balance\n    obj1, obj2 = max_diversity, max_diversity\n    if obj1 > obj2:\n        # More focus on objective 1: perform multiple targeted edge swaps\n        for _ in range(3):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # More focus on objective 2: perform a segment inversion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm selects a solution from the archive using a dynamic weight-based selection that adapts to the current distribution of solutions, then applies a novel local search combining edge insertion and adaptive segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic weight selection based on solution distribution\n    costs = np.array([x[1] for x in archive])\n    weights = np.exp(-np.sum((costs - np.mean(costs, axis=0))**2, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    if len(new_solution) > 3:\n        # Edge insertion\n        i, j = np.random.choice(len(new_solution), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n        # Adaptive segment rotation\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], k)\n\n    return new_solution\n\n",
        "score": [
            -0.8493747792914507,
            2.14768385887146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic weight selection based on solution distribution\n    costs = np.array([x[1] for x in archive])\n    weights = np.exp(-np.sum((costs - np.mean(costs, axis=0))**2, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    if len(new_solution) > 3:\n        # Edge insertion\n        i, j = np.random.choice(len(new_solution), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n        # Adaptive segment rotation\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], k)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{A novel local search heuristic uses a crowding-distance-based selection to prioritize solutions in less-explored regions of the Pareto front, combined with a dynamic edge swap and segment reversal operator to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    front = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(front))\n\n    for m in range(2):\n        sorted_idx = np.argsort([obj[m] for obj in front])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(front)-1):\n            crowding_distances[sorted_idx[i]] += (front[sorted_idx[i+1]][m] - front[sorted_idx[i-1]][m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random positions\n        i, j = sorted(random.sample(range(n), 2))\n        while j - i < 2:\n            i, j = sorted(random.sample(range(n), 2))\n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform an edge swap\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6006913577932226,
            2.4970436692237854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    front = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(front))\n\n    for m in range(2):\n        sorted_idx = np.argsort([obj[m] for obj in front])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(front)-1):\n            crowding_distances[sorted_idx[i]] += (front[sorted_idx[i+1]][m] - front[sorted_idx[i-1]][m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random positions\n        i, j = sorted(random.sample(range(n), 2))\n        while j - i < 2:\n            i, j = sorted(random.sample(range(n), 2))\n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Perform an edge swap\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic Pareto front approximation, then applies a hybrid local search combining adaptive edge insertion and multi-segment reversal to generate a neighbor solution while ensuring feasibility and promoting exploration of non-dominated regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Approximate Pareto front and select a solution\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search with adaptive operations\n    n = len(new_solution)\n    if n > 3:\n        # Adaptive edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n        # Multi-segment reversal\n        k = random.randint(2, min(4, n//2))\n        segments = sorted(random.sample(range(1, n), k-1))\n        segments = [0] + segments + [n]\n        for s in range(len(segments)-1):\n            a, b = segments[s], segments[s+1]\n            if a < b:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n",
        "score": [
            -0.8764542350424736,
            3.227148652076721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Approximate Pareto front and select a solution\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search with adaptive operations\n    n = len(new_solution)\n    if n > 3:\n        # Adaptive edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n        # Multi-segment reversal\n        k = random.randint(2, min(4, n//2))\n        segments = sorted(random.sample(range(1, n), k-1))\n        segments = [0] + segments + [n]\n        for s in range(len(segments)-1):\n            a, b = segments[s], segments[s+1]\n            if a < b:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines tournament selection with a hybrid of adaptive segment rotation and guided node reinsertion, using a weighted multi-objective cost metric to balance exploration and exploitation while ensuring feasibility through constrained insertion points.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Tournament selection of promising solutions\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected_solution = min(selected, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Step 2: Hybrid segment rotation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate weighted cost metric\n        weighted_cost = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            weighted_cost[i] = 0.6 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.4 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and rotate segment\n        segment_size = min(4, n // 4)\n        segment_start = np.argmax(weighted_cost)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Rotate segment\n        rotation = random.randint(1, segment_size-1) if segment_size > 1 else 0\n        rotated_segment = np.roll(segment, rotation)\n\n        new_solution = np.concatenate([\n            new_solution[:segment_start], rotated_segment, new_solution[segment_end:]\n        ])\n\n    # Step 3: Guided node reinsertion with constraints\n    if n > 5:\n        # Calculate insertion cost with constraints\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.7 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.3 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{An innovative local search heuristic that combines adaptive Pareto-optimal solution selection with a hybrid of multi-crossover and guided segment inversion, using a dynamic objective-weighted cost metric to balance exploration and exploitation while ensuring feasibility through constrained node reallocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Adaptive Pareto-optimal selection\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Select based on diversity and objective balance\n        diversity_scores = []\n        for sol, obj in non_dominated:\n            diversity = 0\n            for other_sol, _ in non_dominated:\n                diversity += np.sum(sol != other_sol)\n            diversity_scores.append(diversity * (obj[0] + obj[1]))\n        selected_idx = np.argmin(diversity_scores)\n        selected_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 2: Hybrid multi-crossover operation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select two random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Create new solution by combining segments\n        new_solution = np.concatenate([\n            selected_solution[:a],\n            selected_solution[c:d],\n            selected_solution[b:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) < n:\n            missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Guided segment inversion with constrained optimization\n    if n > 5:\n        # Calculate segment costs\n        segment_costs = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            segment_costs[i] = 0.5 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.5 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select worst segment to invert\n        segment_size = min(3, n // 3)\n        worst_segment_start = np.argmax(segment_costs)\n        worst_segment = new_solution[worst_segment_start:worst_segment_start+segment_size]\n\n        # Invert segment with constraints\n        if segment_size > 1:\n            inverted_segment = worst_segment[::-1]\n            new_solution = np.concatenate([\n                new_solution[:worst_segment_start],\n                inverted_segment,\n                new_solution[worst_segment_start+segment_size:]\n            ])\n\n    # Step 4: Constrained node reallocation\n    if n > 6:\n        # Identify nodes with high reallocation cost\n        reallocation_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            reallocation_costs[i] = 0.4 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.6 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Reallocate worst node\n        worst_node_idx = np.argmax(reallocation_costs)\n        worst_node = new_solution[worst_node_idx]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n        for i in range(n):\n            if i != worst_node_idx and i != (worst_node_idx-1)%n and i != (worst_node_idx+1)%n:\n                temp_solution = np.concatenate([\n                    new_solution[:worst_node_idx],\n                    new_solution[worst_node_idx+1:]\n                ])\n                temp_solution = np.insert(temp_solution, i, worst_node)\n                cost = 0\n                for j in range(n-1):\n                    cost += distance_matrix_1[temp_solution[j], temp_solution[j+1]] + distance_matrix_2[temp_solution[j], temp_solution[j+1]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:worst_node_idx],\n                new_solution[worst_node_idx+1:]\n            ])\n            new_solution = np.insert(new_solution, best_pos, worst_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6302631325015211,
            13.661134660243988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Adaptive Pareto-optimal selection\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Select based on diversity and objective balance\n        diversity_scores = []\n        for sol, obj in non_dominated:\n            diversity = 0\n            for other_sol, _ in non_dominated:\n                diversity += np.sum(sol != other_sol)\n            diversity_scores.append(diversity * (obj[0] + obj[1]))\n        selected_idx = np.argmin(diversity_scores)\n        selected_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 2: Hybrid multi-crossover operation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select two random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Create new solution by combining segments\n        new_solution = np.concatenate([\n            selected_solution[:a],\n            selected_solution[c:d],\n            selected_solution[b:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) < n:\n            missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Guided segment inversion with constrained optimization\n    if n > 5:\n        # Calculate segment costs\n        segment_costs = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            segment_costs[i] = 0.5 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.5 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select worst segment to invert\n        segment_size = min(3, n // 3)\n        worst_segment_start = np.argmax(segment_costs)\n        worst_segment = new_solution[worst_segment_start:worst_segment_start+segment_size]\n\n        # Invert segment with constraints\n        if segment_size > 1:\n            inverted_segment = worst_segment[::-1]\n            new_solution = np.concatenate([\n                new_solution[:worst_segment_start],\n                inverted_segment,\n                new_solution[worst_segment_start+segment_size:]\n            ])\n\n    # Step 4: Constrained node reallocation\n    if n > 6:\n        # Identify nodes with high reallocation cost\n        reallocation_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            reallocation_costs[i] = 0.4 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.6 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Reallocate worst node\n        worst_node_idx = np.argmax(reallocation_costs)\n        worst_node = new_solution[worst_node_idx]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n        for i in range(n):\n            if i != worst_node_idx and i != (worst_node_idx-1)%n and i != (worst_node_idx+1)%n:\n                temp_solution = np.concatenate([\n                    new_solution[:worst_node_idx],\n                    new_solution[worst_node_idx+1:]\n                ])\n                temp_solution = np.insert(temp_solution, i, worst_node)\n                cost = 0\n                for j in range(n-1):\n                    cost += distance_matrix_1[temp_solution[j], temp_solution[j+1]] + distance_matrix_2[temp_solution[j], temp_solution[j+1]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:worst_node_idx],\n                new_solution[worst_node_idx+1:]\n            ])\n            new_solution = np.insert(new_solution, best_pos, worst_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel hybrid local search combining edge insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best diversity-adjusted objective (0.6 for first objective, 0.4 for second)\n    selected = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: edge insertion and segment rotation\n    if len(selected) > 3:\n        # Edge insertion\n        i, j = np.random.choice(len(selected), size=2, replace=False)\n        node = selected[i]\n        selected = np.delete(selected, i)\n        insert_pos = np.random.randint(0, len(selected))\n        selected = np.insert(selected, insert_pos, node)\n\n        # Segment rotation\n        a, b = sorted(np.random.choice(len(selected), size=2, replace=False))\n        segment = selected[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n        selected[a:b+1] = segment\n\n    return selected\n\n",
        "score": [
            -0.8542704935292552,
            1.4955139756202698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best diversity-adjusted objective (0.6 for first objective, 0.4 for second)\n    selected = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: edge insertion and segment rotation\n    if len(selected) > 3:\n        # Edge insertion\n        i, j = np.random.choice(len(selected), size=2, replace=False)\n        node = selected[i]\n        selected = np.delete(selected, i)\n        insert_pos = np.random.randint(0, len(selected))\n        selected = np.insert(selected, insert_pos, node)\n\n        # Segment rotation\n        a, b = sorted(np.random.choice(len(selected), size=2, replace=False))\n        segment = selected[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n        selected[a:b+1] = segment\n\n    return selected\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{A novel local search heuristic combines a Pareto-frontier biased selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto ranking\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    selected_solution = random.choice(pareto_front)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8123879658239479,
            2.204545021057129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive using Pareto ranking\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    selected_solution = random.choice(pareto_front)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a hybrid segment reversal and node insertion operation to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [float('inf')] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        crowding_distances = [0.0] * len(solutions)\n\n        for m in range(2):\n            sorted_idx = sorted(range(len(objectives)), key=lambda i: objectives[i][m])\n            crowding_distances[sorted_idx[0]] = float('inf')\n            crowding_distances[sorted_idx[-1]] = float('inf')\n\n            f_min = objectives[sorted_idx[0]][m]\n            f_max = objectives[sorted_idx[-1]][m]\n\n            if f_max == f_min:\n                continue\n\n            for i in range(1, len(solutions)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (f_max - f_min)\n\n        return crowding_distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance = max(crowding_distances)\n    candidates = [sol for sol, dist in zip(archive, crowding_distances) if dist == max_distance]\n    selected_solution, _ = random.choice(candidates)\n\n    # Step 2: Apply hybrid segment reversal and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert a random node at a different position\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6263508964242112,
            2.3359748125076294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [float('inf')] * len(solutions)\n\n        objectives = [obj for _, obj in solutions]\n        crowding_distances = [0.0] * len(solutions)\n\n        for m in range(2):\n            sorted_idx = sorted(range(len(objectives)), key=lambda i: objectives[i][m])\n            crowding_distances[sorted_idx[0]] = float('inf')\n            crowding_distances[sorted_idx[-1]] = float('inf')\n\n            f_min = objectives[sorted_idx[0]][m]\n            f_max = objectives[sorted_idx[-1]][m]\n\n            if f_max == f_min:\n                continue\n\n            for i in range(1, len(solutions)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (f_max - f_min)\n\n        return crowding_distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    max_distance = max(crowding_distances)\n    candidates = [sol for sol, dist in zip(archive, crowding_distances) if dist == max_distance]\n    selected_solution, _ = random.choice(candidates)\n\n    # Step 2: Apply hybrid segment reversal and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert a random node at a different position\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{A novel local search heuristic that combines a crowding-distance-based selection of solutions from the archive with a multi-segment reversal operation guided by a dynamic objective trade-off to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_index = np.argmax(crowding_distances)\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Calculate dynamic objective trade-off\n    total_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[i+1]] for i in range(len(selected_solution)-1)) + distance_matrix_1[selected_solution[-1], selected_solution[0]]\n    total_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[i+1]] for i in range(len(selected_solution)-1)) + distance_matrix_2[selected_solution[-1], selected_solution[0]]\n    trade_off = total_cost1 / (total_cost1 + total_cost2)\n\n    # Step 3: Apply multi-segment reversal operation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Determine number of segments based on trade-off\n        num_segments = max(2, min(5, int(3 + trade_off * 3)))\n\n        # Generate segment boundaries\n        segments = sorted(random.sample(range(1, n), num_segments-1))\n\n        # Reverse each segment\n        for i in range(len(segments)):\n            start = segments[i-1] if i > 0 else 0\n            end = segments[i]\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.44469288164575366,
            3.414334774017334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_index = np.argmax(crowding_distances)\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Calculate dynamic objective trade-off\n    total_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[i+1]] for i in range(len(selected_solution)-1)) + distance_matrix_1[selected_solution[-1], selected_solution[0]]\n    total_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[i+1]] for i in range(len(selected_solution)-1)) + distance_matrix_2[selected_solution[-1], selected_solution[0]]\n    trade_off = total_cost1 / (total_cost1 + total_cost2)\n\n    # Step 3: Apply multi-segment reversal operation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Determine number of segments based on trade-off\n        num_segments = max(2, min(5, int(3 + trade_off * 3)))\n\n        # Generate segment boundaries\n        segments = sorted(random.sample(range(1, n), num_segments-1))\n\n        # Reverse each segment\n        for i in range(len(segments)):\n            start = segments[i-1] if i > 0 else 0\n            end = segments[i]\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour length, then applies a hybrid local search operator that combines edge insertion and node relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with node relinking\n    n = len(base_solution)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j:\n        j = random.randint(0, n-1)\n\n    # Perform edge insertion\n    if random.random() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node relinking: insert node j between i and i+1\n        if i == n-1:\n            new_solution = np.concatenate([new_solution[:i], [base_solution[j]], new_solution[i:]])\n        else:\n            new_solution = np.concatenate([new_solution[:i+1], [base_solution[j]], new_solution[i+1:]])\n\n    # Ensure the tour remains valid by removing duplicates\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them randomly\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, missing_nodes)\n\n    return new_solution\n\n",
        "score": [
            -0.7248858978778558,
            2.52502977848053
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (obj[0] + obj[1]) for _, obj in archive], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion with node relinking\n    n = len(base_solution)\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while i == j:\n        j = random.randint(0, n-1)\n\n    # Perform edge insertion\n    if random.random() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Node relinking: insert node j between i and i+1\n        if i == n-1:\n            new_solution = np.concatenate([new_solution[:i], [base_solution[j]], new_solution[i:]])\n        else:\n            new_solution = np.concatenate([new_solution[:i+1], [base_solution[j]], new_solution[i+1:]])\n\n    # Ensure the tour remains valid by removing duplicates\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them randomly\n    missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n    if len(missing_nodes) > 0:\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, missing_nodes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective trade-off that adapts to the current diversity of solutions, then applies a novel hybrid local search combining edge-based crossover and adaptive segment mutation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic trade-off selection based on solution diversity\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    diversity = (max(obj1_values) - min(obj1_values)) + (max(obj2_values) - min(obj2_values))\n\n    if diversity > 0:\n        weights = (0.5 + 0.5 * (obj1_values[0] - min(obj1_values)) / diversity,\n                  0.5 + 0.5 * (obj2_values[0] - min(obj2_values)) / diversity)\n    else:\n        weights = (0.5, 0.5)\n\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search: edge-based crossover and adaptive segment mutation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-based crossover with a random solution\n        other_sol = random.choice(archive)[0]\n        crossover_point = random.randint(1, n-2)\n        edges = set(zip(selected_solution, np.roll(selected_solution, -1)))\n        edges.update(zip(other_sol, np.roll(other_sol, -1)))\n\n        # Build new solution by following edges\n        current_node = selected_solution[0]\n        visited = {current_node}\n        new_solution = [current_node]\n\n        for _ in range(n-1):\n            candidates = [node for edge in edges for node in edge if edge[0] == current_node and node not in visited]\n            if not candidates:\n                candidates = [node for node in range(n) if node not in visited]\n            next_node = random.choice(candidates)\n            new_solution.append(next_node)\n            visited.add(next_node)\n            current_node = next_node\n\n        # Adaptive segment mutation based on objective trade-off\n        mutation_size = max(2, int(n * (0.1 + 0.4 * weights[0])))\n        start = random.randint(0, n - mutation_size)\n        segment = new_solution[start:start+mutation_size]\n        new_segment = segment.copy()\n        random.shuffle(new_segment)\n        new_solution[start:start+mutation_size] = new_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8507377370018289,
            4.339975714683533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic trade-off selection based on solution diversity\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n    diversity = (max(obj1_values) - min(obj1_values)) + (max(obj2_values) - min(obj2_values))\n\n    if diversity > 0:\n        weights = (0.5 + 0.5 * (obj1_values[0] - min(obj1_values)) / diversity,\n                  0.5 + 0.5 * (obj2_values[0] - min(obj2_values)) / diversity)\n    else:\n        weights = (0.5, 0.5)\n\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search: edge-based crossover and adaptive segment mutation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-based crossover with a random solution\n        other_sol = random.choice(archive)[0]\n        crossover_point = random.randint(1, n-2)\n        edges = set(zip(selected_solution, np.roll(selected_solution, -1)))\n        edges.update(zip(other_sol, np.roll(other_sol, -1)))\n\n        # Build new solution by following edges\n        current_node = selected_solution[0]\n        visited = {current_node}\n        new_solution = [current_node]\n\n        for _ in range(n-1):\n            candidates = [node for edge in edges for node in edge if edge[0] == current_node and node not in visited]\n            if not candidates:\n                candidates = [node for node in range(n) if node not in visited]\n            next_node = random.choice(candidates)\n            new_solution.append(next_node)\n            visited.add(next_node)\n            current_node = next_node\n\n        # Adaptive segment mutation based on objective trade-off\n        mutation_size = max(2, int(n * (0.1 + 0.4 * weights[0])))\n        start = random.randint(0, n - mutation_size)\n        segment = new_solution[start:start+mutation_size]\n        new_segment = segment.copy()\n        random.shuffle(new_segment)\n        new_solution[start:start+mutation_size] = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{A novel local search heuristic dynamically prioritizes solutions based on their dominance in the Pareto front, followed by a hybrid of edge-swap and segment-reversal operations, with adaptive segment lengths and guided by objective-specific distance matrices to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance in Pareto front\n    # Compute dominance counts\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select solution with minimum dominance count (most non-dominated)\n    selected_idx = np.argmin(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive segment lengths\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap with objective-aware selection\n        obj_weights = np.random.dirichlet([1, 1])\n        edge_scores = []\n        for i in range(n):\n            next_i = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[next_i]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[next_i]]\n            edge_scores.append(obj_weights[0] * cost1 + obj_weights[1] * cost2)\n\n        # Select worst edge to swap\n        worst_edge = np.argmax(edge_scores)\n        swap_candidates = [i for i in range(n) if i != worst_edge and i != (worst_edge + 1) % n]\n        if swap_candidates:\n            swap_target = random.choice(swap_candidates)\n            new_solution[worst_edge], new_solution[swap_target] = new_solution[swap_target], new_solution[worst_edge]\n\n        # Segment-reversal with adaptive length\n        segment_length = min(3, n // 2)  # Adaptive length based on problem size\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.847178331664988,
            7.557360053062439
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance in Pareto front\n    # Compute dominance counts\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select solution with minimum dominance count (most non-dominated)\n    selected_idx = np.argmin(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive segment lengths\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap with objective-aware selection\n        obj_weights = np.random.dirichlet([1, 1])\n        edge_scores = []\n        for i in range(n):\n            next_i = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[next_i]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[next_i]]\n            edge_scores.append(obj_weights[0] * cost1 + obj_weights[1] * cost2)\n\n        # Select worst edge to swap\n        worst_edge = np.argmax(edge_scores)\n        swap_candidates = [i for i in range(n) if i != worst_edge and i != (worst_edge + 1) % n]\n        if swap_candidates:\n            swap_target = random.choice(swap_candidates)\n            new_solution[worst_edge], new_solution[swap_target] = new_solution[swap_target], new_solution[worst_edge]\n\n        # Segment-reversal with adaptive length\n        segment_length = min(3, n // 2)  # Adaptive length based on problem size\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective-based criterion, then applies a novel segment inversion and node insertion hybrid operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid segment inversion and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select a random segment and invert it\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Insert a randomly selected node at a different position\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Remove duplicate (if any) to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) < n:\n            # Find and remove the duplicate\n            counts = np.bincount(new_solution)\n            duplicate = np.where(counts > 1)[0][0]\n            indices = np.where(new_solution == duplicate)[0]\n            new_solution = np.delete(new_solution, indices[1])\n\n    # Ensure solution is a valid tour\n    if len(new_solution) != n:\n        # If solution length is wrong, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.625014493828599,
            11.916745841503143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid segment inversion and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select a random segment and invert it\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Insert a randomly selected node at a different position\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Remove duplicate (if any) to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) < n:\n            # Find and remove the duplicate\n            counts = np.bincount(new_solution)\n            duplicate = np.where(counts > 1)[0][0]\n            indices = np.where(new_solution == duplicate)[0]\n            new_solution = np.delete(new_solution, indices[1])\n\n    # Ensure solution is a valid tour\n    if len(new_solution) != n:\n        # If solution length is wrong, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.9777870626342715,
            0.9503602981567383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.9777870626342715,
            0.9503602981567383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{A novel local search heuristic that combines Pareto-dominance-based selection with an adaptive segment reversal and guided node insertion mechanism to enhance solution quality in the bi-objective space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated).copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment reversal\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Step 3: Guided node insertion\n    if n > 4:\n        node = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.827546513766572,
            2.750929057598114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated).copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment reversal\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Step 3: Guided node insertion\n    if n > 4:\n        node = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This novel algorithm combines a dynamic objective-based selection with a hybrid of segment inversion and node insertion operations, guided by an adaptive trade-off between objectives and using a probabilistic acceptance criterion to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search with probabilistic acceptance\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node insertion operation with probability\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6981259500638642,
            1.4611483216285706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search with probabilistic acceptance\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node insertion operation with probability\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This novel local search heuristic combines a Pareto-frontier-based selection of solutions from the archive, followed by a hybrid of node-insertion and path-relinking operations, guided by adaptive objective weights to balance exploration and exploitation for improved multi-objective solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive (Pareto-frontier based)\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for i, (_, front_obj) in enumerate(pareto_front):\n            if obj[0] >= front_obj[0] and obj[1] >= front_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= front_obj[0] and obj[1] <= front_obj[1]:\n                pareto_front.pop(i)\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        selected_solution = archive[0][0].copy()\n    else:\n        weights = np.random.dirichlet([1, 1])\n        selected_solution = sorted(pareto_front, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0][0].copy()\n\n    # Step 2: Apply hybrid local search (node-insertion + path-relinking)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-insertion operation\n        i, j = random.sample(range(n), 2)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Path-relinking operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7685153309880612,
            3.5145302414894104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive (Pareto-frontier based)\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for i, (_, front_obj) in enumerate(pareto_front):\n            if obj[0] >= front_obj[0] and obj[1] >= front_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= front_obj[0] and obj[1] <= front_obj[1]:\n                pareto_front.pop(i)\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        selected_solution = archive[0][0].copy()\n    else:\n        weights = np.random.dirichlet([1, 1])\n        selected_solution = sorted(pareto_front, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0][0].copy()\n\n    # Step 2: Apply hybrid local search (node-insertion + path-relinking)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-insertion operation\n        i, j = random.sample(range(n), 2)\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Path-relinking operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection with a hybrid of node-segment relocation and adaptive edge recombination, guided by a multi-objective quality metric that balances diversity and convergence toward the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on combined objective quality\n    quality_scores = []\n    for sol, obj in archive:\n        quality = (obj[0] + obj[1]) / (1 + abs(obj[0] - obj[1]))\n        quality_scores.append(quality)\n    selected_idx = np.argmin(quality_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Node-segment relocation\n        segment_length = random.randint(2, min(4, n//2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n        # Adaptive edge recombination\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if random.random() < 0.3:\n                k = random.randint(0, n-1)\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4177584653950397,
            3.21703177690506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on combined objective quality\n    quality_scores = []\n    for sol, obj in archive:\n        quality = (obj[0] + obj[1]) / (1 + abs(obj[0] - obj[1]))\n        quality_scores.append(quality)\n    selected_idx = np.argmin(quality_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Node-segment relocation\n        segment_length = random.randint(2, min(4, n//2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n        # Adaptive edge recombination\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if random.random() < 0.3:\n                k = random.randint(0, n-1)\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective trade-off, then applies a hybrid of node-swap and segment-reversal operations to generate a neighbor solution while maintaining feasibility through a feasibility-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = [0.3, 0.7]  # Weight for each objective\n    weighted_scores = [(obj[0] * weights[0] + obj[1] * weights[1], sol) for sol, obj in archive]\n    weighted_scores.sort(key=lambda x: x[0])\n    selected_solution = weighted_scores[0][1].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7572484898877156,
            1.4151744842529297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = [0.3, 0.7]  # Weight for each objective\n    weighted_scores = [(obj[0] * weights[0] + obj[1] * weights[1], sol) for sol, obj in archive]\n    weighted_scores.sort(key=lambda x: x[0])\n    selected_solution = weighted_scores[0][1].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This algorithm selects a solution from the archive with the highest potential for improvement by considering both objective values and their relative distances, then applies a hybrid local search operator that combines a segment reversal and a node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and reverse it\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node and insert it at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8801013353109223,
            1.4137367010116577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment and reverse it\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node and insert it at a new position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This novel heuristic combines a crowding-distance-based selection of solutions from the archive, followed by a hybrid of edge-swapping and path-relinking operations, guided by an adaptive weighting scheme to balance exploration and exploitation of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        while l == k:\n            l = random.randint(0, n-1)\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5768854358303674,
            1.9924363493919373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        while l == k:\n            l = random.randint(0, n-1)\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance-based selection of non-dominated solutions from the archive, followed by a hybrid of node-relocation and edge-chaining operations, guided by a dynamic objective-space exploration strategy to diversify the search while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-relocation: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n        # Edge-chaining: connect two random edges by swapping segments\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8694284271886139,
            2.528981029987335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-relocation: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n        # Edge-chaining: connect two random edges by swapping segments\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel local search heuristic that combines a Pareto-frontier-aware selection of solutions with a hybrid of cross-over and mutation operations, guided by adaptive objective weights to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[i][0])\n\n    if pareto_front:\n        selected_solution = random.choice(pareto_front).copy()\n    else:\n        selected_solution = archive[np.argmin(np.sum(objectives, axis=1))][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Crossover: combine segments from two solutions\n        other_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = selected_solution[:crossover_point]\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Mutation: randomly reverse a segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7509050186666427,
            1.4477651715278625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[i][0])\n\n    if pareto_front:\n        selected_solution = random.choice(pareto_front).copy()\n    else:\n        selected_solution = archive[np.argmin(np.sum(objectives, axis=1))][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Crossover: combine segments from two solutions\n        other_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = selected_solution[:crossover_point]\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Mutation: randomly reverse a segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A novel local search heuristic combines a Pareto-frontier biased selection of solutions from the archive, followed by a hybrid of edge-swapping and segment-reversal operations, guided by a dynamic weight-based trade-off to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_indices = np.where(np.all(objectives <= objectives.max(axis=0), axis=1))[0]\n    if len(pareto_indices) == 0:\n        pareto_indices = np.arange(len(archive))\n    selected_idx = random.choice(pareto_indices)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping: swap two random edges\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8777120989032268,
            2.285545289516449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_indices = np.where(np.all(objectives <= objectives.max(axis=0), axis=1))[0]\n    if len(pareto_indices) == 0:\n        pareto_indices = np.arange(len(archive))\n    selected_idx = random.choice(pareto_indices)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping: swap two random edges\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A novel local search algorithm combines adaptive Pareto-frontier selection with a hybrid of edge-crossing and segment-reversal operations, dynamically balancing exploration and exploitation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                continue\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    # Select solution with highest crowding distance (diverse)\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-crossing operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n\n        # Segment-reversal with adaptive length\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.49157421919603433,
            2.4528066515922546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                continue\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    # Select solution with highest crowding distance (diverse)\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-crossing operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n\n        # Segment-reversal with adaptive length\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This novel local search heuristic combines a diversity-aware selection of solutions from the archive with a hybrid of segment-inversion and adaptive node-replacement operations, guided by a dynamic trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        std_devs = np.std(objectives, axis=0)\n        weights = std_devs / np.sum(std_devs)\n        selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node replacement operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = node\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7060887947806757,
            1.47761070728302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on diversity-aware trade-off\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        std_devs = np.std(objectives, axis=0)\n        weights = std_devs / np.sum(std_devs)\n        selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node replacement operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = node\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This novel algorithm combines a crowding-distance-aware selection of solutions with a hybrid of segment inversion and node relocation operations, guided by a dynamic objective-space exploration strategy to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n        normalized_distances = (sorted_objectives[2:] - sorted_objectives[:-2]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n        crowding_distances[sorted_indices[1:-1]] += normalized_distances\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n    if n > 3:\n        # Segment inversion with dynamic length\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Node relocation based on distance improvement\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            best_pos = i\n            current_cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[(i+1)%n]]\n\n            for j in range(n):\n                if j != i and j != (i-1) and j != (i+1):\n                    new_cost = distance_matrix_1[new_solution[(j-1)%n], node] + distance_matrix_1[node, new_solution[j]]\n                    if new_cost < current_cost:\n                        current_cost = new_cost\n                        best_pos = j\n\n            if best_pos != i:\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8977112145603032,
            2.244512140750885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n        normalized_distances = (sorted_objectives[2:] - sorted_objectives[:-2]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n        crowding_distances[sorted_indices[1:-1]] += normalized_distances\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n    if n > 3:\n        # Segment inversion with dynamic length\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Node relocation based on distance improvement\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            best_pos = i\n            current_cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[(i+1)%n]]\n\n            for j in range(n):\n                if j != i and j != (i-1) and j != (i+1):\n                    new_cost = distance_matrix_1[new_solution[(j-1)%n], node] + distance_matrix_1[node, new_solution[j]]\n                    if new_cost < current_cost:\n                        current_cost = new_cost\n                        best_pos = j\n\n            if best_pos != i:\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9897182436917125,
            0.6863543391227722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9897182436917125,
            0.6863543391227722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9897182436917125,
            0.6863543391227722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A novel local search heuristic that combines crowding-distance-based selection with a two-phase perturbation mechanism, including adaptive segment reversal and guided node insertion, to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_indices[0]] = np.inf\n    crowding_dist[sorted_indices[-1]] = np.inf\n\n    for i in range(1, len(archive)-1):\n        crowding_dist[i] = (objectives[i+1, 0] - objectives[i-1, 0]) / (objectives[-1, 0] - objectives[0, 0]) + \\\n                          (objectives[i+1, 1] - objectives[i-1, 1]) / (objectives[-1, 1] - objectives[0, 1])\n\n    selected_solution = archive[np.argmax(crowding_dist)][0].copy()\n\n    # Step 2: Two-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment reversal\n    if n > 3:\n        segment_length = min(4, n-1)\n        start = random.randint(0, n-segment_length-1)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Phase 2: Guided node insertion\n    if n > 4:\n        node_to_move = random.randint(0, n-1)\n        best_pos = node_to_move\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_move or pos == (node_to_move-1)%n or pos == (node_to_move+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.roll(temp_sol, -node_to_move)\n            temp_sol = np.concatenate([temp_sol[:1], temp_sol[1:pos+1], temp_sol[-1:], temp_sol[pos+1:-1]])\n\n            cost1 = distance_matrix_1[temp_sol[-2], temp_sol[-1]] + distance_matrix_1[temp_sol[-1], temp_sol[0]] + \\\n                   distance_matrix_1[temp_sol[pos-1], temp_sol[pos]] + distance_matrix_1[temp_sol[pos], temp_sol[pos+1]]\n            cost2 = distance_matrix_2[temp_sol[-2], temp_sol[-1]] + distance_matrix_2[temp_sol[-1], temp_sol[0]] + \\\n                   distance_matrix_2[temp_sol[pos-1], temp_sol[pos]] + distance_matrix_2[temp_sol[pos], temp_sol[pos+1]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != node_to_move:\n            temp_sol = new_solution.copy()\n            temp_sol = np.roll(temp_sol, -node_to_move)\n            temp_sol = np.concatenate([temp_sol[:1], temp_sol[1:best_pos+1], temp_sol[-1:], temp_sol[best_pos+1:-1]])\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7612632264545114,
            3.8762714862823486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_indices[0]] = np.inf\n    crowding_dist[sorted_indices[-1]] = np.inf\n\n    for i in range(1, len(archive)-1):\n        crowding_dist[i] = (objectives[i+1, 0] - objectives[i-1, 0]) / (objectives[-1, 0] - objectives[0, 0]) + \\\n                          (objectives[i+1, 1] - objectives[i-1, 1]) / (objectives[-1, 1] - objectives[0, 1])\n\n    selected_solution = archive[np.argmax(crowding_dist)][0].copy()\n\n    # Step 2: Two-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment reversal\n    if n > 3:\n        segment_length = min(4, n-1)\n        start = random.randint(0, n-segment_length-1)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Phase 2: Guided node insertion\n    if n > 4:\n        node_to_move = random.randint(0, n-1)\n        best_pos = node_to_move\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_move or pos == (node_to_move-1)%n or pos == (node_to_move+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.roll(temp_sol, -node_to_move)\n            temp_sol = np.concatenate([temp_sol[:1], temp_sol[1:pos+1], temp_sol[-1:], temp_sol[pos+1:-1]])\n\n            cost1 = distance_matrix_1[temp_sol[-2], temp_sol[-1]] + distance_matrix_1[temp_sol[-1], temp_sol[0]] + \\\n                   distance_matrix_1[temp_sol[pos-1], temp_sol[pos]] + distance_matrix_1[temp_sol[pos], temp_sol[pos+1]]\n            cost2 = distance_matrix_2[temp_sol[-2], temp_sol[-1]] + distance_matrix_2[temp_sol[-1], temp_sol[0]] + \\\n                   distance_matrix_2[temp_sol[pos-1], temp_sol[pos]] + distance_matrix_2[temp_sol[pos], temp_sol[pos+1]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != node_to_move:\n            temp_sol = new_solution.copy()\n            temp_sol = np.roll(temp_sol, -node_to_move)\n            temp_sol = np.concatenate([temp_sol[:1], temp_sol[1:best_pos+1], temp_sol[-1:], temp_sol[best_pos+1:-1]])\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{A novel local search heuristic that combines Pareto-dominance-based selection with a two-phase adaptive perturbation mechanism, including a guided segment inversion and a probabilistic edge reallocation strategy, to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution with probability 0.7, otherwise select randomly\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if random.random() < 0.7 and non_dominated:\n        selected_solution = random.choice(non_dominated)[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Guided segment inversion\n    if n > 3:\n        # Select a segment and invert it with probability proportional to its total distance\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-1-segment_length)\n        segment = new_solution[start:start+segment_length]\n        total_dist = sum(distance_matrix_1[segment[i-1], segment[i]] + distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n        if random.random() < total_dist / (distance_matrix_1.max() + distance_matrix_2.max()):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    # Phase 2: Probabilistic edge reallocation\n    if n > 4:\n        # Reallocate edges with probability based on their contribution to total distance\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            edge_dist = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr]\n            if random.random() < edge_dist / (distance_matrix_1.max() + distance_matrix_2.max()):\n                # Find a better position to insert this node\n                candidates = []\n                for j in range(n):\n                    if j != i and j != (i-1)%n and j != (i+1)%n:\n                        new_dist = distance_matrix_1[new_solution[j], curr] + distance_matrix_1[curr, new_solution[(j+1)%n]] + \\\n                                  distance_matrix_2[new_solution[j], curr] + distance_matrix_2[curr, new_solution[(j+1)%n]]\n                        candidates.append((new_dist, j))\n                if candidates:\n                    best_pos = min(candidates, key=lambda x: x[0])[1]\n                    new_solution = np.concatenate([\n                        new_solution[:i], new_solution[i+1:best_pos+1],\n                        [curr], new_solution[best_pos+1:]\n                    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9006961174504331,
            7.412478148937225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution with probability 0.7, otherwise select randomly\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if random.random() < 0.7 and non_dominated:\n        selected_solution = random.choice(non_dominated)[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Guided segment inversion\n    if n > 3:\n        # Select a segment and invert it with probability proportional to its total distance\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-1-segment_length)\n        segment = new_solution[start:start+segment_length]\n        total_dist = sum(distance_matrix_1[segment[i-1], segment[i]] + distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n        if random.random() < total_dist / (distance_matrix_1.max() + distance_matrix_2.max()):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    # Phase 2: Probabilistic edge reallocation\n    if n > 4:\n        # Reallocate edges with probability based on their contribution to total distance\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            edge_dist = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr]\n            if random.random() < edge_dist / (distance_matrix_1.max() + distance_matrix_2.max()):\n                # Find a better position to insert this node\n                candidates = []\n                for j in range(n):\n                    if j != i and j != (i-1)%n and j != (i+1)%n:\n                        new_dist = distance_matrix_1[new_solution[j], curr] + distance_matrix_1[curr, new_solution[(j+1)%n]] + \\\n                                  distance_matrix_2[new_solution[j], curr] + distance_matrix_2[curr, new_solution[(j+1)%n]]\n                        candidates.append((new_dist, j))\n                if candidates:\n                    best_pos = min(candidates, key=lambda x: x[0])[1]\n                    new_solution = np.concatenate([\n                        new_solution[:i], new_solution[i+1:best_pos+1],\n                        [curr], new_solution[best_pos+1:]\n                    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This new algorithm employs a crowding-distance-based selection of solutions from the archive, followed by a combination of node-swap and segment-reversal operations, guided by a dynamic normalization of objective values to balance exploration and exploitation while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives\n    obj1 = np.array([obj[0] for obj in objectives])\n    obj2 = np.array([obj[1] for obj in objectives])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    normalized_obj1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else np.zeros_like(obj1)\n    normalized_obj2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else np.zeros_like(obj2)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    sorted_idx1 = np.argsort(normalized_obj1)\n    sorted_idx2 = np.argsort(normalized_obj2)\n\n    for i in range(1, len(archive)-1):\n        crowding[sorted_idx1[i]] += normalized_obj1[sorted_idx1[i+1]] - normalized_obj1[sorted_idx1[i-1]]\n        crowding[sorted_idx2[i]] += normalized_obj2[sorted_idx2[i+1]] - normalized_obj2[sorted_idx2[i-1]]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8872419089546795,
            2.0733023285865784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives\n    obj1 = np.array([obj[0] for obj in objectives])\n    obj2 = np.array([obj[1] for obj in objectives])\n    min1, max1 = np.min(obj1), np.max(obj1)\n    min2, max2 = np.min(obj2), np.max(obj2)\n    normalized_obj1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else np.zeros_like(obj1)\n    normalized_obj2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else np.zeros_like(obj2)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    sorted_idx1 = np.argsort(normalized_obj1)\n    sorted_idx2 = np.argsort(normalized_obj2)\n\n    for i in range(1, len(archive)-1):\n        crowding[sorted_idx1[i]] += normalized_obj1[sorted_idx1[i+1]] - normalized_obj1[sorted_idx1[i-1]]\n        crowding[sorted_idx2[i]] += normalized_obj2[sorted_idx2[i+1]] - normalized_obj2[sorted_idx2[i-1]]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0245395986903558,
            1.3996911644935608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0245395986903558,
            1.3996911644935608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{A novel local search heuristic that combines a crowding-distance based selection with a hybrid k-opt and node reinsertion operator to balance diversification and intensification of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n    current_front = []\n\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            current_front.append(i)\n\n    fronts.append(current_front)\n\n    # Calculate crowding distance for the selected front\n    front_objectives = objectives[current_front]\n    crowding_distance = np.zeros(len(front_objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort(front_objectives[:, m])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n        for i in range(1, len(sorted_indices)-1):\n            crowding_distance[sorted_indices[i]] += (front_objectives[sorted_indices[i+1], m] - front_objectives[sorted_indices[i-1], m]) / (front_objectives[sorted_indices[-1], m] - front_objectives[sorted_indices[0], m] + 1e-10)\n\n    selected_index = current_front[np.argmax(crowding_distance)]\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply hybrid k-opt and node reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select a random segment of length k (2 to 4)\n        k = random.randint(2, min(4, n-1))\n        start = random.randint(0, n-k-1)\n        segment = new_solution[start:start+k]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n        # Reinsert the segment at a different position\n        insert_pos = random.randint(0, n-k-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Perform a node reinsertion\n        if n > 3:\n            node = new_solution[random.randint(0, n-1)]\n            new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5445111837618625,
            4.010342240333557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n    current_front = []\n\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            current_front.append(i)\n\n    fronts.append(current_front)\n\n    # Calculate crowding distance for the selected front\n    front_objectives = objectives[current_front]\n    crowding_distance = np.zeros(len(front_objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort(front_objectives[:, m])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n        for i in range(1, len(sorted_indices)-1):\n            crowding_distance[sorted_indices[i]] += (front_objectives[sorted_indices[i+1], m] - front_objectives[sorted_indices[i-1], m]) / (front_objectives[sorted_indices[-1], m] - front_objectives[sorted_indices[0], m] + 1e-10)\n\n    selected_index = current_front[np.argmax(crowding_distance)]\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply hybrid k-opt and node reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select a random segment of length k (2 to 4)\n        k = random.randint(2, min(4, n-1))\n        start = random.randint(0, n-k-1)\n        segment = new_solution[start:start+k]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n        # Reinsert the segment at a different position\n        insert_pos = random.randint(0, n-k-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Perform a node reinsertion\n        if n > 3:\n            node = new_solution[random.randint(0, n-1)]\n            new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{A novel local search heuristic employs a Pareto-frontier-aware selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic objective-space trade-off to explore the solution space efficiently while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto-frontier coverage\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.array([not any((objectives < obj).all(axis=1) & (objectives != obj).any(axis=1)) for obj in objectives])\n    if np.sum(pareto_front) > 0:\n        selected_idx = np.random.choice(np.where(pareto_front)[0])\n    else:\n        selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap: randomly select two edges and swap their nodes\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8150028647313574,
            2.339597761631012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto-frontier coverage\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.array([not any((objectives < obj).all(axis=1) & (objectives != obj).any(axis=1)) for obj in objectives])\n    if np.sum(pareto_front) > 0:\n        selected_idx = np.random.choice(np.where(pareto_front)[0])\n    else:\n        selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap: randomly select two edges and swap their nodes\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a dynamic segment reversal and node insertion operation to balance exploration and exploitation while avoiding local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each solution\n    crowding_distance = np.zeros(len(solutions))\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distance[sorted_idx[0]] = np.inf\n        crowding_distance[sorted_idx[-1]] = np.inf\n        for i in range(1, len(solutions)-1):\n            crowding_distance[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distance)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic segment reversal and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+3, n-1))\n\n        # Reverse the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a random node at a different position\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n        # Remove duplicate if any\n        unique_nodes, indices = np.unique(new_solution, return_index=True)\n        if len(unique_nodes) < n:\n            # If insertion caused a duplicate, remove it\n            new_solution = new_solution[indices]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9116446210686852,
            1.2380039691925049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each solution\n    crowding_distance = np.zeros(len(solutions))\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distance[sorted_idx[0]] = np.inf\n        crowding_distance[sorted_idx[-1]] = np.inf\n        for i in range(1, len(solutions)-1):\n            crowding_distance[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distance)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic segment reversal and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+3, n-1))\n\n        # Reverse the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a random node at a different position\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n        # Remove duplicate if any\n        unique_nodes, indices = np.unique(new_solution, return_index=True)\n        if len(unique_nodes) < n:\n            # If insertion caused a duplicate, remove it\n            new_solution = new_solution[indices]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This novel local search heuristic employs an adaptive objective-weighted selection of solutions from the archive, followed by a hybrid of segment-reversal and node-shuffling operations, guided by a dynamic trade-off between objectives to efficiently explore the Pareto front while preserving tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on adaptive weighted sum of objectives\n    alpha = np.random.beta(2, 2)\n    selected_solution = min(archive, key=lambda x: alpha * x[1][0] + (1 - alpha) * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment-reversal operation\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Node-shuffling operation\n        c, d = random.sample(range(1, n-1), 2)\n        while abs(c - d) < 2:\n            c, d = random.sample(range(1, n-1), 2)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7992749737199882,
            2.137540102005005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on adaptive weighted sum of objectives\n    alpha = np.random.beta(2, 2)\n    selected_solution = min(archive, key=lambda x: alpha * x[1][0] + (1 - alpha) * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment-reversal operation\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Node-shuffling operation\n        c, d = random.sample(range(1, n-1), 2)\n        while abs(c - d) < 2:\n            c, d = random.sample(range(1, n-1), 2)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This novel local search heuristic combines an objective-aware selection of solutions from the archive with a hybrid of segment-shuffling and adaptive edge-swapping operations, guided by a dynamic Pareto-dominance criterion to efficiently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shuffling operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n        # Adaptive edge-swapping operation\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = (i + random.randint(1, n//2)) % n\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            if new_cost < current_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7128618975977883,
            2.091639518737793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shuffling operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n        # Adaptive edge-swapping operation\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = (i + random.randint(1, n//2)) % n\n            current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            if new_cost < current_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid fitness metric combining normalized objective values and solution diversity, then applies a novel \"segment reversal with adaptive insertion\" operator that reverses a random segment and inserts it at a position determined by the trade-off between the two objectives, ensuring feasibility through careful validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on hybrid fitness\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n\n    # Normalize objectives and combine with diversity\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    fitness = np.mean(normalized, axis=1)  # Average of normalized objectives\n    selected_idx = np.argmin(fitness)  # Select solution with lowest fitness (best trade-off)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply segment reversal with adaptive insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1][::-1]  # Reverse the segment\n\n        # Calculate insertion position based on objective trade-off\n        obj1 = archive[selected_idx][1][0]\n        obj2 = archive[selected_idx][1][1]\n        trade_off = obj1 / (obj1 + obj2 + 1e-10)  # Normalized trade-off between objectives\n\n        # Insert segment at position determined by trade-off\n        insert_pos = int(trade_off * (n - len(segment)))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a random swap to repair\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7129064938536849,
            2.295413374900818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on hybrid fitness\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n\n    # Normalize objectives and combine with diversity\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    fitness = np.mean(normalized, axis=1)  # Average of normalized objectives\n    selected_idx = np.argmin(fitness)  # Select solution with lowest fitness (best trade-off)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply segment reversal with adaptive insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1][::-1]  # Reverse the segment\n\n        # Calculate insertion position based on objective trade-off\n        obj1 = archive[selected_idx][1][0]\n        obj2 = archive[selected_idx][1][1]\n        trade_off = obj1 / (obj1 + obj2 + 1e-10)  # Normalized trade-off between objectives\n\n        # Insert segment at position determined by trade-off\n        insert_pos = int(trade_off * (n - len(segment)))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a random swap to repair\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with lower total distance in both objectives, then applies a novel hybrid local search combining edge insertion and segment shifting to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best combined objective (inverse of sum of distances)\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply hybrid local search: edge insertion and segment shifting\n    if len(selected_solution) > 3:\n        # Random edge insertion\n        i, j = np.random.choice(len(selected_solution), size=2, replace=False)\n        node = selected_solution[i]\n        new_solution = np.delete(selected_solution, i)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Segment shifting\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n        return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.7626562963604682,
            2.3197813034057617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best combined objective (inverse of sum of distances)\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply hybrid local search: edge insertion and segment shifting\n    if len(selected_solution) > 3:\n        # Random edge insertion\n        i, j = np.random.choice(len(selected_solution), size=2, replace=False)\n        node = selected_solution[i]\n        new_solution = np.delete(selected_solution, i)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Segment shifting\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n        return new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines Pareto-dominance-based selection with a multi-phase perturbation mechanism, including adaptive node relocation and guided segment insertion, to balance exploration and exploitation in the bi-objective space while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Multi-phase perturbation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node relocation\n    if n > 3:\n        # Identify nodes with high total distance contribution\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Relocate the most problematic node\n        problematic_node = np.argmax(total_dist)\n        new_pos = random.randint(0, n-1)\n        if new_pos > problematic_node:\n            new_solution = np.concatenate([new_solution[:problematic_node], new_solution[problematic_node+1:new_pos+1], [new_solution[problematic_node]], new_solution[new_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], [new_solution[problematic_node]], new_solution[new_pos:problematic_node], new_solution[problematic_node+1:]])\n\n    # Phase 2: Guided segment insertion\n    if n > 4:\n        # Select a random segment and insert it in a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        insertion_pos = random.randint(0, n-1)\n        if insertion_pos not in range(a, b+1):\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[b+1:insertion_pos+1],\n                segment, new_solution[insertion_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel local search heuristic that combines crowding-distance-based selection with a dynamic segment reversal mechanism, followed by a guided node exchange operation, to improve solution quality while maintaining diversity in the bi-objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Dynamic segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Guided node exchange\n    if n > 4:\n        # Find nodes with high total distance contribution in both objectives\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                          distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Exchange the most problematic node with another node\n        problematic_node = np.argmax(total_dist)\n        exchange_pos = random.randint(0, n-1)\n        if exchange_pos != problematic_node:\n            new_solution[problematic_node], new_solution[exchange_pos] = new_solution[exchange_pos], new_solution[problematic_node]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4496908817063836,
            3.444458305835724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Dynamic segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Guided node exchange\n    if n > 4:\n        # Find nodes with high total distance contribution in both objectives\n        total_dist = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            total_dist[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                          distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        # Exchange the most problematic node with another node\n        problematic_node = np.argmax(total_dist)\n        exchange_pos = random.randint(0, n-1)\n        if exchange_pos != problematic_node:\n            new_solution[problematic_node], new_solution[exchange_pos] = new_solution[exchange_pos], new_solution[problematic_node]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm selects a solution from the archive based on a Pareto-dominance guided selection, then applies a novel adaptive segment insertion and edge rotation operator that dynamically adjusts the search based on the current solution's objective values, ensuring both feasibility and exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select a solution based on Pareto-dominance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply adaptive segment insertion and edge rotation\n    if len(new_solution) > 3:\n        # Select a random segment and insert it at a different position\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, np.arange(a, b+1))\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Rotate edges based on the current objective values\n        obj1, obj2 = archive[selected_idx][1]\n        if obj1 < obj2:\n            # Rotate edges to favor the first objective\n            i = np.random.randint(0, len(new_solution) - 1)\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n        else:\n            # Rotate edges to favor the second objective\n            i = np.random.randint(0, len(new_solution) - 2)\n            new_solution[i], new_solution[i+2] = new_solution[i+2], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8962411975127883,
            1.9746498465538025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select a solution based on Pareto-dominance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply adaptive segment insertion and edge rotation\n    if len(new_solution) > 3:\n        # Select a random segment and insert it at a different position\n        a, b = sorted(np.random.choice(len(new_solution), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, np.arange(a, b+1))\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Rotate edges based on the current objective values\n        obj1, obj2 = archive[selected_idx][1]\n        if obj1 < obj2:\n            # Rotate edges to favor the first objective\n            i = np.random.randint(0, len(new_solution) - 1)\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n        else:\n            # Rotate edges to favor the second objective\n            i = np.random.randint(0, len(new_solution) - 2)\n            new_solution[i], new_solution[i+2] = new_solution[i+2], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8228403155497273,
            0.5846895575523376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8228403155497273,
            0.5846895575523376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, applies a swap operator to exchange the first two nodes, and returns the modified solution as a neighbor while ensuring the tour remains valid.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a hybrid local search operator that combines node insertion with a guided edge swap to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = objectives - objectives.mean(axis=0)\n    selected_idx = np.argmax(np.sum(improvement_potential, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion with guided selection\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n        # Guided edge swap based on distance improvement\n        for _ in range(2):\n            a, b = sorted(random.sample(range(n-1), 2))\n            if b - a > 1:\n                current_cost = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n                swapped_cost = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[(b+1)%n]]\n                if swapped_cost < current_cost:\n                    new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        i = random.randint(0, n-1)\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8416368582809539,
            2.0748528242111206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = objectives - objectives.mean(axis=0)\n    selected_idx = np.argmax(np.sum(improvement_potential, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion with guided selection\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n        # Guided edge swap based on distance improvement\n        for _ in range(2):\n            a, b = sorted(random.sample(range(n-1), 2))\n            if b - a > 1:\n                current_cost = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n                swapped_cost = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[(b+1)%n]]\n                if swapped_cost < current_cost:\n                    new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        i = random.randint(0, n-1)\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a hybrid segment reversal and edge insertion operation to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        n = len(solutions)\n        if n < 2:\n            return [float('inf')] * n\n\n        objectives = [obj for _, obj in solutions]\n        distances = [0.0] * n\n\n        for m in range(2):  # For each objective\n            sorted_idx = sorted(range(n), key=lambda i: objectives[i][m])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, n-1):\n                if max(objectives[sorted_idx[-1]][m], objectives[sorted_idx[0]][m]) - min(objectives[sorted_idx[-1]][m], objectives[sorted_idx[0]][m]) == 0:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid segment reversal and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to reverse\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, min(i+3, n-1))\n\n        # Reverse the segment\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        # Randomly insert a removed edge\n        k = random.randint(0, n-2)\n        l = random.randint(0, n-2)\n        while l == k or l == (k+1) % n:\n            l = random.randint(0, n-2)\n\n        removed_node = new_solution[k+1]\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[k+2:l+1], [removed_node], new_solution[l+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5873794052276665,
            1.2385765314102173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    def calculate_crowding_distance(solutions):\n        n = len(solutions)\n        if n < 2:\n            return [float('inf')] * n\n\n        objectives = [obj for _, obj in solutions]\n        distances = [0.0] * n\n\n        for m in range(2):  # For each objective\n            sorted_idx = sorted(range(n), key=lambda i: objectives[i][m])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n\n            for i in range(1, n-1):\n                if max(objectives[sorted_idx[-1]][m], objectives[sorted_idx[0]][m]) - min(objectives[sorted_idx[-1]][m], objectives[sorted_idx[0]][m]) == 0:\n                    continue\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n        return distances\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid segment reversal and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to reverse\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, min(i+3, n-1))\n\n        # Reverse the segment\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        # Randomly insert a removed edge\n        k = random.randint(0, n-2)\n        l = random.randint(0, n-2)\n        while l == k or l == (k+1) % n:\n            l = random.randint(0, n-2)\n\n        removed_node = new_solution[k+1]\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[k+2:l+1], [removed_node], new_solution[l+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{A novel local search heuristic dynamically balances objective trade-offs using adaptive weights, applies a hybrid of edge-swap and segment-reversal with probabilistic segment selection, and employs a feasibility-preserving fallback to ensure high-quality, diverse neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution with adaptive objective weighting\n    weights = np.random.dirichlet([0.7, 0.3])  # Bias towards first objective\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[np.random.choice(min(5, len(ranked_solutions)))][0].copy()\n\n    # Step 2: Apply hybrid local search with probabilistic segment selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge-swap with probability 0.6\n        if random.random() < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Segment-reversal with adaptive length\n        segment_len = max(2, min(5, int(np.random.normal(3, 1))))\n        a = random.randint(0, n - segment_len)\n        new_solution[a:a+segment_len] = new_solution[a:a+segment_len][::-1]\n\n    # Ensure feasibility with enhanced fallback\n    if len(np.unique(new_solution)) != n:\n        # Use 3-opt for more complex repair\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7879657508369788,
            2.2914592623710632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution with adaptive objective weighting\n    weights = np.random.dirichlet([0.7, 0.3])  # Bias towards first objective\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[np.random.choice(min(5, len(ranked_solutions)))][0].copy()\n\n    # Step 2: Apply hybrid local search with probabilistic segment selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge-swap with probability 0.6\n        if random.random() < 0.6:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Segment-reversal with adaptive length\n        segment_len = max(2, min(5, int(np.random.normal(3, 1))))\n        a = random.randint(0, n - segment_len)\n        new_solution[a:a+segment_len] = new_solution[a:a+segment_len][::-1]\n\n    # Ensure feasibility with enhanced fallback\n    if len(np.unique(new_solution)) != n:\n        # Use 3-opt for more complex repair\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines tournament selection with a hybrid of adaptive segment rotation and guided node reinsertion, using a weighted multi-objective cost metric to balance exploration and exploitation while ensuring feasibility through constrained insertion points.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Tournament selection of promising solutions\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected_solution = min(selected, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Step 2: Hybrid segment rotation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate weighted cost metric\n        weighted_cost = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            weighted_cost[i] = 0.6 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.4 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and rotate segment\n        segment_size = min(4, n // 4)\n        segment_start = np.argmax(weighted_cost)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Rotate segment\n        rotation = random.randint(1, segment_size-1) if segment_size > 1 else 0\n        rotated_segment = np.roll(segment, rotation)\n\n        new_solution = np.concatenate([\n            new_solution[:segment_start], rotated_segment, new_solution[segment_end:]\n        ])\n\n    # Step 3: Guided node reinsertion with constraints\n    if n > 5:\n        # Calculate insertion cost with constraints\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.7 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.3 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This novel algorithm implements a dynamic objective-aware path segmentation and recombination strategy that combines adaptive segment partitioning with guided crossover-inspired operations, using a multi-objective cost metric to identify critical path segments and intelligently merge them while maintaining tour feasibility through constrained insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Dynamic segment identification\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_length-1)\n        segment1 = new_solution[start:start+segment_length]\n\n        # Find complementary segment based on multi-objective cost\n        costs = np.zeros(n-segment_length)\n        for i in range(n-segment_length):\n            segment2 = new_solution[i:i+segment_length]\n            cost1 = sum(distance_matrix_1[segment1[j], segment2[j]] for j in range(segment_length))\n            cost2 = sum(distance_matrix_2[segment1[j], segment2[j]] for j in range(segment_length))\n            costs[i] = 0.5 * cost1 + 0.5 * cost2\n\n        best_match = np.argmin(costs)\n        segment2 = new_solution[best_match:best_match+segment_length]\n\n        # Recombine segments\n        new_segment = np.concatenate([segment1, segment2[::-1]])\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_segment,\n            new_solution[start+segment_length:]\n        ])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            # Fallback to constrained swap\n            valid_swaps = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    if i != j and (i == 0 or j != 0):\n                        valid_swaps.append((i, j))\n            if valid_swaps:\n                i, j = random.choice(valid_swaps)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8711555384744123,
            1.1900806427001953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Dynamic segment identification\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_length-1)\n        segment1 = new_solution[start:start+segment_length]\n\n        # Find complementary segment based on multi-objective cost\n        costs = np.zeros(n-segment_length)\n        for i in range(n-segment_length):\n            segment2 = new_solution[i:i+segment_length]\n            cost1 = sum(distance_matrix_1[segment1[j], segment2[j]] for j in range(segment_length))\n            cost2 = sum(distance_matrix_2[segment1[j], segment2[j]] for j in range(segment_length))\n            costs[i] = 0.5 * cost1 + 0.5 * cost2\n\n        best_match = np.argmin(costs)\n        segment2 = new_solution[best_match:best_match+segment_length]\n\n        # Recombine segments\n        new_segment = np.concatenate([segment1, segment2[::-1]])\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_segment,\n            new_solution[start+segment_length:]\n        ])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            # Fallback to constrained swap\n            valid_swaps = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    if i != j and (i == 0 or j != 0):\n                        valid_swaps.append((i, j))\n            if valid_swaps:\n                i, j = random.choice(valid_swaps)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This novel algorithm combines a diversity-aware selection mechanism with a hybrid local search operator that dynamically adapts its exploration/exploitation based on the current Pareto front's properties, using a combination of adaptive segment relinking and probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select a solution with good diversity and objective balance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance for diversity\n    crowding = np.zeros(len(solutions))\n    for m in range(2):\n        sorted_idx = np.argsort([obj[m] for obj in objectives])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(solutions)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max(objectives[sorted_idx[-1]][m], 1e-6) - min(objectives[sorted_idx[0]][m], 1e-6))\n\n    # Select solution with best crowding distance (diversity) and good objective balance\n    selection_scores = [crowding[i] * (1 - 0.5 * (objectives[i][0] + objectives[i][1]) / (sum(obj[0] + obj[1] for obj in objectives) + 1e-6))\n                       for i in range(len(solutions))]\n    selected_idx = np.argmax(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Adaptive hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment relinking\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = base_solution[a:b+1]\n\n        # Calculate segment quality based on both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # With probability based on segment quality, relink or insert\n        relink_prob = 0.5 * (1 - (seg_cost1 + seg_cost2) / (sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(1, n)) +\n                                                           sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(1, n)) + 1e-6))\n\n        if np.random.rand() < relink_prob:\n            # Relink the segment\n            new_pos = np.random.randint(n)\n            new_solution = np.concatenate([base_solution[:new_pos], segment, np.setdiff1d(base_solution, segment)])\n        else:\n            # Insert the segment at a different position\n            new_pos = np.random.randint(n)\n            new_solution = np.concatenate([base_solution[:new_pos], segment, np.setdiff1d(base_solution, segment)])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal if invalid\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8673765114774254,
            3.1168214678764343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Step 1: Select a solution with good diversity and objective balance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance for diversity\n    crowding = np.zeros(len(solutions))\n    for m in range(2):\n        sorted_idx = np.argsort([obj[m] for obj in objectives])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(solutions)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max(objectives[sorted_idx[-1]][m], 1e-6) - min(objectives[sorted_idx[0]][m], 1e-6))\n\n    # Select solution with best crowding distance (diversity) and good objective balance\n    selection_scores = [crowding[i] * (1 - 0.5 * (objectives[i][0] + objectives[i][1]) / (sum(obj[0] + obj[1] for obj in objectives) + 1e-6))\n                       for i in range(len(solutions))]\n    selected_idx = np.argmax(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Adaptive hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment relinking\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = base_solution[a:b+1]\n\n        # Calculate segment quality based on both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # With probability based on segment quality, relink or insert\n        relink_prob = 0.5 * (1 - (seg_cost1 + seg_cost2) / (sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(1, n)) +\n                                                           sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(1, n)) + 1e-6))\n\n        if np.random.rand() < relink_prob:\n            # Relink the segment\n            new_pos = np.random.randint(n)\n            new_solution = np.concatenate([base_solution[:new_pos], segment, np.setdiff1d(base_solution, segment)])\n        else:\n            # Insert the segment at a different position\n            new_pos = np.random.randint(n)\n            new_solution = np.concatenate([base_solution[:new_pos], segment, np.setdiff1d(base_solution, segment)])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal if invalid\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm combines a Pareto-frontier biased selection with a novel segment-swap and edge-reversal operator that intelligently combines elements from multiple solutions while maintaining feasibility through a multi-phase validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution near the Pareto frontier with high improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other in objectives:\n            if (other[0] < obj[0] and other[1] < obj[1]) and not (other[0] == obj[0] and other[1] == obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid segment-swap and edge-reversal\n    n = len(base_solution)\n    if n > 3:\n        # Segment-swap between two random segments from different solutions\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = base_solution[a:b+1]\n        segment2 = other_solution[c:d+1]\n\n        # Create new segments by combining elements\n        new_segment1 = np.concatenate([segment1, segment2])\n        new_segment2 = np.concatenate([segment2, segment1])\n\n        # Apply to base solution\n        base_solution[a:b+1] = new_segment1[:len(segment1)]\n        base_solution[c:d+1] = new_segment2[:len(segment2)]\n\n        # Edge-reversal: reverse edges between random nodes\n        i, j = sorted(random.sample(range(n), 2))\n        base_solution[i:j] = base_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(base_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(base_solution)\n        base_solution = np.delete(base_solution, np.where(base_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        base_solution = np.insert(base_solution, insert_pos, node_to_move)\n\n    return base_solution\n\n",
        "score": [
            -0.6446663644708351,
            2.083016514778137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution near the Pareto frontier with high improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other in objectives:\n            if (other[0] < obj[0] and other[1] < obj[1]) and not (other[0] == obj[0] and other[1] == obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid segment-swap and edge-reversal\n    n = len(base_solution)\n    if n > 3:\n        # Segment-swap between two random segments from different solutions\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = base_solution[a:b+1]\n        segment2 = other_solution[c:d+1]\n\n        # Create new segments by combining elements\n        new_segment1 = np.concatenate([segment1, segment2])\n        new_segment2 = np.concatenate([segment2, segment1])\n\n        # Apply to base solution\n        base_solution[a:b+1] = new_segment1[:len(segment1)]\n        base_solution[c:d+1] = new_segment2[:len(segment2)]\n\n        # Edge-reversal: reverse edges between random nodes\n        i, j = sorted(random.sample(range(n), 2))\n        base_solution[i:j] = base_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(base_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(base_solution)\n        base_solution = np.delete(base_solution, np.where(base_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        base_solution = np.insert(base_solution, insert_pos, node_to_move)\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{A novel local search heuristic combines a Pareto-frontier biased selection of solutions from the archive, followed by a dynamic node clustering and reordering operation, guided by a multi-objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    pareto_front = []\n    objectives = [obj for _, obj in archive]\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node clustering and reordering\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Cluster nodes based on their positions in both objective spaces\n        node_coords = instance[new_solution]\n        cluster_assignments = np.zeros(n, dtype=int)\n        k = min(3, n // 2)  # Number of clusters\n\n        # Simple k-means clustering\n        centroids = node_coords[np.random.choice(n, k, replace=False), :]\n        for _ in range(5):  # Few iterations for clustering\n            distances = np.zeros((n, k))\n            for i in range(k):\n                distances[:, i] = np.linalg.norm(node_coords - centroids[i], axis=1)\n            cluster_assignments = np.argmin(distances, axis=1)\n            for i in range(k):\n                if np.sum(cluster_assignments == i) > 0:\n                    centroids[i] = np.mean(node_coords[cluster_assignments == i], axis=0)\n\n        # Reorder nodes by cluster and then by distance to cluster centroid\n        sorted_indices = []\n        for cluster in range(k):\n            cluster_nodes = np.where(cluster_assignments == cluster)[0]\n            if len(cluster_nodes) > 0:\n                cluster_centroid = centroids[cluster]\n                distances_to_centroid = np.linalg.norm(node_coords[cluster_nodes] - cluster_centroid, axis=1)\n                sorted_cluster = cluster_nodes[np.argsort(distances_to_centroid)]\n                sorted_indices.extend(sorted_cluster)\n\n        new_solution = new_solution[sorted_indices]\n\n        # Apply random local perturbations\n        if random.random() < 0.3:  # 30% chance of perturbation\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8359069091866772,
            7.003540813922882
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    pareto_front = []\n    objectives = [obj for _, obj in archive]\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node clustering and reordering\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Cluster nodes based on their positions in both objective spaces\n        node_coords = instance[new_solution]\n        cluster_assignments = np.zeros(n, dtype=int)\n        k = min(3, n // 2)  # Number of clusters\n\n        # Simple k-means clustering\n        centroids = node_coords[np.random.choice(n, k, replace=False), :]\n        for _ in range(5):  # Few iterations for clustering\n            distances = np.zeros((n, k))\n            for i in range(k):\n                distances[:, i] = np.linalg.norm(node_coords - centroids[i], axis=1)\n            cluster_assignments = np.argmin(distances, axis=1)\n            for i in range(k):\n                if np.sum(cluster_assignments == i) > 0:\n                    centroids[i] = np.mean(node_coords[cluster_assignments == i], axis=0)\n\n        # Reorder nodes by cluster and then by distance to cluster centroid\n        sorted_indices = []\n        for cluster in range(k):\n            cluster_nodes = np.where(cluster_assignments == cluster)[0]\n            if len(cluster_nodes) > 0:\n                cluster_centroid = centroids[cluster]\n                distances_to_centroid = np.linalg.norm(node_coords[cluster_nodes] - cluster_centroid, axis=1)\n                sorted_cluster = cluster_nodes[np.argsort(distances_to_centroid)]\n                sorted_indices.extend(sorted_cluster)\n\n        new_solution = new_solution[sorted_indices]\n\n        # Apply random local perturbations\n        if random.random() < 0.3:  # 30% chance of perturbation\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines tournament selection with a hybrid of adaptive segment rotation and guided node reinsertion, using a weighted multi-objective cost metric to balance exploration and exploitation while ensuring feasibility through constrained insertion points.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Tournament selection of promising solutions\n    tournament_size = min(5, len(archive))\n    selected = random.sample(archive, tournament_size)\n    selected_solution = min(selected, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Step 2: Hybrid segment rotation mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate weighted cost metric\n        weighted_cost = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            weighted_cost[i] = 0.6 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.4 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and rotate segment\n        segment_size = min(4, n // 4)\n        segment_start = np.argmax(weighted_cost)\n        segment_end = (segment_start + segment_size) % n\n        segment = new_solution[segment_start:segment_end]\n\n        # Rotate segment\n        rotation = random.randint(1, segment_size-1) if segment_size > 1 else 0\n        rotated_segment = np.roll(segment, rotation)\n\n        new_solution = np.concatenate([\n            new_solution[:segment_start], rotated_segment, new_solution[segment_end:]\n        ])\n\n    # Step 3: Guided node reinsertion with constraints\n    if n > 5:\n        # Calculate insertion cost with constraints\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.7 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.3 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This novel local search heuristic combines dynamic objective-based solution selection with a hybrid of adaptive segment swapping and constrained node insertion, using a multi-objective cost metric to balance exploration and exploitation while ensuring feasibility through constrained segment boundaries and insertion points.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Hybrid segment swapping mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate segment costs\n        segment_costs = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            segment_costs[i] = 0.5 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.5 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and swap segments\n        segment_size = min(3, n // 3)\n        segment1_start = np.argmax(segment_costs)\n        segment1_end = (segment1_start + segment_size) % n\n        segment1 = new_solution[segment1_start:segment1_end]\n\n        segment2_start = np.argmin(segment_costs)\n        segment2_end = (segment2_start + segment_size) % n\n        segment2 = new_solution[segment2_start:segment2_end]\n\n        if segment1_start < segment2_start:\n            new_solution = np.concatenate([\n                new_solution[:segment1_start], segment2, new_solution[segment1_end:segment2_start], segment1, new_solution[segment2_end:]\n            ])\n        else:\n            new_solution = np.concatenate([\n                new_solution[:segment2_start], segment1, new_solution[segment2_end:segment1_start], segment2, new_solution[segment1_end:]\n            ])\n\n    # Step 3: Constrained node insertion\n    if n > 5:\n        # Calculate insertion costs\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.4 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.6 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7635717656881869,
            3.1390998363494873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Hybrid segment swapping mechanism\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Calculate segment costs\n        segment_costs = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            segment_costs[i] = 0.5 * (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) + 0.5 * (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select and swap segments\n        segment_size = min(3, n // 3)\n        segment1_start = np.argmax(segment_costs)\n        segment1_end = (segment1_start + segment_size) % n\n        segment1 = new_solution[segment1_start:segment1_end]\n\n        segment2_start = np.argmin(segment_costs)\n        segment2_end = (segment2_start + segment_size) % n\n        segment2 = new_solution[segment2_start:segment2_end]\n\n        if segment1_start < segment2_start:\n            new_solution = np.concatenate([\n                new_solution[:segment1_start], segment2, new_solution[segment1_end:segment2_start], segment1, new_solution[segment2_end:]\n            ])\n        else:\n            new_solution = np.concatenate([\n                new_solution[:segment2_start], segment1, new_solution[segment2_end:segment1_start], segment2, new_solution[segment1_end:]\n            ])\n\n    # Step 3: Constrained node insertion\n    if n > 5:\n        # Calculate insertion costs\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            insertion_costs[i] = 0.4 * (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) + 0.6 * (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n        # Remove and reinsert node with highest cost\n        problematic_node = np.argmax(insertion_costs)\n        node_to_move = new_solution[problematic_node]\n        new_solution = np.concatenate([\n            new_solution[:problematic_node], new_solution[problematic_node+1:]\n        ])\n\n        # Find constrained insertion points\n        candidate_positions = []\n        for i in range(len(new_solution)):\n            if i > 0 and i < len(new_solution)-1:\n                candidate_positions.append(i)\n\n        if candidate_positions:\n            insert_pos = random.choice(candidate_positions)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to constrained swap\n        valid_swaps = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if i != j and (i == 0 or j != 0):\n                    valid_swaps.append((i, j))\n        if valid_swaps:\n            i, j = random.choice(valid_swaps)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This novel local search heuristic combines a crowding-distance-based selection of solutions from the archive with a hybrid of node-relocation and segment-reversal operations, guided by an adaptive normalization of objective values to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(normalized[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += normalized[sorted_indices[j+1], i] - normalized[sorted_indices[j-1], i]\n\n    selected_index = np.argmax(crowding_distances)\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.532706728730306,
            4.301231682300568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(normalized[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += normalized[sorted_indices[j+1], i] - normalized[sorted_indices[j-1], i]\n\n    selected_index = np.argmax(crowding_distances)\n    selected_solution = archive[selected_index][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of node-swapping and path-relinking operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path-relinking operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This novel local search heuristic incorporates a multi-objective selection based on adaptive dominance criteria, followed by a hybrid of segment reversal and node insertion operations, guided by a dynamic trade-off between objectives to efficiently explore the Pareto front while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive dominance\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    weights = np.random.dirichlet([1, 1])\n    selected_idx = np.argmin(np.dot(normalized, weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal operation\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.920193434725712,
            0.8542215824127197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive dominance\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    weights = np.random.dirichlet([1, 1])\n    selected_idx = np.argmin(np.dot(normalized, weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal operation\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a biased random selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to escape local optima and improve solution quality.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Sort solutions by a weighted sum of objectives (dynamic weights)\n    weights = np.random.dirichlet([1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge-swap + segment-reversal\n    if n > 3:\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Swap edges (i, i+1) and (j, j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This novel local search heuristic combines a multi-objective selection based on a dynamic utility function with a hybrid of node-swap and segment-rotation operations, guided by adaptive weights to balance exploration and exploitation while avoiding local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using a dynamic utility function\n    weights = np.random.dirichlet([1, 1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1] + weights[2] * (x[1][0] * x[1][1]))\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swap operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-rotation operation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, (c - a) % len(segment))\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6352336507557861,
            1.3941553235054016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using a dynamic utility function\n    weights = np.random.dirichlet([1, 1, 1])  # Random weights for trade-off\n    ranked_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1] + weights[2] * (x[1][0] * x[1][1]))\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swap operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-rotation operation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, (c - a) % len(segment))\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search with segment inversion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9273527289216823,
            1.2068572640419006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search with segment inversion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{A new algorithm selects solutions from the archive based on a weighted sum of normalized objective values and edge diversity, then applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using weighted sum of normalized objectives and edge diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for each objective\n    weighted_scores = np.dot(normalized_obj, weights)\n\n    # Calculate edge diversity (number of unique edges in the tour)\n    diversity_scores = []\n    for sol, _ in archive:\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity_scores.append(len(edges))\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = weighted_scores + 0.3 * (diversity_scores / diversity_scores.max())\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search - segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            # Remove two nodes and insert them in a different position\n            removed = new_solution[i+1:j]\n            new_solution = np.delete(new_solution, slice(i+1, j))\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, removed)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5434485685596986,
            2.4462159276008606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using weighted sum of normalized objectives and edge diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for each objective\n    weighted_scores = np.dot(normalized_obj, weights)\n\n    # Calculate edge diversity (number of unique edges in the tour)\n    diversity_scores = []\n    for sol, _ in archive:\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity_scores.append(len(edges))\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = weighted_scores + 0.3 * (diversity_scores / diversity_scores.max())\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search - segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            # Remove two nodes and insert them in a different position\n            removed = new_solution[i+1:j]\n            new_solution = np.delete(new_solution, slice(i+1, j))\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, removed)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{A novel local search heuristic combines a crowding-distance-based selection of solutions from the archive, followed by a hybrid of edge-swapping and segment-reversal operations, guided by a dynamic objective-space trade-off to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        sorted_indices = np.argsort(objectives[:, 0])\n        rank = np.where(sorted_indices == i)[0][0]\n        if rank == 0 or rank == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            left = objectives[sorted_indices[rank - 1]]\n            right = objectives[sorted_indices[rank + 1]]\n            crowding_distances[i] = np.abs(objectives[i, 0] - left[0]) + np.abs(objectives[i, 1] - left[1]) + \\\n                                   np.abs(objectives[i, 0] - right[0]) + np.abs(objectives[i, 1] - right[1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping: randomly swap two adjacent edges\n        swap_pos = random.randint(0, n-2)\n        new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random edge swap if invalid\n        swap_pos = random.randint(0, n-2)\n        new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    return new_solution\n\n",
        "score": [
            -0.37977622631184904,
            3.2718093395233154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        sorted_indices = np.argsort(objectives[:, 0])\n        rank = np.where(sorted_indices == i)[0][0]\n        if rank == 0 or rank == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            left = objectives[sorted_indices[rank - 1]]\n            right = objectives[sorted_indices[rank + 1]]\n            crowding_distances[i] = np.abs(objectives[i, 0] - left[0]) + np.abs(objectives[i, 1] - left[1]) + \\\n                                   np.abs(objectives[i, 0] - right[0]) + np.abs(objectives[i, 1] - right[1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping: randomly swap two adjacent edges\n        swap_pos = random.randint(0, n-2)\n        new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random edge swap if invalid\n        swap_pos = random.randint(0, n-2)\n        new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This novel local search heuristic employs a crowding-distance-based selection of solutions from the archive, followed by a hybrid of edge-swapping and path-relinking operations, guided by a dynamic weighting of objectives to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, obj in archive]\n    objectives = np.array([obj for sol, obj in archive])\n\n    if len(archive) == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Normalize objectives\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance\n        sorted_indices = np.argsort(normalized_obj[:, 0])\n        crowding_dist = np.zeros(len(archive))\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[i]] += (normalized_obj[sorted_indices[i+1], 0] - normalized_obj[sorted_indices[i-1], 0])\n\n        sorted_indices = np.argsort(normalized_obj[:, 1])\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[i]] += (normalized_obj[sorted_indices[i+1], 1] - normalized_obj[sorted_indices[i-1], 1])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_dist)\n        selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n-1)\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.49743732052395506,
            1.6149736046791077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, obj in archive]\n    objectives = np.array([obj for sol, obj in archive])\n\n    if len(archive) == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Normalize objectives\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n        # Calculate crowding distance\n        sorted_indices = np.argsort(normalized_obj[:, 0])\n        crowding_dist = np.zeros(len(archive))\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[i]] += (normalized_obj[sorted_indices[i+1], 0] - normalized_obj[sorted_indices[i-1], 0])\n\n        sorted_indices = np.argsort(normalized_obj[:, 1])\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[i]] += (normalized_obj[sorted_indices[i+1], 1] - normalized_obj[sorted_indices[i-1], 1])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_dist)\n        selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n-1)\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7134986225460939,
            0.636914849281311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This novel algorithm employs a dominance-based selection of solutions from the archive, combined with a hybrid of edge-swapping and segment-insertion operations, dynamically adapting the search to both objective spaces by utilizing a weighted distance metric to guide exploration toward less crowded Pareto-optimal regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective distance\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n\n    # Calculate dominance score\n    dominance_scores = []\n    for i in range(len(objectives)):\n        dominated = 0\n        for j in range(len(objectives)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]:\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    # Calculate weighted distance to ideal point\n    distance_scores = []\n    for obj in objectives:\n        dist1 = abs(obj[0] - min_obj1)\n        dist2 = abs(obj[1] - min_obj2)\n        distance_scores.append(0.6 * dist1 + 0.4 * dist2)\n\n    # Combine scores\n    combined_scores = [d + 0.1 * dist for d, dist in zip(dominance_scores, distance_scores)]\n    selected_idx = combined_scores.index(min(combined_scores))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n\n        # Swap edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment insertion operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6287891513935732,
            2.1205419301986694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective distance\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n\n    # Calculate dominance score\n    dominance_scores = []\n    for i in range(len(objectives)):\n        dominated = 0\n        for j in range(len(objectives)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]:\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    # Calculate weighted distance to ideal point\n    distance_scores = []\n    for obj in objectives:\n        dist1 = abs(obj[0] - min_obj1)\n        dist2 = abs(obj[1] - min_obj2)\n        distance_scores.append(0.6 * dist1 + 0.4 * dist2)\n\n    # Combine scores\n    combined_scores = [d + 0.1 * dist for d, dist in zip(dominance_scores, distance_scores)]\n    selected_idx = combined_scores.index(min(combined_scores))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n\n        # Swap edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment insertion operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{A novel algorithm combines Pareto-dominance-based solution selection with a multi-segment crossover and adaptive node insertion operator, guided by both objective improvements and diversity preservation to efficiently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with best combined objective improvement potential\n    best_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / (distance_matrix_1[x[0][0], x[0][-1]] + distance_matrix_2[x[0][0], x[0][-1]]))[0].copy()\n\n    # Apply multi-segment crossover with adaptive node insertion\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select two random segments and cross them\n        a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Insert segments at random positions\n        insert_pos1 = np.random.randint(0, n)\n        insert_pos2 = np.random.randint(0, n)\n\n        # Create new solution by combining segments\n        temp = np.concatenate([new_solution[:insert_pos1], segment2, new_solution[insert_pos1:insert_pos2], segment1, new_solution[insert_pos2:]])\n\n        # Remove duplicates while preserving order\n        _, unique_indices = np.unique(temp, return_index=True)\n        new_solution = temp[np.sort(unique_indices)]\n\n        # Truncate if too long\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n        elif len(new_solution) < n:\n            # Insert missing nodes at random positions\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution)+1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6019124919395376,
            3.5372418761253357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with best combined objective improvement potential\n    best_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / (distance_matrix_1[x[0][0], x[0][-1]] + distance_matrix_2[x[0][0], x[0][-1]]))[0].copy()\n\n    # Apply multi-segment crossover with adaptive node insertion\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select two random segments and cross them\n        a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Insert segments at random positions\n        insert_pos1 = np.random.randint(0, n)\n        insert_pos2 = np.random.randint(0, n)\n\n        # Create new solution by combining segments\n        temp = np.concatenate([new_solution[:insert_pos1], segment2, new_solution[insert_pos1:insert_pos2], segment1, new_solution[insert_pos2:]])\n\n        # Remove duplicates while preserving order\n        _, unique_indices = np.unique(temp, return_index=True)\n        new_solution = temp[np.sort(unique_indices)]\n\n        # Truncate if too long\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n        elif len(new_solution) < n:\n            # Insert missing nodes at random positions\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution)+1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware criterion, then applies a novel hybrid local search combining node insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with highest diversity (distance from average objectives)\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n    selected = max(archive, key=lambda x: abs(x[1][0] - avg_obj1) + abs(x[1][1] - avg_obj2))[0].copy()\n\n    # Apply hybrid local search: node insertion and segment rotation\n    if len(selected) > 3:\n        # Random node insertion\n        i = np.random.randint(len(selected))\n        node = selected[i]\n        selected = np.delete(selected, i)\n        j = np.random.randint(len(selected))\n        selected = np.insert(selected, j, node)\n\n        # Segment rotation (shift left by random amount)\n        k = np.random.randint(1, len(selected)-1)\n        selected[k:] = np.roll(selected[k:], -k)\n\n    return selected\n\n",
        "score": [
            -0.6056403975713179,
            2.3141990900039673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with highest diversity (distance from average objectives)\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n    selected = max(archive, key=lambda x: abs(x[1][0] - avg_obj1) + abs(x[1][1] - avg_obj2))[0].copy()\n\n    # Apply hybrid local search: node insertion and segment rotation\n    if len(selected) > 3:\n        # Random node insertion\n        i = np.random.randint(len(selected))\n        node = selected[i]\n        selected = np.delete(selected, i)\n        j = np.random.randint(len(selected))\n        selected = np.insert(selected, j, node)\n\n        # Segment rotation (shift left by random amount)\n        k = np.random.randint(1, len(selected)-1)\n        selected[k:] = np.roll(selected[k:], -k)\n\n    return selected\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{A novel local search heuristic combines a crowding-distance-aware selection of solutions from the archive, followed by a hybrid of edge-swap and segment-reversal operations, guided by a dynamic objective-space trade-off to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in the archive\n    objectives = np.array([obj for _, obj in archive])\n    distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        sorted_indices = np.argsort(objectives[:, 0])\n        rank = np.where(sorted_indices == i)[0][0]\n        if rank == 0 or rank == len(archive) - 1:\n            distances[i] = float('inf')\n        else:\n            distances[i] = (objectives[sorted_indices[rank + 1], 0] - objectives[sorted_indices[rank - 1], 0]) / (objectives.max(axis=0)[0] - objectives.min(axis=0)[0])\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap: swap two adjacent edges\n        a = random.randint(0, n - 2)\n        new_solution[a], new_solution[a + 1] = new_solution[a + 1], new_solution[a]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        a = random.randint(0, n - 2)\n        new_solution[a], new_solution[a + 1] = new_solution[a + 1], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.41505265600238705,
            7.300532400608063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in the archive\n    objectives = np.array([obj for _, obj in archive])\n    distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        sorted_indices = np.argsort(objectives[:, 0])\n        rank = np.where(sorted_indices == i)[0][0]\n        if rank == 0 or rank == len(archive) - 1:\n            distances[i] = float('inf')\n        else:\n            distances[i] = (objectives[sorted_indices[rank + 1], 0] - objectives[sorted_indices[rank - 1], 0]) / (objectives.max(axis=0)[0] - objectives.min(axis=0)[0])\n    selected_idx = np.argmax(distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap: swap two adjacent edges\n        a = random.randint(0, n - 2)\n        new_solution[a], new_solution[a + 1] = new_solution[a + 1], new_solution[a]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        a = random.randint(0, n - 2)\n        new_solution[a], new_solution[a + 1] = new_solution[a + 1], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel hybrid local search combining edge flipping and segment transposition to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best combined objective (0.6 for first objective, 0.4 for second)\n    best_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: edge flip and segment transposition\n    if len(best_solution) > 3:\n        # Edge flip: reverse a random segment of length 2\n        i = np.random.randint(0, len(best_solution) - 1)\n        best_solution[i:i+2] = best_solution[i:i+2][::-1]\n\n        # Segment transposition: move a random segment to a different position\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        segment = best_solution[a:b+1]\n        remaining = np.concatenate([best_solution[:a], best_solution[b+1:]])\n        pos = np.random.randint(0, len(remaining) + 1)\n        best_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n    return best_solution\n\n",
        "score": [
            -0.9134569483416081,
            1.2506980299949646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best combined objective (0.6 for first objective, 0.4 for second)\n    best_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: edge flip and segment transposition\n    if len(best_solution) > 3:\n        # Edge flip: reverse a random segment of length 2\n        i = np.random.randint(0, len(best_solution) - 1)\n        best_solution[i:i+2] = best_solution[i:i+2][::-1]\n\n        # Segment transposition: move a random segment to a different position\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        segment = best_solution[a:b+1]\n        remaining = np.concatenate([best_solution[:a], best_solution[b+1:]])\n        pos = np.random.randint(0, len(remaining) + 1)\n        best_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{A novel local search heuristic selects a solution from the archive based on a Pareto-dominance aware selection criterion, then applies a dynamic node insertion and path reordering operation guided by a multi-objective improvement metric to efficiently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on Pareto dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = set()\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.add(i)\n\n    if pareto_front:\n        selected_idx = random.choice(list(pareto_front))\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node insertion and path reordering\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node and insert it in a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reorder a random segment based on distance improvement\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        segment_costs = [distance_matrix_1[segment[i-1], segment[i]] + distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))]\n        if len(segment_costs) > 1:\n            if random.random() < 0.5:\n                segment = sorted(segment, key=lambda x: sum(distance_matrix_1[x, :] + distance_matrix_2[x, :]))\n            else:\n                segment = sorted(segment, key=lambda x: sum(distance_matrix_1[:, x] + distance_matrix_2[:, x]), reverse=True)\n            new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7724548121930073,
            2.7221044301986694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on Pareto dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = set()\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.add(i)\n\n    if pareto_front:\n        selected_idx = random.choice(list(pareto_front))\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node insertion and path reordering\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node and insert it in a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reorder a random segment based on distance improvement\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        segment_costs = [distance_matrix_1[segment[i-1], segment[i]] + distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))]\n        if len(segment_costs) > 1:\n            if random.random() < 0.5:\n                segment = sorted(segment, key=lambda x: sum(distance_matrix_1[x, :] + distance_matrix_2[x, :]))\n            else:\n                segment = sorted(segment, key=lambda x: sum(distance_matrix_1[:, x] + distance_matrix_2[:, x]), reverse=True)\n            new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm uses a hybrid of adaptive segment rotation and biased edge insertion to exploit spatial correlations in both objective spaces, while maintaining feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        k = random.randint(2, min(5, n//2))\n        i = random.randint(0, n-1)\n        segment = new_solution[i:i+k]\n        rotated = np.roll(segment, random.randint(1, k-1))\n        new_solution[i:i+k] = rotated\n\n        # Biased edge insertion\n        j = random.randint(0, n-1)\n        while j == i or j == i+k-1:\n            j = random.randint(0, n-1)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6627579367174632,
            1.1056714057922363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        k = random.randint(2, min(5, n//2))\n        i = random.randint(0, n-1)\n        segment = new_solution[i:i+k]\n        rotated = np.roll(segment, random.randint(1, k-1))\n        new_solution[i:i+k] = rotated\n\n        # Biased edge insertion\n        j = random.randint(0, n-1)\n        while j == i or j == i+k-1:\n            j = random.randint(0, n-1)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-swap and segment-reversal operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9366600896208233,
            1.623308002948761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This novel algorithm incorporates a dominance-based selection with adaptive segment reversal and insertion, utilizing both spatial and objective-based proximity to guide the search towards Pareto-optimal regions while maintaining feasibility through dynamic segment handling.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Step 1: Select a solution using dominance count\n    dominance_counts = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    dominance_counts[j] += 1\n    selected_idx = np.argmin(dominance_counts)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply adaptive segment reversal and insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Insertion\n        k = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:k], reversed_segment, new_solution[k:]])\n\n        # Trim to original length\n        new_solution = new_solution[:n]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.783744994014816,
            2.158802807331085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Step 1: Select a solution using dominance count\n    dominance_counts = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    dominance_counts[j] += 1\n    selected_idx = np.argmin(dominance_counts)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply adaptive segment reversal and insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Insertion\n        k = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:k], reversed_segment, new_solution[k:]])\n\n        # Trim to original length\n        new_solution = new_solution[:n]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a dynamic trade-off between objectives, applies a combination of node-swap and segment-reversal operations to explore the search space, and uses a probabilistic acceptance criterion to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic trade-off\n    total_costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / total_costs\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal operation\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9041702657954962,
            1.8595625758171082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic trade-off\n    total_costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = 1 / total_costs\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swap operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal operation\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9295150429011738,
            0.674144983291626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This novel local search heuristic combines Pareto-dominance-based solution selection with a dynamic hybrid of node swapping and segment reversal operations, guided by a dynamic objective trade-off to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and crowding distance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select based on crowding distance\n        crowding = []\n        for sol, obj in archive:\n            dist = 0\n            for other_sol, other_obj in archive:\n                dist += (abs(obj[0] - other_obj[0]) + abs(obj[1] - other_obj[1]))\n            crowding.append((sol, dist))\n        crowding.sort(key=lambda x: x[1], reverse=True)\n        selected_solution = crowding[0][0].copy()\n    else:\n        # Among non-dominated, select based on objective trade-off\n        weights = [0.3, 0.7] if random.random() < 0.5 else [0.7, 0.3]\n        selected_solution = min(non_dominated, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid node swapping and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swapping operation\n        i, j = random.sample(range(n), 2)\n        while abs(i - j) < 2:  # Ensure not adjacent\n            i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7549127129992868,
            1.4834076166152954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and crowding distance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select based on crowding distance\n        crowding = []\n        for sol, obj in archive:\n            dist = 0\n            for other_sol, other_obj in archive:\n                dist += (abs(obj[0] - other_obj[0]) + abs(obj[1] - other_obj[1]))\n            crowding.append((sol, dist))\n        crowding.sort(key=lambda x: x[1], reverse=True)\n        selected_solution = crowding[0][0].copy()\n    else:\n        # Among non-dominated, select based on objective trade-off\n        weights = [0.3, 0.7] if random.random() < 0.5 else [0.7, 0.3]\n        selected_solution = min(non_dominated, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid node swapping and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node swapping operation\n        i, j = random.sample(range(n), 2)\n        while abs(i - j) < 2:  # Ensure not adjacent\n            i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This novel algorithm combines a non-dominated sorting-based selection of solutions with a hybrid of edge insertion and adaptive segment swapping, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on non-dominated sorting\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    dominated = [False] * len(archive)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                    dominated[i] = True\n                    break\n        if not dominated[i]:\n            fronts.append(i)\n\n    if not fronts:\n        fronts = [i for i, d in enumerate(dominated) if not d]\n\n    if not fronts:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(fronts)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Adaptive segment swapping\n        segment_length = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        other_solution = random.choice(archive)[0]\n        other_segment = other_solution[start:end]\n\n        current_nodes = set(new_solution)\n        valid_nodes = [node for node in other_segment if node in current_nodes]\n\n        if valid_nodes:\n            swap_pos = random.randint(0, n - segment_length)\n            new_solution[swap_pos:swap_pos+segment_length] = valid_nodes\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8948645907769704,
            0.9302977919578552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on non-dominated sorting\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    dominated = [False] * len(archive)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                    dominated[i] = True\n                    break\n        if not dominated[i]:\n            fronts.append(i)\n\n    if not fronts:\n        fronts = [i for i, d in enumerate(dominated) if not d]\n\n    if not fronts:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(fronts)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Adaptive segment swapping\n        segment_length = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        other_solution = random.choice(archive)[0]\n        other_segment = other_solution[start:end]\n\n        current_nodes = set(new_solution)\n        valid_nodes = [node for node in other_segment if node in current_nodes]\n\n        if valid_nodes:\n            swap_pos = random.randint(0, n - segment_length)\n            new_solution[swap_pos:swap_pos+segment_length] = valid_nodes\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This novel heuristic combines a multi-objective Pareto dominance-based selection with a hybrid of edge swapping and node insertion operations, guided by an adaptive objective weighting scheme to explore the solution space while balancing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge swapping operation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Node insertion operation\n        i, j = random.sample(range(n), 2)\n        while i == j:\n            j = random.sample(range(n), 1)[0]\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8693860211480922,
            5.544930160045624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge swapping operation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Node insertion operation\n        i, j = random.sample(range(n), 2)\n        while i == j:\n            j = random.sample(range(n), 1)[0]\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This novel algorithm combines a multi-objective clustering-based selection of solutions from the archive with a hybrid of node-swapping and segment-rotation operations, dynamically balancing the exploration of trade-off regions by leveraging geometric properties of the solution space to identify promising regions while ensuring feasibility through constrained local search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Multi-objective clustering selection\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives\n        min_vals = objectives.min(axis=0)\n        max_vals = objectives.max(axis=0)\n        normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n        # K-means clustering (k=3)\n        k = min(3, len(archive))\n        centroids = normalized[np.random.choice(len(archive), k, replace=False)]\n        for _ in range(10):\n            distances = np.linalg.norm(normalized[:, np.newaxis] - centroids, axis=2)\n            labels = np.argmin(distances, axis=1)\n            for i in range(k):\n                if np.sum(labels == i) > 0:\n                    centroids[i] = normalized[labels == i].mean(axis=0)\n\n        # Select from the least crowded cluster\n        cluster_sizes = np.bincount(labels, minlength=k)\n        least_crowded = np.argmin(cluster_sizes)\n        candidates = [i for i, label in enumerate(labels) if label == least_crowded]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-rotation operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Find duplicate and missing nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        all_nodes = set(range(n))\n        missing = list(all_nodes - set(new_solution))\n\n        if duplicates and missing:\n            # Replace duplicate with missing node\n            dup_pos = np.where(new_solution == duplicates[0])[0][0]\n            new_solution[dup_pos] = missing[0]\n\n    return new_solution\n\n",
        "score": [
            -0.8775102978163242,
            4.4345725774765015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Multi-objective clustering selection\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Normalize objectives\n        min_vals = objectives.min(axis=0)\n        max_vals = objectives.max(axis=0)\n        normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n        # K-means clustering (k=3)\n        k = min(3, len(archive))\n        centroids = normalized[np.random.choice(len(archive), k, replace=False)]\n        for _ in range(10):\n            distances = np.linalg.norm(normalized[:, np.newaxis] - centroids, axis=2)\n            labels = np.argmin(distances, axis=1)\n            for i in range(k):\n                if np.sum(labels == i) > 0:\n                    centroids[i] = normalized[labels == i].mean(axis=0)\n\n        # Select from the least crowded cluster\n        cluster_sizes = np.bincount(labels, minlength=k)\n        least_crowded = np.argmin(cluster_sizes)\n        candidates = [i for i, label in enumerate(labels) if label == least_crowded]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-rotation operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Find duplicate and missing nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        all_nodes = set(range(n))\n        missing = list(all_nodes - set(new_solution))\n\n        if duplicates and missing:\n            # Replace duplicate with missing node\n            dup_pos = np.where(new_solution == duplicates[0])[0][0]\n            new_solution[dup_pos] = missing[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{A novel local search heuristic combines a crowding-distance based selection with a hybrid edge exchange and path reversal operation to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    # Normalize objectives\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Sort by each objective\n    sorted_indices = [np.argsort(normalized_obj[:, i]) for i in range(2)]\n\n    # Compute crowding distance\n    crowding_dist = np.zeros(n_solutions)\n    for i in range(2):\n        crowding_dist[sorted_indices[i][0]] = np.inf\n        crowding_dist[sorted_indices[i][-1]] = np.inf\n        for j in range(1, n_solutions - 1):\n            crowding_dist[sorted_indices[i][j]] += (normalized_obj[sorted_indices[i][j+1], i] - normalized_obj[sorted_indices[i][j-1], i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge exchange and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid operation: edge exchange followed by path reversal\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-1)\n\n        # Edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path reversal between two random points\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5965691210596704,
            1.8212772011756897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    # Normalize objectives\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Sort by each objective\n    sorted_indices = [np.argsort(normalized_obj[:, i]) for i in range(2)]\n\n    # Compute crowding distance\n    crowding_dist = np.zeros(n_solutions)\n    for i in range(2):\n        crowding_dist[sorted_indices[i][0]] = np.inf\n        crowding_dist[sorted_indices[i][-1]] = np.inf\n        for j in range(1, n_solutions - 1):\n            crowding_dist[sorted_indices[i][j]] += (normalized_obj[sorted_indices[i][j+1], i] - normalized_obj[sorted_indices[i][j-1], i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge exchange and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid operation: edge exchange followed by path reversal\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-1)\n\n        # Edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Path reversal between two random points\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{A novel local search heuristic combines a adaptive objective-based selection with a hybrid of segment rotation and node exchange operations, guided by a dynamic trade-off between the two objectives to explore the Pareto front while maintaining feasibility through a novel feasibility-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet([1, 1])\n    selected_idx = np.argmin(np.dot(normalized, weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n        # Node exchange operation\n        i, j = random.sample(range(n), 2)\n        while i == j:\n            j = random.sample(range(n), 1)[0]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility preservation mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify duplicates and missing nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        missing = np.setdiff1d(np.arange(n), new_solution)\n\n        # Fix duplicates by replacing with missing nodes\n        for dup in duplicates:\n            if len(missing) > 0:\n                pos = np.where(new_solution == dup)[0][1]  # Second occurrence\n                new_solution[pos] = missing[0]\n                missing = np.delete(missing, 0)\n\n        # If still invalid, perform a controlled swap\n        if len(np.unique(new_solution)) != n:\n            i = np.where(np.isin(new_solution, duplicates))[0][0]\n            j = np.where(new_solution == missing[0])[0][0] if len(missing) > 0 else np.random.randint(n)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8060831257077131,
            1.744167447090149
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.dirichlet([1, 1])\n    selected_idx = np.argmin(np.dot(normalized, weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n        # Node exchange operation\n        i, j = random.sample(range(n), 2)\n        while i == j:\n            j = random.sample(range(n), 1)[0]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility preservation mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify duplicates and missing nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        missing = np.setdiff1d(np.arange(n), new_solution)\n\n        # Fix duplicates by replacing with missing nodes\n        for dup in duplicates:\n            if len(missing) > 0:\n                pos = np.where(new_solution == dup)[0][1]  # Second occurrence\n                new_solution[pos] = missing[0]\n                missing = np.delete(missing, 0)\n\n        # If still invalid, perform a controlled swap\n        if len(np.unique(new_solution)) != n:\n            i = np.where(np.isin(new_solution, duplicates))[0][0]\n            j = np.where(new_solution == missing[0])[0][0] if len(missing) > 0 else np.random.randint(n)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{A novel adaptive local search heuristic combines multi-objective Pareto dominance selection with a dynamic node insertion and segment rotation operation, guided by a hybrid improvement criterion that balances objective improvements in both spaces while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto dominance and objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply dynamic node insertion and segment rotation\n    if n > 3:\n        # Select a random segment and rotate it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n        # Insert a random node at another position\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(new_solution):\n        # Remove duplicates by keeping first occurrence\n        mask = np.zeros_like(new_solution, dtype=bool)\n        mask[np.unique(new_solution, return_index=True)[1]] = True\n        new_solution = new_solution[mask]\n\n    return new_solution\n\n",
        "score": [
            -0.865144918069516,
            2.8809955716133118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto dominance and objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply dynamic node insertion and segment rotation\n    if n > 3:\n        # Select a random segment and rotate it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n        # Insert a random node at another position\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(new_solution):\n        # Remove duplicates by keeping first occurrence\n        mask = np.zeros_like(new_solution, dtype=bool)\n        mask[np.unique(new_solution, return_index=True)[1]] = True\n        new_solution = new_solution[mask]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance aware selection of solutions from the archive with a hybrid of segment reordering and node permutation operations, guided by an adaptive objective-based trade-off to efficiently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected_solution = random.choice(non_dominated)[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reordering operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Node permutation operation\n        i, j = random.sample(range(n), 2)\n        while i == j:\n            j = random.sample(range(n), 1)[0]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9125249446189458,
            2.3388314843177795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected_solution = random.choice(non_dominated)[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reordering operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Node permutation operation\n        i, j = random.sample(range(n), 2)\n        while i == j:\n            j = random.sample(range(n), 1)[0]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm first selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search combining node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Select solution with best weighted objective (0.7 for first objective, 0.3 for second)\n    best_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Apply hybrid local search: node swap and segment reversal\n    if len(best_solution) > 3:\n        # Random node swap\n        i, j = np.random.choice(len(best_solution), size=2, replace=False)\n        best_solution[i], best_solution[j] = best_solution[j], best_solution[i]\n\n        # Segment reversal between two random points\n        a, b = sorted(np.random.choice(len(best_solution), size=2, replace=False))\n        best_solution[a:b+1] = best_solution[a:b+1][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive using a dynamic selection criterion that balances exploration and exploitation, then applies a novel hybrid local search combining segment rotation, node relocation, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic selection criterion: balance between best solution and random exploration\n    if np.random.random() < 0.7 or len(archive) < 5:\n        selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation operation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Node relocation with distance-based criteria\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Calculate potential insertion positions based on both distance matrices\n        insertion_costs = []\n        for j in range(n - 1):\n            if j == i or j == (i - 1) % (n - 1):\n                insertion_costs.append(float('inf'))\n            else:\n                cost1 = distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, new_solution[j]]\n                cost2 = distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, new_solution[j]]\n                insertion_costs.append(0.7 * cost1 + 0.3 * cost2)\n\n        if insertion_costs:\n            best_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n        # Edge swapping based on both objectives\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1 and (i != 0 or j != n-1):\n            cost1_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]])\n            cost2_before = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n            cost1_after = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[i]])\n            cost2_after = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if (0.7 * cost1_after + 0.3 * cost2_after) < (0.7 * cost1_before + 0.3 * cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7106647821906629,
            2.823600471019745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Dynamic selection criterion: balance between best solution and random exploration\n    if np.random.random() < 0.7 or len(archive) < 5:\n        selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation operation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Node relocation with distance-based criteria\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Calculate potential insertion positions based on both distance matrices\n        insertion_costs = []\n        for j in range(n - 1):\n            if j == i or j == (i - 1) % (n - 1):\n                insertion_costs.append(float('inf'))\n            else:\n                cost1 = distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, new_solution[j]]\n                cost2 = distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, new_solution[j]]\n                insertion_costs.append(0.7 * cost1 + 0.3 * cost2)\n\n        if insertion_costs:\n            best_pos = np.argmin(insertion_costs)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n        # Edge swapping based on both objectives\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1 and (i != 0 or j != n-1):\n            cost1_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]])\n            cost2_before = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n            cost1_after = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[i]])\n            cost2_after = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if (0.7 * cost1_after + 0.3 * cost2_after) < (0.7 * cost1_before + 0.3 * cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This novel local search heuristic dynamically selects solutions from the archive based on a crowding-distance-based trade-off, then applies a hybrid of adaptive segment inversion and probabilistic node relocation, guided by the relative improvement in both objectives to explore the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = float('inf')\n        crowding[sorted_idx[-1]] = float('inf')\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                continue\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive parameters\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion\n        segment_length = random.randint(1, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], segment[::-1], new_solution[end:]])\n\n        # Probabilistic node relocation\n        for _ in range(2):\n            if random.random() < 0.7:\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                while i == j:\n                    j = random.randint(0, n-1)\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4271540900078869,
            3.8231363892555237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = float('inf')\n        crowding[sorted_idx[-1]] = float('inf')\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                continue\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive parameters\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion\n        segment_length = random.randint(1, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], segment[::-1], new_solution[end:]])\n\n        # Probabilistic node relocation\n        for _ in range(2):\n            if random.random() < 0.7:\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                while i == j:\n                    j = random.randint(0, n-1)\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This novel heuristic combines a dominance-based selection with a multi-objective-aware segment relocation and rotation operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using dominance-based selection\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Find non-dominated solutions\n    is_dominated = np.zeros(len(objectives), dtype=bool)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(objectives))\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply multi-objective-aware segment relocation and rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relocation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Segment rotation based on objective space\n        if random.random() < 0.5:\n            # Rotate segment based on first objective space\n            total_dist_1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            total_dist_1 += distance_matrix_1[segment[-1], segment[0]]\n            if total_dist_1 > 0:\n                rotation_point = random.randint(0, len(segment)-1)\n                segment = np.roll(segment, rotation_point)\n        else:\n            # Rotate segment based on second objective space\n            total_dist_2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            total_dist_2 += distance_matrix_2[segment[-1], segment[0]]\n            if total_dist_2 > 0:\n                rotation_point = random.randint(0, len(segment)-1)\n                segment = np.roll(segment, rotation_point)\n\n        # Reinsert segment at a new position\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9359071640617478,
            3.1920443177223206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using dominance-based selection\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Find non-dominated solutions\n    is_dominated = np.zeros(len(objectives), dtype=bool)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(objectives))\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply multi-objective-aware segment relocation and rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relocation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Segment rotation based on objective space\n        if random.random() < 0.5:\n            # Rotate segment based on first objective space\n            total_dist_1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            total_dist_1 += distance_matrix_1[segment[-1], segment[0]]\n            if total_dist_1 > 0:\n                rotation_point = random.randint(0, len(segment)-1)\n                segment = np.roll(segment, rotation_point)\n        else:\n            # Rotate segment based on second objective space\n            total_dist_2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            total_dist_2 += distance_matrix_2[segment[-1], segment[0]]\n            if total_dist_2 > 0:\n                rotation_point = random.randint(0, len(segment)-1)\n                segment = np.roll(segment, rotation_point)\n\n        # Reinsert segment at a new position\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0763280568037827,
            3.917659640312195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0763280568037827,
            3.917659640312195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{A novel local search heuristic uses a Pareto-frontier guided selection of solutions from the archive, followed by a dynamic path reconfiguration and node insertion operation, guided by a multi-objective improvement criterion to efficiently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 2: Apply dynamic path reconfiguration and node insertion\n    n = len(new_solution)\n    if n > 3:\n        # Select a random segment and reorder it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        if len(segment) > 1:\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n        # Insert a random node at a random position (if not already present)\n        if n < len(instance):\n            node_to_insert = random.choice([i for i in range(len(instance)) if i not in new_solution])\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.802231575629143,
            2.402696669101715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Step 2: Apply dynamic path reconfiguration and node insertion\n    n = len(new_solution)\n    if n > 3:\n        # Select a random segment and reorder it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        if len(segment) > 1:\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n        # Insert a random node at a random position (if not already present)\n        if n < len(instance):\n            node_to_insert = random.choice([i for i in range(len(instance)) if i not in new_solution])\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This novel heuristic employs a Pareto-dominance based selection followed by a hybrid segment relocation and path reversal operation, dynamically adapting the search intensity based on spatial clustering in both objective spaces to efficiently explore high-quality regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify non-dominated solutions\n    is_dominated = np.zeros(len(objectives), dtype=bool)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                if objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]:\n                    is_dominated[i] = True\n                    break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid segment relocation and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relocation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Path reversal with spatial consideration\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        # Check spatial proximity in both objective spaces\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n        if (distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j] <\n            distance_matrix_1[node_i, new_solution[i+1]] + distance_matrix_2[node_i, new_solution[i+1]] +\n            distance_matrix_1[node_j, new_solution[j-1]] + distance_matrix_2[node_j, new_solution[j-1]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7574054067658348,
            2.804863691329956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify non-dominated solutions\n    is_dominated = np.zeros(len(objectives), dtype=bool)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                if objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]:\n                    is_dominated[i] = True\n                    break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid segment relocation and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relocation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Path reversal with spatial consideration\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        # Check spatial proximity in both objective spaces\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n        if (distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j] <\n            distance_matrix_1[node_i, new_solution[i+1]] + distance_matrix_2[node_i, new_solution[i+1]] +\n            distance_matrix_1[node_j, new_solution[j-1]] + distance_matrix_2[node_j, new_solution[j-1]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{A novel local search heuristic combines a crowding-distance-based selection with a hybrid segment reversal and insertion operation to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    crowding_distances = []\n    for i in range(len(objectives)):\n        distances = []\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            d1 = abs(objectives[i][0] - objectives[j][0])\n            d2 = abs(objectives[i][1] - objectives[j][1])\n            distances.append(d1 + d2)\n        crowding_distances.append(min(distances) if distances else float('inf'))\n\n    # Select solution with highest crowding distance\n    selected_index = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_index].copy()\n\n    # Step 2: Apply hybrid segment reversal and insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Select another random position to insert a node\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7821728096714836,
            2.8222458362579346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    crowding_distances = []\n    for i in range(len(objectives)):\n        distances = []\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            d1 = abs(objectives[i][0] - objectives[j][0])\n            d2 = abs(objectives[i][1] - objectives[j][1])\n            distances.append(d1 + d2)\n        crowding_distances.append(min(distances) if distances else float('inf'))\n\n    # Select solution with highest crowding distance\n    selected_index = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_index].copy()\n\n    # Step 2: Apply hybrid segment reversal and insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Select another random position to insert a node\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel local search heuristic that combines objective-space partitioning with a multi-segment shuffle and insertion operator, guided by both geometric and topological properties of the solution space, to explore diverse neighborhoods while preserving feasibility through a geometric validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Partition the objective space and select a representative solution\n    objectives = np.array([obj for _, obj in archive])\n    min_obj, max_obj = np.min(objectives, axis=0), np.max(objectives, axis=0)\n    partitions = np.linspace(min_obj[0], max_obj[0], 4), np.linspace(min_obj[1], max_obj[1], 4)\n\n    selected_idx = -1\n    for i in range(len(archive)):\n        obj = objectives[i]\n        if (obj[0] > partitions[0][1] and obj[0] < partitions[0][2]) and (obj[1] > partitions[1][1] and obj[1] < partitions[1][2]):\n            selected_idx = i\n            break\n\n    if selected_idx == -1:\n        selected_idx = np.random.randint(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Multi-segment shuffle and insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Split into 3 segments\n        split1 = random.randint(1, n-3)\n        split2 = random.randint(split1+1, n-2)\n        segments = [new_solution[:split1], new_solution[split1:split2], new_solution[split2:]]\n\n        # Shuffle segments and insert them back\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Perform a random insertion\n        if n > 5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Geometric validation\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct using geometric properties\n        coords1 = instance[new_solution, :2]\n        coords2 = instance[new_solution, 2:]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n\n        # Sort nodes by angle in first space and distance in second space\n        angles = np.arctan2(coords1[:,1] - centroid1[1], coords1[:,0] - centroid1[0])\n        distances = np.linalg.norm(coords2 - centroid2, axis=1)\n        order = np.lexsort((angles, distances))\n        new_solution = new_solution[order]\n\n    # Final check\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.5858467512517017,
            1.7992205619812012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Partition the objective space and select a representative solution\n    objectives = np.array([obj for _, obj in archive])\n    min_obj, max_obj = np.min(objectives, axis=0), np.max(objectives, axis=0)\n    partitions = np.linspace(min_obj[0], max_obj[0], 4), np.linspace(min_obj[1], max_obj[1], 4)\n\n    selected_idx = -1\n    for i in range(len(archive)):\n        obj = objectives[i]\n        if (obj[0] > partitions[0][1] and obj[0] < partitions[0][2]) and (obj[1] > partitions[1][1] and obj[1] < partitions[1][2]):\n            selected_idx = i\n            break\n\n    if selected_idx == -1:\n        selected_idx = np.random.randint(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Multi-segment shuffle and insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Split into 3 segments\n        split1 = random.randint(1, n-3)\n        split2 = random.randint(split1+1, n-2)\n        segments = [new_solution[:split1], new_solution[split1:split2], new_solution[split2:]]\n\n        # Shuffle segments and insert them back\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Perform a random insertion\n        if n > 5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Geometric validation\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct using geometric properties\n        coords1 = instance[new_solution, :2]\n        coords2 = instance[new_solution, 2:]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n\n        # Sort nodes by angle in first space and distance in second space\n        angles = np.arctan2(coords1[:,1] - centroid1[1], coords1[:,0] - centroid1[0])\n        distances = np.linalg.norm(coords2 - centroid2, axis=1)\n        order = np.lexsort((angles, distances))\n        new_solution = new_solution[order]\n\n    # Final check\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This novel algorithm combines a dominance-based selection of solutions from the archive with a hybrid of cluster-based swapping and adaptive segment insertion, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective diversity\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Cluster-based swapping operation\n        cluster_size = max(2, n // 5)\n        clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n        if len(clusters) > 1:\n            i, j = random.sample(range(len(clusters)), 2)\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n            new_solution = np.concatenate(clusters)\n\n        # Adaptive segment insertion\n        segment_length = random.randint(1, min(3, n//3))\n        start = random.randint(0, n-segment_length)\n        end = start + segment_length\n\n        other_solution = random.choice(archive)[0]\n        other_segment = other_solution[start:end]\n\n        current_nodes = set(new_solution)\n        valid_nodes = [node for node in other_segment if node not in current_nodes]\n\n        if valid_nodes:\n            insert_pos = random.randint(0, n-len(valid_nodes))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array(valid_nodes),\n                new_solution[insert_pos:]\n            ])[:n]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [i for i, x in enumerate(new_solution) if list(new_solution).count(x) > 1]\n        if missing and duplicates:\n            new_solution[duplicates[0]] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8683417033776142,
            8.449627459049225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective diversity\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Cluster-based swapping operation\n        cluster_size = max(2, n // 5)\n        clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n        if len(clusters) > 1:\n            i, j = random.sample(range(len(clusters)), 2)\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n            new_solution = np.concatenate(clusters)\n\n        # Adaptive segment insertion\n        segment_length = random.randint(1, min(3, n//3))\n        start = random.randint(0, n-segment_length)\n        end = start + segment_length\n\n        other_solution = random.choice(archive)[0]\n        other_segment = other_solution[start:end]\n\n        current_nodes = set(new_solution)\n        valid_nodes = [node for node in other_segment if node not in current_nodes]\n\n        if valid_nodes:\n            insert_pos = random.randint(0, n-len(valid_nodes))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                np.array(valid_nodes),\n                new_solution[insert_pos:]\n            ])[:n]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [i for i, x in enumerate(new_solution) if list(new_solution).count(x) > 1]\n        if missing and duplicates:\n            new_solution[duplicates[0]] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel local search heuristic selects solutions based on a Pareto-dominance aware quality metric combined with a novel edge importance scoring mechanism, followed by a dynamic segment reversal and edge contraction operation, guided by a hybrid objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with Pareto-dominance aware quality metric\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj) and any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Edge importance scoring\n    n = len(selected_solution)\n    edge_importance = np.zeros(n)\n    for i in range(n):\n        prev = selected_solution[i-1]\n        curr = selected_solution[i]\n        next_node = selected_solution[(i+1)%n]\n        edge_importance[i] = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                              distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n    # Step 3: Dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    if n > 3:\n        # Select segment based on edge importance\n        sorted_indices = np.argsort(edge_importance)[::-1]\n        a, b = sorted(random.sample(sorted_indices[:n//2].tolist(), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract edges based on importance\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(sorted_indices[:n//3].tolist(), 2))\n            if j - i > 1:\n                remove_pos = random.randint(i+1, j-1)\n                new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.836664522523213,
            1.4543231129646301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with Pareto-dominance aware quality metric\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj) and any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Edge importance scoring\n    n = len(selected_solution)\n    edge_importance = np.zeros(n)\n    for i in range(n):\n        prev = selected_solution[i-1]\n        curr = selected_solution[i]\n        next_node = selected_solution[(i+1)%n]\n        edge_importance[i] = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                              distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n    # Step 3: Dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    if n > 3:\n        # Select segment based on edge importance\n        sorted_indices = np.argsort(edge_importance)[::-1]\n        a, b = sorted(random.sample(sorted_indices[:n//2].tolist(), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract edges based on importance\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(sorted_indices[:n//3].tolist(), 2))\n            if j - i > 1:\n                remove_pos = random.randint(i+1, j-1)\n                new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{An adaptive local search heuristic combines a non-dominated sorting-based selection of solutions with a novel multi-stage path decomposition and reinsertion operation, dynamically balancing objective improvements while ensuring feasibility through a hierarchical validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    fronts = []\n    dominated_counts = np.zeros(len(objectives))\n    domination_sets = [[] for _ in range(len(objectives))]\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    domination_sets[i].append(j)\n                elif all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                    dominated_counts[i] += 1\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    # Select from the first non-dominated front\n    front_indices = fronts[0]\n    selected_idx = random.choice(front_indices)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Multi-stage path decomposition and reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Stage 1: Decompose into segments\n        k = random.randint(2, min(5, n-1))\n        segment_length = n // k\n        segments = []\n        for i in range(k):\n            start = i * segment_length\n            end = (i+1) * segment_length if i < k-1 else n\n            segments.append(new_solution[start:end])\n\n        # Stage 2: Reinsert segments in a new order\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Stage 3: Apply partial path reversal\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Hierarchical validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        segment_size = random.randint(1, min(3, len(new_solution)//2))\n        new_solution[i:i+segment_size], new_solution[j:j+segment_size] = new_solution[j:j+segment_size], new_solution[i:i+segment_size]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7008835937336519,
            3.981017529964447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    fronts = []\n    dominated_counts = np.zeros(len(objectives))\n    domination_sets = [[] for _ in range(len(objectives))]\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    domination_sets[i].append(j)\n                elif all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                    dominated_counts[i] += 1\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    # Select from the first non-dominated front\n    front_indices = fronts[0]\n    selected_idx = random.choice(front_indices)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Multi-stage path decomposition and reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Stage 1: Decompose into segments\n        k = random.randint(2, min(5, n-1))\n        segment_length = n // k\n        segments = []\n        for i in range(k):\n            start = i * segment_length\n            end = (i+1) * segment_length if i < k-1 else n\n            segments.append(new_solution[start:end])\n\n        # Stage 2: Reinsert segments in a new order\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Stage 3: Apply partial path reversal\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Hierarchical validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment swap\n        i, j = random.sample(range(len(new_solution)), 2)\n        segment_size = random.randint(1, min(3, len(new_solution)//2))\n        new_solution[i:i+segment_size], new_solution[j:j+segment_size] = new_solution[j:j+segment_size], new_solution[i:i+segment_size]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{A novel local search heuristic that combines a dominance-based selection of solutions with a hybrid of segment-shuffling and edge-flipping operations, dynamically balancing exploration and exploitation while ensuring feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance count\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    min_dominance_idx = np.argmin(dominance_counts)\n    selected_solution = solutions[min_dominance_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shuffling operation\n        a = random.randint(0, n-2)\n        b = random.randint(0, n-2)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-2)\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n        # Edge-flipping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = \\\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n\n    # Step 3: Probabilistic validation\n    if random.random() < 0.3 or len(np.unique(new_solution)) != n:\n        # Apply random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8891854277958461,
            10.158304989337921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance count\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    min_dominance_idx = np.argmin(dominance_counts)\n    selected_solution = solutions[min_dominance_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shuffling operation\n        a = random.randint(0, n-2)\n        b = random.randint(0, n-2)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-2)\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n        # Edge-flipping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = \\\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n\n    # Step 3: Probabilistic validation\n    if random.random() < 0.3 or len(np.unique(new_solution)) != n:\n        # Apply random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This novel local search heuristic employs a dynamic Pareto-dominance guided selection followed by a hybrid of segment rotation and edge exchange operations, adaptively balancing exploration and exploitation of the trade-off surface while ensuring feasibility through constrained perturbation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on Pareto dominance and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = random.randint(0, min(5, len(archive)-1))\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation operation\n        k = random.randint(0, n-4)\n        segment = new_solution[k:k+3]\n        new_solution = np.concatenate([new_solution[:k], np.roll(segment, 1), new_solution[k+3:]])\n\n        # Edge exchange operation\n        i, j = random.sample(range(n), 2)\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        if random.random() > 0.5:\n            new_solution[i] = c\n            new_solution[(j+1)%n] = a\n        else:\n            new_solution[i] = d\n            new_solution[(j+1)%n] = a\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7320040252408067,
            0.8304330706596375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on Pareto dominance and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = random.randint(0, min(5, len(archive)-1))\n    selected_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation operation\n        k = random.randint(0, n-4)\n        segment = new_solution[k:k+3]\n        new_solution = np.concatenate([new_solution[:k], np.roll(segment, 1), new_solution[k+3:]])\n\n        # Edge exchange operation\n        i, j = random.sample(range(n), 2)\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        if random.random() > 0.5:\n            new_solution[i] = c\n            new_solution[(j+1)%n] = a\n        else:\n            new_solution[i] = d\n            new_solution[(j+1)%n] = a\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.324697913050048,
            0.5149560570716858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.324697913050048,
            0.5149560570716858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{A novel local search heuristic that combines a Pareto-dominance based selection with a dynamic multi-segment shuffle and edge expansion operation, guided by an adaptive objective weighting scheme to efficiently explore the solution space while maintaining feasibility through constrained permutation operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and adaptive objective weighting\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet([1, 1])\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic multi-segment shuffle and edge expansion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select 3 random segments and shuffle them\n        points = sorted(random.sample(range(1, n), 3))\n        a, b, c = points\n        segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Expand an edge by inserting a random node between two existing nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            insert_pos = random.randint(i+1, j-1)\n            available_nodes = list(set(range(n)) - set(new_solution))\n            if available_nodes:\n                new_node = random.choice(available_nodes)\n                new_solution = np.insert(new_solution, insert_pos, new_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8520085933160728,
            1.9463881850242615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and adaptive objective weighting\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet([1, 1])\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmin(weighted_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic multi-segment shuffle and edge expansion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select 3 random segments and shuffle them\n        points = sorted(random.sample(range(1, n), 3))\n        a, b, c = points\n        segments = [new_solution[:a], new_solution[a:b], new_solution[b:c], new_solution[c:]]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Expand an edge by inserting a random node between two existing nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            insert_pos = random.randint(i+1, j-1)\n            available_nodes = list(set(range(n)) - set(new_solution))\n            if available_nodes:\n                new_node = random.choice(available_nodes)\n                new_solution = np.insert(new_solution, insert_pos, new_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This novel local search heuristic leverages a crowding-distance-based selection of solutions from the archive, followed by a hybrid of path-relinking and adaptive segment-reversal operations, dynamically balancing the trade-off between objectives to efficiently navigate the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    if len(solutions) == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Compute crowding distance for each solution\n        crowding = np.zeros(len(solutions))\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[i+1]][m] != objectives[sorted_idx[i-1]][m]:\n                    crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max(obj[m] for obj in objectives) - min(obj[m] for obj in objectives))\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while b == a:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Adaptive segment-reversal operation\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5172975385225241,
            9.472160458564758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    if len(solutions) == 1:\n        selected_solution = solutions[0].copy()\n    else:\n        # Compute crowding distance for each solution\n        crowding = np.zeros(len(solutions))\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(solutions)-1):\n                if objectives[sorted_idx[i+1]][m] != objectives[sorted_idx[i-1]][m]:\n                    crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max(obj[m] for obj in objectives) - min(obj[m] for obj in objectives))\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n        selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while b == a:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Adaptive segment-reversal operation\n        k = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{A novel local search heuristic that combines a Pareto-frontier guided selection of solutions with a hybrid of segment-shuffling and node-chain operations, dynamically balancing exploration and exploitation by leveraging objective-space geometry while maintaining feasibility through a geometric validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto-frontier analysis\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    pareto_front_indices = np.where(~is_dominated)[0]\n    if len(pareto_front_indices) > 0:\n        selected_idx = random.choice(pareto_front_indices)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shuffling operation\n        segment_length = random.randint(2, max(2, n // 3))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n        # Node-chain operation\n        chain_length = random.randint(2, min(3, n))\n        chain_start = random.randint(0, n - chain_length)\n        chain = new_solution[chain_start:chain_start+chain_length]\n        new_positions = random.sample(range(n), chain_length)\n        for pos, node in zip(new_positions, chain):\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Geometric validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8118155864097122,
            2.533356010913849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto-frontier analysis\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    pareto_front_indices = np.where(~is_dominated)[0]\n    if len(pareto_front_indices) > 0:\n        selected_idx = random.choice(pareto_front_indices)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shuffling operation\n        segment_length = random.randint(2, max(2, n // 3))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n        # Node-chain operation\n        chain_length = random.randint(2, min(3, n))\n        chain_start = random.randint(0, n - chain_length)\n        chain = new_solution[chain_start:chain_start+chain_length]\n        new_positions = random.sample(range(n), chain_length)\n        for pos, node in zip(new_positions, chain):\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Geometric validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic incorporates a multi-objective selection based on adaptive dominance criteria, followed by a hybrid of segment reversal and node insertion operations, guided by a dynamic trade-off between objectives to efficiently explore the Pareto front while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive dominance\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    weights = np.random.dirichlet([1, 1])\n    selected_idx = np.argmin(np.dot(normalized, weights))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal operation\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{A novel local search heuristic selects solutions based on their trade-off angle between objectives and applies a geometric clustering and reinsertion operator that groups nodes by their spatial proximity in both objective spaces and reinserts them in a new order guided by their combined geometric properties to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with good trade-off angle\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    angles = np.arctan2(normalized[:, 1], normalized[:, 0])\n    selected_idx = np.argmin(np.abs(angles - np.pi/4))  # Prefer solutions near 45-degree angle\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric clustering and reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Cluster nodes by their geometric properties\n        node_coords = instance[selected_solution]\n        cluster_centers = np.zeros((3, 4))  # 3 clusters\n        for i in range(3):\n            cluster_centers[i] = node_coords[i*n//3:(i+1)*n//3].mean(axis=0)\n\n        # Reinsert nodes based on cluster assignment\n        cluster_assignments = np.zeros(n, dtype=int)\n        for i in range(n):\n            distances = np.linalg.norm(node_coords[i] - cluster_centers, axis=1)\n            cluster_assignments[i] = np.argmin(distances)\n\n        # Sort nodes by cluster and then by position within cluster\n        sorted_indices = np.lexsort((node_coords[:, 0], cluster_assignments))\n        new_solution = selected_solution[sorted_indices]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.43509661321314835,
            11.498261868953705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with good trade-off angle\n    objectives = np.array([obj for _, obj in archive])\n    ideal = np.min(objectives, axis=0)\n    nadir = np.max(objectives, axis=0)\n    normalized = (objectives - ideal) / (nadir - ideal + 1e-10)\n    angles = np.arctan2(normalized[:, 1], normalized[:, 0])\n    selected_idx = np.argmin(np.abs(angles - np.pi/4))  # Prefer solutions near 45-degree angle\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric clustering and reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Cluster nodes by their geometric properties\n        node_coords = instance[selected_solution]\n        cluster_centers = np.zeros((3, 4))  # 3 clusters\n        for i in range(3):\n            cluster_centers[i] = node_coords[i*n//3:(i+1)*n//3].mean(axis=0)\n\n        # Reinsert nodes based on cluster assignment\n        cluster_assignments = np.zeros(n, dtype=int)\n        for i in range(n):\n            distances = np.linalg.norm(node_coords[i] - cluster_centers, axis=1)\n            cluster_assignments[i] = np.argmin(distances)\n\n        # Sort nodes by cluster and then by position within cluster\n        sorted_indices = np.lexsort((node_coords[:, 0], cluster_assignments))\n        new_solution = selected_solution[sorted_indices]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation with dynamic segment size\n        segment_size = random.randint(1, min(5, n-2))\n        start = random.randint(0, n-1-segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution[start:start+segment_size] = segment[::-1]\n\n        # Node relocation operation with objective-aware selection\n        obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        if obj1 > obj2:\n            # Prefer improving the first objective\n            candidates = [i for i in range(n) if distance_matrix_1[new_solution[i-1], new_solution[i]] > np.mean(distance_matrix_1)]\n        else:\n            # Prefer improving the second objective\n            candidates = [i for i in range(n) if distance_matrix_2[new_solution[i-1], new_solution[i]] > np.mean(distance_matrix_2)]\n\n        if candidates:\n            i = random.choice(candidates)\n            j = random.randint(0, n-1)\n            while i == j:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair\n        obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        if obj1 > obj2:\n            # Prefer swaps that reduce first objective\n            for _ in range(10):\n                i, j = random.sample(range(n), 2)\n                if distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] > \\\n                   distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n        else:\n            # Prefer swaps that reduce second objective\n            for _ in range(10):\n                i, j = random.sample(range(n), 2)\n                if distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] > \\\n                   distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9034519118465303,
            3.582377552986145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation with dynamic segment size\n        segment_size = random.randint(1, min(5, n-2))\n        start = random.randint(0, n-1-segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution[start:start+segment_size] = segment[::-1]\n\n        # Node relocation operation with objective-aware selection\n        obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        if obj1 > obj2:\n            # Prefer improving the first objective\n            candidates = [i for i in range(n) if distance_matrix_1[new_solution[i-1], new_solution[i]] > np.mean(distance_matrix_1)]\n        else:\n            # Prefer improving the second objective\n            candidates = [i for i in range(n) if distance_matrix_2[new_solution[i-1], new_solution[i]] > np.mean(distance_matrix_2)]\n\n        if candidates:\n            i = random.choice(candidates)\n            j = random.randint(0, n-1)\n            while i == j:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Objective-aware repair\n        obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        if obj1 > obj2:\n            # Prefer swaps that reduce first objective\n            for _ in range(10):\n                i, j = random.sample(range(n), 2)\n                if distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] > \\\n                   distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n        else:\n            # Prefer swaps that reduce second objective\n            for _ in range(10):\n                i, j = random.sample(range(n), 2)\n                if distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] > \\\n                   distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a hybrid of node-insertion and segment-shifting operations, guided by a dynamic trade-off between the two objectives to explore diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i + 1) % n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment reversal and node relocation operation, guided by a dynamic trade-off between the two objectives to balance exploration and exploitation of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment reversal and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Reverse a random segment\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Relocate a node to a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8144588191375779,
            2.0776419043540955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment reversal and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Reverse a random segment\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Relocate a node to a different position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{A novel local search heuristic combines Pareto-dominance-based selection of solutions with a dynamic edge-swapping and path-reversal operator, guided by a hybrid objective improvement criterion to efficiently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto-dominance\n    objectives = np.array([obj for _, obj in archive])\n    dominated_count = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated_count[i] += 1\n    selected_idx = np.argmin(dominated_count)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge-swapping and path-reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random edges and swap their positions\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = np.concatenate([new_solution[j:i:-1], new_solution[j:j+1]])\n\n        # Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6912991342083361,
            0.9544398188591003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto-dominance\n    objectives = np.array([obj for _, obj in archive])\n    dominated_count = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated_count[i] += 1\n    selected_idx = np.argmin(dominated_count)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge-swapping and path-reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random edges and swap their positions\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = np.concatenate([new_solution[j:i:-1], new_solution[j:j+1]])\n\n        # Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive with a hybrid of edge-swapping and partial tour reversal operations, guided by an adaptive objective weighting to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and objective trade-off\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        weights = np.random.dirichlet([1, 1])\n        selected_solution = min(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Partial tour reversal operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8489116518431522,
            1.4116958379745483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and objective trade-off\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        weights = np.random.dirichlet([1, 1])\n        selected_solution = min(non_dominated, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Partial tour reversal operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This novel local search heuristic combines a hypervolume-based selection of solutions with a hybrid of adaptive segment rotation and node insertion operations, dynamically balancing the objectives while ensuring feasibility through a multi-objective validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate hypervolume contributions (simplified approximation)\n    ref_point = np.max(objectives, axis=0) + 1.0\n    hypervolumes = []\n    for i in range(len(objectives)):\n        dominated = np.all(objectives <= objectives[i], axis=1) & (objectives != objectives[i]).any(axis=1)\n        if not np.any(dominated):\n            hypervolumes.append(np.prod(ref_point - objectives[i]))\n        else:\n            hypervolumes.append(np.prod(ref_point - objectives[i]) - np.sum(np.prod(ref_point - objectives[dominated], axis=1)))\n\n    max_hv_idx = np.argmax(hypervolumes)\n    selected_solution = solutions[max_hv_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        if k > l:\n            k, l = l, k\n        segment = new_solution[k:l]\n\n        # Rotate segment based on objective trade-off\n        weights = np.random.dirichlet([1, 1])\n        if weights[0] > weights[1]:\n            # Rotate left\n            segment = np.roll(segment, -1)\n        else:\n            # Rotate right\n            segment = np.roll(segment, 1)\n\n        new_solution[k:l] = segment\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Multi-objective validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to objective-aware segment reversal\n        weights = np.random.dirichlet([1, 1])\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment based on objective trade-off\n        if weights[0] > weights[1]:\n            # Reverse segment to potentially improve first objective\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Reverse segment to potentially improve second objective\n            new_solution[b:a-1:-1] = new_solution[a:b+1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7187040423486599,
            2.307590067386627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate hypervolume contributions (simplified approximation)\n    ref_point = np.max(objectives, axis=0) + 1.0\n    hypervolumes = []\n    for i in range(len(objectives)):\n        dominated = np.all(objectives <= objectives[i], axis=1) & (objectives != objectives[i]).any(axis=1)\n        if not np.any(dominated):\n            hypervolumes.append(np.prod(ref_point - objectives[i]))\n        else:\n            hypervolumes.append(np.prod(ref_point - objectives[i]) - np.sum(np.prod(ref_point - objectives[dominated], axis=1)))\n\n    max_hv_idx = np.argmax(hypervolumes)\n    selected_solution = solutions[max_hv_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        if k > l:\n            k, l = l, k\n        segment = new_solution[k:l]\n\n        # Rotate segment based on objective trade-off\n        weights = np.random.dirichlet([1, 1])\n        if weights[0] > weights[1]:\n            # Rotate left\n            segment = np.roll(segment, -1)\n        else:\n            # Rotate right\n            segment = np.roll(segment, 1)\n\n        new_solution[k:l] = segment\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Multi-objective validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to objective-aware segment reversal\n        weights = np.random.dirichlet([1, 1])\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment based on objective trade-off\n        if weights[0] > weights[1]:\n            # Reverse segment to potentially improve first objective\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Reverse segment to potentially improve second objective\n            new_solution[b:a-1:-1] = new_solution[a:b+1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{A novel local search heuristic combines a Pareto-frontier biased selection of solutions from the archive, followed by a hybrid of edge-swapping and segment-reversal operations, guided by a dynamic dominance-based trade-off to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.argmax(np.sum(objectives, axis=1))\n    else:\n        selected_idx = random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping: randomly select two edges and swap them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7644002460619839,
            3.355963945388794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution from the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.argmax(np.sum(objectives, axis=1))\n    else:\n        selected_idx = random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping: randomly select two edges and swap them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{A novel local search heuristic selects solutions based on their hypervolume contribution and applies a node swapping operator that considers the geometric properties of the nodes in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) + 1.0  # Reference point for hypervolume calculation\n    hypervolumes = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated = []\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1]):\n                dominated.append(objectives[j])\n        dominated = np.array(dominated)\n        if len(dominated) > 0:\n            hypervolumes[i] = np.prod(np.max(dominated - objectives[i], axis=0))\n\n    selected_idx = np.argmax(hypervolumes)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply node swapping operator based on geometric properties\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two nodes to swap based on their positions in both spaces\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate distance between nodes in both spaces\n        dist1 = np.linalg.norm(instance[node_i, :2] - instance[node_j, :2])\n        dist2 = np.linalg.norm(instance[node_i, 2:] - instance[node_j, 2:])\n\n        # Swap nodes if they are far apart in at least one space\n        if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8463492028112747,
            4.534123241901398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) + 1.0  # Reference point for hypervolume calculation\n    hypervolumes = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated = []\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1]):\n                dominated.append(objectives[j])\n        dominated = np.array(dominated)\n        if len(dominated) > 0:\n            hypervolumes[i] = np.prod(np.max(dominated - objectives[i], axis=0))\n\n    selected_idx = np.argmax(hypervolumes)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply node swapping operator based on geometric properties\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two nodes to swap based on their positions in both spaces\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate distance between nodes in both spaces\n        dist1 = np.linalg.norm(instance[node_i, :2] - instance[node_j, :2])\n        dist2 = np.linalg.norm(instance[node_i, 2:] - instance[node_j, 2:])\n\n        # Swap nodes if they are far apart in at least one space\n        if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{A novel local search heuristic selects solutions based on a Pareto-dominance-aware quality metric that balances objective improvement and solution diversity, followed by a hybrid edge swap and segment inversion operation that adaptively modifies the tour structure to escape local optima while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with Pareto-dominance aware quality metric\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front[i] = True\n\n    if np.any(pareto_front):\n        candidates = np.where(pareto_front)[0]\n        selected_idx = random.choice(candidates)\n    else:\n        # If no Pareto optimal solutions, select based on crowding distance\n        crowding_distances = np.zeros(len(archive))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n        selected_idx = np.argmax(crowding_distances)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge swap and segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid operation: edge swap with probability 0.7, segment inversion with probability 0.3\n        if random.random() < 0.7:\n            # Edge swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment inversion\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8626990827245511,
            7.7558982372283936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with Pareto-dominance aware quality metric\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front[i] = True\n\n    if np.any(pareto_front):\n        candidates = np.where(pareto_front)[0]\n        selected_idx = random.choice(candidates)\n    else:\n        # If no Pareto optimal solutions, select based on crowding distance\n        crowding_distances = np.zeros(len(archive))\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n        selected_idx = np.argmax(crowding_distances)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge swap and segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid operation: edge swap with probability 0.7, segment inversion with probability 0.3\n        if random.random() < 0.7:\n            # Edge swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment inversion\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a dynamic node insertion and segment rotation operation, guided by a multi-objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a node to remove and insert elsewhere\n        remove_pos = random.randint(0, n - 1)\n        node = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Rotate a random segment\n        a, b = sorted(random.sample(range(n - 1), 2))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], random.randint(1, b - a))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8513620618625164,
            2.3784324526786804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a node to remove and insert elsewhere\n        remove_pos = random.randint(0, n - 1)\n        node = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Rotate a random segment\n        a, b = sorted(random.sample(range(n - 1), 2))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], random.randint(1, b - a))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0192234096974193,
            3.786520481109619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This novel algorithm combines a quality-diversity balanced selection with a multi-segment inversion and adaptive edge insertion operation, guided by a dynamic Pareto-front approximation to explore the solution space while maintaining feasibility and promoting high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using quality-diversity balance\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = 0.7 * quality_scores + 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply multi-segment inversion and adaptive edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        if a < b < c < d:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:a], segment2[::-1], new_solution[b+1:c], segment1[::-1], new_solution[d+1:]])\n\n        # Adaptive edge insertion\n        if random.random() < 0.5:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while j == i or j == (i+1) % n:\n                j = random.randint(0, n-2)\n            node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random inversion if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7579932133350551,
            1.1382777094841003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using quality-diversity balance\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = 0.7 * quality_scores + 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply multi-segment inversion and adaptive edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        if a < b < c < d:\n            segment1 = new_solution[a:b+1]\n            segment2 = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:a], segment2[::-1], new_solution[b+1:c], segment1[::-1], new_solution[d+1:]])\n\n        # Adaptive edge insertion\n        if random.random() < 0.5:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while j == i or j == (i+1) % n:\n                j = random.randint(0, n-2)\n            node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random inversion if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{A novel hybrid local search algorithm combines a Pareto-frontier-based selection of solutions with a multi-segment crossover and adaptive edge insertion operation, guided by a dynamic objective weighting scheme to efficiently explore the solution space while maintaining feasibility through a node reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution from Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply multi-segment crossover and adaptive edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple random segments and perform crossover\n        points = sorted(random.sample(range(1, n), 2))\n        a, b = points[0], points[1]\n\n        # Create two segments and swap them\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        new_solution = np.concatenate([segment1, segment3, segment2])\n\n        # Adaptive edge insertion\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate insertion cost for both objectives\n                cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%n]])\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n                # Insert if beneficial for at least one objective\n                if (cost1 < original_cost1) or (cost2 < original_cost2):\n                    new_solution = np.insert(new_solution, i+1, new_solution[j])\n                    new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Node reinsertion mechanism\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(len(new_solution)):\n                cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7142512588731823,
            4.771176874637604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution from Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply multi-segment crossover and adaptive edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple random segments and perform crossover\n        points = sorted(random.sample(range(1, n), 2))\n        a, b = points[0], points[1]\n\n        # Create two segments and swap them\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        new_solution = np.concatenate([segment1, segment3, segment2])\n\n        # Adaptive edge insertion\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate insertion cost for both objectives\n                cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%n]])\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n                # Insert if beneficial for at least one objective\n                if (cost1 < original_cost1) or (cost2 < original_cost2):\n                    new_solution = np.insert(new_solution, i+1, new_solution[j])\n                    new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Node reinsertion mechanism\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(len(instance)), unique_nodes)\n        for node in missing_nodes:\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(len(new_solution)):\n                cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{An adaptive local search heuristic that combines non-dominated sorting with a dynamic combination of segment relinking and node insertion operations, using objective-specific distance metrics to guide the search while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    fronts = []\n    dominated_counts = np.zeros(len(solutions))\n    dominating_sets = [[] for _ in range(len(solutions))]\n\n    for i in range(len(solutions)):\n        for j in range(len(solutions)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    dominating_sets[i].append(j)\n                elif all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                    dominated_counts[i] += 1\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    # Select from first front\n    front_indices = fronts[0]\n    if not front_indices:\n        front_indices = range(len(solutions))\n    selected_idx = random.choice(front_indices)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relinking with objective-aware probability\n        obj1_ratio = np.sum(distance_matrix_1[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) / (np.sum(distance_matrix_1) + 1)\n        obj2_ratio = np.sum(distance_matrix_2[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) / (np.sum(distance_matrix_2) + 1)\n\n        if random.random() < obj1_ratio:\n            # Relink segments in first objective space\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while abs(j - i) < 2:\n                j = random.randint(0, n-2)\n            segment1 = new_solution[i:i+2]\n            segment2 = new_solution[j:j+2]\n            new_solution[i:i+2] = segment2\n            new_solution[j:j+2] = segment1\n        else:\n            # Node insertion in second objective space\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Probabilistic validation\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.5:\n            # Random segment reversal\n            a = random.randint(0, n-1)\n            b = random.randint(0, n-1)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Random node insertion\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9229850477121473,
            5.561752080917358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    fronts = []\n    dominated_counts = np.zeros(len(solutions))\n    dominating_sets = [[] for _ in range(len(solutions))]\n\n    for i in range(len(solutions)):\n        for j in range(len(solutions)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    dominating_sets[i].append(j)\n                elif all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                    dominated_counts[i] += 1\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    # Select from first front\n    front_indices = fronts[0]\n    if not front_indices:\n        front_indices = range(len(solutions))\n    selected_idx = random.choice(front_indices)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relinking with objective-aware probability\n        obj1_ratio = np.sum(distance_matrix_1[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) / (np.sum(distance_matrix_1) + 1)\n        obj2_ratio = np.sum(distance_matrix_2[selected_solution[i], selected_solution[i+1]] for i in range(n-1)) / (np.sum(distance_matrix_2) + 1)\n\n        if random.random() < obj1_ratio:\n            # Relink segments in first objective space\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while abs(j - i) < 2:\n                j = random.randint(0, n-2)\n            segment1 = new_solution[i:i+2]\n            segment2 = new_solution[j:j+2]\n            new_solution[i:i+2] = segment2\n            new_solution[j:j+2] = segment1\n        else:\n            # Node insertion in second objective space\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Probabilistic validation\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.5:\n            # Random segment reversal\n            a = random.randint(0, n-1)\n            b = random.randint(0, n-1)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Random node insertion\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance guided selection of solutions with a dynamic edge-swap and node-insertion operation, guided by an adaptive objective trade-off to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance and objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        weights = np.random.dirichlet([1, 1])\n        selected_idx = np.argmin(weights[0] * objectives[:, 0] + weights[1] * objectives[:, 1])\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge-swap and node-insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Node-insertion operation\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7530804744721667,
            7.202170550823212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance and objective trade-off\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        weights = np.random.dirichlet([1, 1])\n        selected_idx = np.argmin(weights[0] * objectives[:, 0] + weights[1] * objectives[:, 1])\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge-swap and node-insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Node-insertion operation\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{A novel local search heuristic that combines Pareto-dominance guided solution selection with a hybrid of edge-swapping and segment-shuffling operations, ensuring feasible tours while exploring diverse regions of the solution space to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for other in objectives:\n            if dominates(other, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge-swapping and segment-shuffling\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge-swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-shuffling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7135996520736587,
            2.750990331172943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for other in objectives:\n            if dominates(other, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge-swapping and segment-shuffling\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge-swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-shuffling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{An adaptive local search heuristic that combines Pareto-dominance guided selection with a hybrid of node-insertion and segment-shifting operations, dynamically balancing objective improvements while preserving feasibility through a three-stage validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto-dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(solutions)-1)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Node-insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 3:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment-shifting operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 3: Three-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment shift\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8557627810497197,
            4.672428786754608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto-dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(solutions)-1)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Node-insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 3:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment-shifting operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 3: Three-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment shift\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{A novel local search heuristic that combines Pareto-dominance guided selection with a hybrid of segment-shifting and node-insertion operations, dynamically balancing objective improvements through a multi-stage validation mechanism to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto-dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Node-insertion operation\n        pos = random.randint(0, n-1)\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment shift\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random insertion\n        pos = random.randint(0, n-1)\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8331181128615778,
            3.464120030403137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto-dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Node-insertion operation\n        pos = random.randint(0, n-1)\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment shift\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random insertion\n        pos = random.randint(0, n-1)\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This novel algorithm combines a dominance-based selection of solutions from the archive with a hybrid of segment-swap and segment-insertion operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance count\n    dominance_counts = []\n    for i in range(len(archive)):\n        count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                   (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                    count += 1\n        dominance_counts.append(count)\n\n    if all(d == 0 for d in dominance_counts):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        min_dom = min(dominance_counts)\n        candidates = [i for i, d in enumerate(dominance_counts) if d == min_dom]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment swap operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        segment_length = random.randint(1, min(3, n//3))\n        start_i = i\n        end_i = start_i + segment_length\n        if end_i >= n:\n            end_i = n - 1\n            start_i = end_i - segment_length\n\n        start_j = j\n        end_j = start_j + segment_length\n        if end_j >= n:\n            end_j = n - 1\n            start_j = end_j - segment_length\n\n        segment_i = new_solution[start_i:end_i+1].copy()\n        segment_j = new_solution[start_j:end_j+1].copy()\n\n        new_solution[start_i:end_i+1] = segment_j\n        new_solution[start_j:end_j+1] = segment_i\n\n        # Segment insertion operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2 or abs(b - a) > n//2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6901290566079014,
            8.620022058486938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance count\n    dominance_counts = []\n    for i in range(len(archive)):\n        count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                   (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                    count += 1\n        dominance_counts.append(count)\n\n    if all(d == 0 for d in dominance_counts):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        min_dom = min(dominance_counts)\n        candidates = [i for i, d in enumerate(dominance_counts) if d == min_dom]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment swap operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        segment_length = random.randint(1, min(3, n//3))\n        start_i = i\n        end_i = start_i + segment_length\n        if end_i >= n:\n            end_i = n - 1\n            start_i = end_i - segment_length\n\n        start_j = j\n        end_j = start_j + segment_length\n        if end_j >= n:\n            end_j = n - 1\n            start_j = end_j - segment_length\n\n        segment_i = new_solution[start_i:end_i+1].copy()\n        segment_j = new_solution[start_j:end_j+1].copy()\n\n        new_solution[start_i:end_i+1] = segment_j\n        new_solution[start_j:end_j+1] = segment_i\n\n        # Segment insertion operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2 or abs(b - a) > n//2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1].copy()\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{A novel local search heuristic that combines a non-dominated sorting-based selection of solutions from the archive with a hybrid of edge-exchange and node-swapping operations, dynamically balancing the exploration of Pareto front regions by leveraging objective-specific dominance relationships to guide the search toward high-quality solutions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    # Find non-dominated solutions\n    non_dominated = []\n    for i in range(n):\n        dominated = False\n        for j in range(n):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, n-1)\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-exchange operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n\n        # Swap edges (i,i+1) and (j,j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Node-swapping operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while a == b:\n            b = random.randint(0, n-1)\n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to node swapping\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8415706070446731,
            2.858000159263611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution from the archive\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    # Find non-dominated solutions\n    non_dominated = []\n    for i in range(n):\n        dominated = False\n        for j in range(n):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, n-1)\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-exchange operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n\n        # Swap edges (i,i+1) and (j,j+1)\n        new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Node-swapping operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while a == b:\n            b = random.randint(0, n-1)\n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to node swapping\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This novel algorithm combines a dominance-based selection with a hybrid of dynamic node swapping and objective-aware segment insertion, leveraging both spatial and objective-distance metrics to guide the search toward high-quality, diverse solutions while maintaining feasibility through a novel validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective diversity\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic node swapping based on objective distances\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while b == a:\n            b = random.randint(0, n-1)\n\n        node_a = new_solution[a]\n        node_b = new_solution[b]\n\n        # Calculate objective distances\n        obj_dist1 = abs(distance_matrix_1[node_a, new_solution[(a+1)%n]] - distance_matrix_1[node_b, new_solution[(a+1)%n]]) + \\\n                     abs(distance_matrix_1[new_solution[(a-1)%n], node_a] - distance_matrix_1[new_solution[(a-1)%n], node_b])\n        obj_dist2 = abs(distance_matrix_2[node_a, new_solution[(a+1)%n]] - distance_matrix_2[node_b, new_solution[(a+1)%n]]) + \\\n                     abs(distance_matrix_2[new_solution[(a-1)%n], node_a] - distance_matrix_2[new_solution[(a-1)%n], node_b])\n\n        if obj_dist1 + obj_dist2 > 0.1 * (distance_matrix_1.max() + distance_matrix_2.max()):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Objective-aware segment insertion\n        if random.random() < 0.5:\n            start = random.randint(0, n-1)\n            length = random.randint(1, min(3, n//2))\n            end = min(start + length, n-1)\n\n            # Find best insertion position based on objective improvement\n            best_pos = -1\n            best_improvement = 0\n            for pos in range(n):\n                if pos >= start and pos <= end:\n                    continue\n\n                # Calculate potential improvement\n                prev_node = new_solution[(pos-1)%n]\n                next_node = new_solution[pos%n]\n                segment_cost1 = sum(distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] for node in new_solution[start:end+1])\n                new_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[end], next_node]\n                improvement1 = segment_cost1 - new_cost1\n\n                segment_cost2 = sum(distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] for node in new_solution[start:end+1])\n                new_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[end], next_node]\n                improvement2 = segment_cost2 - new_cost2\n\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pos = pos\n\n            if best_pos != -1:\n                segment = new_solution[start:end+1]\n                new_solution = np.concatenate([new_solution[:best_pos%n], segment, new_solution[best_pos%n:]])\n                if len(new_solution) > n:\n                    new_solution = new_solution[:n]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        duplicate_pos = [i for i, x in enumerate(new_solution) if list(new_solution).count(x) > 1]\n        for pos in duplicate_pos:\n            if missing:\n                new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8735901397271078,
            3.4477224946022034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective diversity\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic node swapping based on objective distances\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while b == a:\n            b = random.randint(0, n-1)\n\n        node_a = new_solution[a]\n        node_b = new_solution[b]\n\n        # Calculate objective distances\n        obj_dist1 = abs(distance_matrix_1[node_a, new_solution[(a+1)%n]] - distance_matrix_1[node_b, new_solution[(a+1)%n]]) + \\\n                     abs(distance_matrix_1[new_solution[(a-1)%n], node_a] - distance_matrix_1[new_solution[(a-1)%n], node_b])\n        obj_dist2 = abs(distance_matrix_2[node_a, new_solution[(a+1)%n]] - distance_matrix_2[node_b, new_solution[(a+1)%n]]) + \\\n                     abs(distance_matrix_2[new_solution[(a-1)%n], node_a] - distance_matrix_2[new_solution[(a-1)%n], node_b])\n\n        if obj_dist1 + obj_dist2 > 0.1 * (distance_matrix_1.max() + distance_matrix_2.max()):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Objective-aware segment insertion\n        if random.random() < 0.5:\n            start = random.randint(0, n-1)\n            length = random.randint(1, min(3, n//2))\n            end = min(start + length, n-1)\n\n            # Find best insertion position based on objective improvement\n            best_pos = -1\n            best_improvement = 0\n            for pos in range(n):\n                if pos >= start and pos <= end:\n                    continue\n\n                # Calculate potential improvement\n                prev_node = new_solution[(pos-1)%n]\n                next_node = new_solution[pos%n]\n                segment_cost1 = sum(distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] for node in new_solution[start:end+1])\n                new_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[end], next_node]\n                improvement1 = segment_cost1 - new_cost1\n\n                segment_cost2 = sum(distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] for node in new_solution[start:end+1])\n                new_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[end], next_node]\n                improvement2 = segment_cost2 - new_cost2\n\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pos = pos\n\n            if best_pos != -1:\n                segment = new_solution[start:end+1]\n                new_solution = np.concatenate([new_solution[:best_pos%n], segment, new_solution[best_pos%n:]])\n                if len(new_solution) > n:\n                    new_solution = new_solution[:n]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        duplicate_pos = [i for i, x in enumerate(new_solution) if list(new_solution).count(x) > 1]\n        for pos in duplicate_pos:\n            if missing:\n                new_solution[pos] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This novel algorithm combines a diversity-aware selection of solutions from the archive with a hybrid of multi-segment reversal and adaptive edge insertion operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility through a multi-stage validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using diversity-aware metric\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate diversity score for each solution\n    diversity_scores = []\n    for i in range(len(solutions)):\n        dist1 = np.sum(distance_matrix_1[solutions[i], :][:, solutions[i]])\n        dist2 = np.sum(distance_matrix_2[solutions[i], :][:, solutions[i]])\n        diversity_scores.append(dist1 + dist2)\n\n    # Select solution with highest diversity\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment reversal operation\n        num_segments = random.randint(1, min(3, n//4))\n        for _ in range(num_segments):\n            a = random.randint(0, n-1)\n            b = random.randint(0, n-1)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive edge insertion operation\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while abs(j - i) < 2:\n                j = random.randint(0, n-1)\n\n            # Calculate objective-specific distances\n            dist1_i = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            dist1_j = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            dist2_i = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            dist2_j = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Decide which insertion is better based on objectives\n            if (dist1_j + dist2_j) < (dist1_i + dist2_i):\n                # Insert edge (i,j)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7893773431817819,
            4.408249735832214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using diversity-aware metric\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate diversity score for each solution\n    diversity_scores = []\n    for i in range(len(solutions)):\n        dist1 = np.sum(distance_matrix_1[solutions[i], :][:, solutions[i]])\n        dist2 = np.sum(distance_matrix_2[solutions[i], :][:, solutions[i]])\n        diversity_scores.append(dist1 + dist2)\n\n    # Select solution with highest diversity\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment reversal operation\n        num_segments = random.randint(1, min(3, n//4))\n        for _ in range(num_segments):\n            a = random.randint(0, n-1)\n            b = random.randint(0, n-1)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive edge insertion operation\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while abs(j - i) < 2:\n                j = random.randint(0, n-1)\n\n            # Calculate objective-specific distances\n            dist1_i = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            dist1_j = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            dist2_i = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            dist2_j = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Decide which insertion is better based on objectives\n            if (dist1_j + dist2_j) < (dist1_i + dist2_i):\n                # Insert edge (i,j)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{An adaptive local search heuristic that combines crowding-distance based selection with a hybrid geometric and topological transformation operator, which dynamically adjusts the transformation parameters based on the relative importance of each objective to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (max_obj[i] - min_obj[i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate objective importance weights\n        obj1_diff = max_obj[0] - min_obj[0]\n        obj2_diff = max_obj[1] - min_obj[1]\n        total_diff = obj1_diff + obj2_diff\n        weight1 = obj1_diff / total_diff if total_diff > 0 else 0.5\n        weight2 = obj2_diff / total_diff if total_diff > 0 else 0.5\n\n        # Apply weighted transformation\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Transform based on weighted importance\n            if random.random() < weight1:\n                # Apply geometric transformation in first space\n                angle = random.uniform(-np.pi/4, np.pi/4)\n                cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n                x1, y1 = instance[node_idx, :2] - centroid1\n                x1_new = x1 * cos_theta - y1 * sin_theta\n                y1_new = x1 * sin_theta + y1 * cos_theta\n                instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n            else:\n                # Apply topological transformation in second space\n                x2, y2 = instance[node_idx, 2:] - centroid2\n                instance[node_idx, 2:] = np.array([y2, x2]) + centroid2  # Swap coordinates\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7301010234382438,
            1.67818945646286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (max_obj[i] - min_obj[i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate objective importance weights\n        obj1_diff = max_obj[0] - min_obj[0]\n        obj2_diff = max_obj[1] - min_obj[1]\n        total_diff = obj1_diff + obj2_diff\n        weight1 = obj1_diff / total_diff if total_diff > 0 else 0.5\n        weight2 = obj2_diff / total_diff if total_diff > 0 else 0.5\n\n        # Apply weighted transformation\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Transform based on weighted importance\n            if random.random() < weight1:\n                # Apply geometric transformation in first space\n                angle = random.uniform(-np.pi/4, np.pi/4)\n                cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n                x1, y1 = instance[node_idx, :2] - centroid1\n                x1_new = x1 * cos_theta - y1 * sin_theta\n                y1_new = x1 * sin_theta + y1 * cos_theta\n                instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n            else:\n                # Apply topological transformation in second space\n                x2, y2 = instance[node_idx, 2:] - centroid2\n                instance[node_idx, 2:] = np.array([y2, x2]) + centroid2  # Swap coordinates\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This novel local search heuristic dynamically selects solutions from the archive based on a probabilistic trade-off between objectives, then applies a hybrid of adaptive segment rotation and probabilistic node swapping operations to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with probability based on objective trade-off\n    total_norm = sum(np.linalg.norm(obj) for _, obj in archive)\n    probs = [np.linalg.norm(obj)/total_norm for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n    if n > 3:\n        # Adaptive segment rotation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:k], segment[1:], segment[:1], new_solution[l:]])\n        else:\n            new_solution = np.concatenate([new_solution[:k], np.roll(segment, 1), new_solution[l:]])\n\n        # Probabilistic node swapping\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8402877089703007,
            1.6757261157035828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with probability based on objective trade-off\n    total_norm = sum(np.linalg.norm(obj) for _, obj in archive)\n    probs = [np.linalg.norm(obj)/total_norm for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(new_solution)\n    if n > 3:\n        # Adaptive segment rotation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:k], segment[1:], segment[:1], new_solution[l:]])\n        else:\n            new_solution = np.concatenate([new_solution[:k], np.roll(segment, 1), new_solution[l:]])\n\n        # Probabilistic node swapping\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.2040775992429598,
            3.5232117772102356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.2040775992429598,
            3.5232117772102356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{An adaptive local search heuristic that combines Pareto-dominance guided segment insertion and dynamic edge swapping, prioritizing solutions with high hypervolume contribution while maintaining feasibility through constrained node reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = objectives.max(axis=0)\n    contributions = (max_obj - objectives).prod(axis=1)\n    selected_idx = np.argmax(contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, np.arange(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Perform edge swapping based on distance improvement\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n-1), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                old_cost = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                           distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                           distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                           distance_matrix_2[new_solution[j], new_solution[j+1]])\n                new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                           distance_matrix_1[new_solution[i+1], new_solution[j+1]] +\n                           distance_matrix_2[new_solution[i], new_solution[j]] +\n                           distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n                if new_cost < old_cost:\n                    new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6491650470960697,
            2.2187333703041077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = objectives.max(axis=0)\n    contributions = (max_obj - objectives).prod(axis=1)\n    selected_idx = np.argmax(contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, np.arange(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Perform edge swapping based on distance improvement\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n-1), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                old_cost = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                           distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                           distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                           distance_matrix_2[new_solution[j], new_solution[j+1]])\n                new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                           distance_matrix_1[new_solution[i+1], new_solution[j+1]] +\n                           distance_matrix_2[new_solution[i], new_solution[j]] +\n                           distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n                if new_cost < old_cost:\n                    new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This novel local search heuristic combines a multi-objective selection criterion based on Pareto front coverage and geometric diversity with a hybrid operator that performs both a dynamic path inversion and a context-aware node insertion, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto front coverage and geometric diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        # Select from Pareto front with geometric diversity\n        diversity_scores = []\n        for i in pareto_front:\n            centroid1 = instance[archive[i][0], :2].mean(axis=0)\n            centroid2 = instance[archive[i][0], 2:].mean(axis=0)\n            diversity_scores.append(np.linalg.norm(centroid1) + np.linalg.norm(centroid2))\n        selected_idx = pareto_front[np.argmax(diversity_scores)]\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (dynamic path inversion + context-aware insertion)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic path inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Context-aware insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        # Calculate insertion point based on geometric proximity\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n        dist1 = distance_matrix_1[node_i, node_j]\n        dist2 = distance_matrix_2[node_i, node_j]\n\n        if dist1 < dist2:\n            # Insert node_i before node_j if it's closer in first space\n            pos = np.where(new_solution == node_j)[0][0]\n            new_solution = np.insert(new_solution, pos, node_i)\n        else:\n            # Insert node_j before node_i if it's closer in second space\n            pos = np.where(new_solution == node_i)[0][0]\n            new_solution = np.insert(new_solution, pos, node_j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9365404782820516,
            3.0576916337013245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto front coverage and geometric diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        # Select from Pareto front with geometric diversity\n        diversity_scores = []\n        for i in pareto_front:\n            centroid1 = instance[archive[i][0], :2].mean(axis=0)\n            centroid2 = instance[archive[i][0], 2:].mean(axis=0)\n            diversity_scores.append(np.linalg.norm(centroid1) + np.linalg.norm(centroid2))\n        selected_idx = pareto_front[np.argmax(diversity_scores)]\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (dynamic path inversion + context-aware insertion)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic path inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Context-aware insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        # Calculate insertion point based on geometric proximity\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n        dist1 = distance_matrix_1[node_i, node_j]\n        dist2 = distance_matrix_2[node_i, node_j]\n\n        if dist1 < dist2:\n            # Insert node_i before node_j if it's closer in first space\n            pos = np.where(new_solution == node_j)[0][0]\n            new_solution = np.insert(new_solution, pos, node_i)\n        else:\n            # Insert node_j before node_i if it's closer in second space\n            pos = np.where(new_solution == node_i)[0][0]\n            new_solution = np.insert(new_solution, pos, node_j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This algorithm selects solutions based on their crowding distance in the objective space and applies a hybrid local search operator that combines edge insertion with a geometric transformation guided by the nodes' positions in both objective spaces, ensuring feasibility and exploration of diverse regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(n)\n\n    for i in range(n):\n        if i == 0 or i == n - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Edge insertion\n        a, b = sorted(random.sample(range(n_nodes), 2))\n        node_to_move = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node_to_move], new_solution[b+1:]])\n\n        # Geometric transformation\n        segment = new_solution[a:b+1]\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Scale in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            scale_factor = random.uniform(0.8, 1.2)\n            instance[node_idx, :2] = np.array([x1 * scale_factor, y1 * scale_factor]) + centroid1\n\n            # Shear in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            shear_factor = random.uniform(-0.5, 0.5)\n            instance[node_idx, 2:] = np.array([x2 + shear_factor * y2, y2]) + centroid2\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n_nodes:\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7502015186713973,
            3.2094287276268005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(n)\n\n    for i in range(n):\n        if i == 0 or i == n - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Edge insertion\n        a, b = sorted(random.sample(range(n_nodes), 2))\n        node_to_move = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node_to_move], new_solution[b+1:]])\n\n        # Geometric transformation\n        segment = new_solution[a:b+1]\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Scale in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            scale_factor = random.uniform(0.8, 1.2)\n            instance[node_idx, :2] = np.array([x1 * scale_factor, y1 * scale_factor]) + centroid1\n\n            # Shear in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            shear_factor = random.uniform(-0.5, 0.5)\n            instance[node_idx, 2:] = np.array([x2 + shear_factor * y2, y2]) + centroid2\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n_nodes:\n        i, j = random.sample(range(n_nodes), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This novel local search heuristic dynamically combines a Pareto-dominance guided selection with a hybrid of adaptive segment inversion and multi-objective-aware node relocation, using a weighted objective trade-off to balance exploration of the Pareto front while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high potential for improvement\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_idx = min(len(sorted_archive) // 2, len(archive) - 1)\n    selected_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with multi-objective awareness\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion based on objective trade-off\n        weights = np.random.dirichlet([1, 1])\n        obj1, obj2 = archive[selected_idx][1]\n        if weights[0] * obj1 > weights[1] * obj2:\n            k, l = random.randint(1, n-2), random.randint(1, n-2)\n            while k == l:\n                l = random.randint(1, n-2)\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n        else:\n            # Multi-objective aware node relocation\n            i, j = random.randint(0, n-1), random.randint(0, n-1)\n            while i == j:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility with probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(10):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8833925613083611,
            1.7555415034294128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high potential for improvement\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_idx = min(len(sorted_archive) // 2, len(archive) - 1)\n    selected_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with multi-objective awareness\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion based on objective trade-off\n        weights = np.random.dirichlet([1, 1])\n        obj1, obj2 = archive[selected_idx][1]\n        if weights[0] * obj1 > weights[1] * obj2:\n            k, l = random.randint(1, n-2), random.randint(1, n-2)\n            while k == l:\n                l = random.randint(1, n-2)\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n        else:\n            # Multi-objective aware node relocation\n            i, j = random.randint(0, n-1), random.randint(0, n-1)\n            while i == j:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility with probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        for _ in range(10):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{A novel local search heuristic that combines a dominance-based selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance count\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj_i = archive[i][1]\n                obj_j = archive[j][1]\n                if (obj_i[0] <= obj_j[0] and obj_i[1] < obj_j[1]) or (obj_i[0] < obj_j[0] and obj_i[1] <= obj_j[1]):\n                    dominance_counts[j] += 1\n\n    min_dominance_idx = np.argmin(dominance_counts)\n    selected_solution = archive[min_dominance_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8960499201048499,
            7.820393741130829
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance count\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj_i = archive[i][1]\n                obj_j = archive[j][1]\n                if (obj_i[0] <= obj_j[0] and obj_i[1] < obj_j[1]) or (obj_i[0] < obj_j[0] and obj_i[1] <= obj_j[1]):\n                    dominance_counts[j] += 1\n\n    min_dominance_idx = np.argmin(dominance_counts)\n    selected_solution = archive[min_dominance_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{A novel local search heuristic that combines a non-dominated sorting-based selection of solutions with a dynamic node insertion and removal operation, guided by a Pareto-based objective improvement criterion, to explore the solution space efficiently while maintaining feasibility through a multi-stage validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting-based selection\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Identify non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                           (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    # Select a random non-dominated solution\n    selected_idx = np.random.choice(non_dominated_indices)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Dynamic node insertion and removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random node and insert it at a different position\n        remove_pos = random.randint(0, n-1)\n        node_to_insert = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Randomly reverse a segment\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8547537729531619,
            3.1117144227027893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting-based selection\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Identify non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                           (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    # Select a random non-dominated solution\n    selected_idx = np.random.choice(non_dominated_indices)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Dynamic node insertion and removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random node and insert it at a different position\n        remove_pos = random.randint(0, n-1)\n        node_to_insert = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Randomly reverse a segment\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a dynamic edge swap and segment inversion operation, guided by a multi-objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with Pareto-dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and np.all(other_obj <= obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    diversity_scores = np.linalg.norm(objectives[pareto_front] - objectives[pareto_front].mean(axis=0), axis=1)\n    selected_idx = pareto_front[np.argmax(diversity_scores)]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge swap and segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and invert it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Swap two random edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6450005521187512,
            8.324601948261261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with Pareto-dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and np.all(other_obj <= obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    diversity_scores = np.linalg.norm(objectives[pareto_front] - objectives[pareto_front].mean(axis=0), axis=1)\n    selected_idx = pareto_front[np.argmax(diversity_scores)]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge swap and segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and invert it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Swap two random edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This novel algorithm combines a dominance-aware selection of solutions with a geometric-aware local search operator that performs adaptive segment flipping and rotation, leveraging both objective-specific distance metrics and geometric properties to explore diverse trade-off regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment flipping and rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate geometric properties\n        segment_coords1 = instance[segment, :2]\n        segment_coords2 = instance[segment, 2:]\n\n        # Adaptive flipping based on objective trade-offs\n        obj1_diff = objectives[selected_idx][0] - objectives[np.argmin(objectives[:,0])][0]\n        obj2_diff = objectives[selected_idx][1] - objectives[np.argmin(objectives[:,1])][1]\n\n        if obj1_diff > obj2_diff:\n            # Flip segment in first space\n            segment_coords1 = segment_coords1[::-1]\n        else:\n            # Flip segment in second space\n            segment_coords2 = segment_coords2[::-1]\n\n        # Apply rotation based on segment's dominant objective\n        centroid1 = segment_coords1.mean(axis=0)\n        centroid2 = segment_coords2.mean(axis=0)\n\n        # Calculate principal component direction\n        cov1 = np.cov(segment_coords1.T)\n        eigvals1, eigvecs1 = np.linalg.eig(cov1)\n        main_dir1 = eigvecs1[:, np.argmax(eigvals1)]\n\n        angle = np.arctan2(main_dir1[1], main_dir1[0])\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        # Rotate segment in both spaces\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = segment_coords1[i] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Rotate in second space\n            x2, y2 = segment_coords2[i] - centroid2\n            x2_new, y2_new = rotation_matrix @ np.array([x2, y2])\n            instance[node_idx, 2:] = np.array([x2_new, y2_new]) + centroid2\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7980704661385517,
            2.610826551914215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment flipping and rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate geometric properties\n        segment_coords1 = instance[segment, :2]\n        segment_coords2 = instance[segment, 2:]\n\n        # Adaptive flipping based on objective trade-offs\n        obj1_diff = objectives[selected_idx][0] - objectives[np.argmin(objectives[:,0])][0]\n        obj2_diff = objectives[selected_idx][1] - objectives[np.argmin(objectives[:,1])][1]\n\n        if obj1_diff > obj2_diff:\n            # Flip segment in first space\n            segment_coords1 = segment_coords1[::-1]\n        else:\n            # Flip segment in second space\n            segment_coords2 = segment_coords2[::-1]\n\n        # Apply rotation based on segment's dominant objective\n        centroid1 = segment_coords1.mean(axis=0)\n        centroid2 = segment_coords2.mean(axis=0)\n\n        # Calculate principal component direction\n        cov1 = np.cov(segment_coords1.T)\n        eigvals1, eigvecs1 = np.linalg.eig(cov1)\n        main_dir1 = eigvecs1[:, np.argmax(eigvals1)]\n\n        angle = np.arctan2(main_dir1[1], main_dir1[0])\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        # Rotate segment in both spaces\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = segment_coords1[i] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Rotate in second space\n            x2, y2 = segment_coords2[i] - centroid2\n            x2_new, y2_new = rotation_matrix @ np.array([x2, y2])\n            instance[node_idx, 2:] = np.array([x2_new, y2_new]) + centroid2\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This novel algorithm employs a dominance-based selection strategy combined with a hybrid of edge exchange and segment rotation operations, dynamically refining solutions by prioritizing non-dominated regions and introducing objective-specific perturbations to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance rank\n    objectives = [obj for _, obj in archive]\n    sorted_indices = sorted(range(len(objectives)), key=lambda i: (objectives[i][0], objectives[i][1]))\n    selected_idx = sorted_indices[0]  # Select the non-dominated solution\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge exchange operation\n        i, j = random.sample(range(n), 2)\n        a, b = random.sample(range(n), 2)\n        while i == j or a == b:\n            i, j = random.sample(range(n), 2)\n            a, b = random.sample(range(n), 2)\n\n        # Swap edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment rotation operation\n        k = random.randint(0, n-1)\n        m = random.randint(0, n-1)\n        while abs(m - k) < 2:\n            m = random.randint(0, n-1)\n\n        if k > m:\n            k, m = m, k\n        segment = new_solution[k:m+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution[k:m+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8965131502742214,
            2.0987181663513184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance rank\n    objectives = [obj for _, obj in archive]\n    sorted_indices = sorted(range(len(objectives)), key=lambda i: (objectives[i][0], objectives[i][1]))\n    selected_idx = sorted_indices[0]  # Select the non-dominated solution\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge exchange operation\n        i, j = random.sample(range(n), 2)\n        a, b = random.sample(range(n), 2)\n        while i == j or a == b:\n            i, j = random.sample(range(n), 2)\n            a, b = random.sample(range(n), 2)\n\n        # Swap edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment rotation operation\n        k = random.randint(0, n-1)\n        m = random.randint(0, n-1)\n        while abs(m - k) < 2:\n            m = random.randint(0, n-1)\n\n        if k > m:\n            k, m = m, k\n        segment = new_solution[k:m+1]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution[k:m+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This novel local search heuristic combines a non-dominated sorting-based selection of solutions with a dynamic segment rotation and edge swapping operation, guided by a Pareto-dominance-based improvement criterion to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Perform non-dominated sorting\n    fronts = [[]]\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominating_sets[i].append(j)\n                elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] < objectives[i][1]) or \\\n                     (objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                    dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts[0].append(i)\n\n    # Select a solution from the first front\n    selected_idx = random.choice(fronts[0])\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic segment rotation and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and rotate it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = rotated_segment\n\n        # Swap two random edges\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8577915734999433,
            1.9954159259796143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Perform non-dominated sorting\n    fronts = [[]]\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominating_sets[i].append(j)\n                elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] < objectives[i][1]) or \\\n                     (objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                    dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts[0].append(i)\n\n    # Select a solution from the first front\n    selected_idx = random.choice(fronts[0])\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic segment rotation and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and rotate it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = rotated_segment\n\n        # Swap two random edges\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{A novel local search heuristic that combines objective-specific edge swapping with a dynamic node insertion and deletion operation, guided by a multi-objective improvement metric that prioritizes solutions with balanced improvements in both objectives while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    improvements = objectives - objectives.mean(axis=0)\n    improvement_scores = np.abs(improvements[:, 0] - improvements[:, 1])\n    selected_idx = np.argmin(improvement_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply objective-specific edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Dynamic node insertion and deletion\n        if random.random() < 0.3:\n            # Insert a random node from another solution\n            other_solution = random.choice(archive)[0]\n            insert_node = random.choice(other_solution)\n            if insert_node not in new_solution:\n                insert_pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, insert_pos, insert_node)\n        elif random.random() < 0.2:\n            # Delete a random node (except first and last)\n            if n > 4:\n                delete_pos = random.randint(1, n-2)\n                new_solution = np.delete(new_solution, delete_pos)\n\n    # Step 3: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = set(range(len(instance))) - set(new_solution)\n        if missing_nodes:\n            for i in range(len(new_solution)):\n                if list(new_solution).count(new_solution[i]) > 1:\n                    new_solution[i] = random.choice(list(missing_nodes))\n                    missing_nodes.remove(new_solution[i])\n                    if not missing_nodes:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6230786166885658,
            1.6395659446716309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    improvements = objectives - objectives.mean(axis=0)\n    improvement_scores = np.abs(improvements[:, 0] - improvements[:, 1])\n    selected_idx = np.argmin(improvement_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply objective-specific edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Dynamic node insertion and deletion\n        if random.random() < 0.3:\n            # Insert a random node from another solution\n            other_solution = random.choice(archive)[0]\n            insert_node = random.choice(other_solution)\n            if insert_node not in new_solution:\n                insert_pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, insert_pos, insert_node)\n        elif random.random() < 0.2:\n            # Delete a random node (except first and last)\n            if n > 4:\n                delete_pos = random.randint(1, n-2)\n                new_solution = np.delete(new_solution, delete_pos)\n\n    # Step 3: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = set(range(len(instance))) - set(new_solution)\n        if missing_nodes:\n            for i in range(len(new_solution)):\n                if list(new_solution).count(new_solution[i]) > 1:\n                    new_solution[i] = random.choice(list(missing_nodes))\n                    missing_nodes.remove(new_solution[i])\n                    if not missing_nodes:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This novel algorithm employs a Pareto-frontier-aware selection mechanism combined with a dynamic segment-swapping and objective-biased reversal strategy to generate high-quality neighbors by prioritizing solutions with under-explored trade-off regions and applying tailored local search operations that adaptively balance the improvement of both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on Pareto frontier and objective diversity\n    objectives = [obj for _, obj in archive]\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto solutions, select based on objective space coverage\n        obj1_min, obj1_max = min(o[0] for o in objectives), max(o[0] for o in objectives)\n        obj2_min, obj2_max = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n        coverage_scores = []\n        for obj in objectives:\n            norm1 = (obj[0] - obj1_min) / (obj1_max - obj1_min) if obj1_max > obj1_min else 0.5\n            norm2 = (obj[1] - obj2_min) / (obj2_max - obj2_min) if obj2_max > obj2_min else 0.5\n            coverage_scores.append(norm1 + norm2)\n\n        selected_idx = coverage_scores.index(max(coverage_scores))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Dynamic segment swapping with objective bias\n    if n > 3:\n        # Select segment based on objective improvement potential\n        obj_weights = [0.5, 0.5]  # Equal weights for both objectives\n        segment_scores = []\n\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):\n                # Calculate potential improvement for both objectives\n                current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Alternative segment\n                alt_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                alt_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n                improvement1 = current_cost1 - alt_cost1\n                improvement2 = current_cost2 - alt_cost2\n\n                score = obj_weights[0] * improvement1 + obj_weights[1] * improvement2\n                segment_scores.append((i, j, score))\n\n        if segment_scores:\n            best_segment = max(segment_scores, key=lambda x: x[2])\n            i, j, _ = best_segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Objective-biased reversal\n    if n > 3:\n        obj_bias = random.choice([0, 1])  # Randomly select which objective to prioritize\n        obj_weights = [0.7, 0.3] if obj_bias == 0 else [0.3, 0.7]\n\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        # Evaluate potential improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b))\n\n        reversed_cost1 = sum(distance_matrix_1[new_solution[(i+1)%n], new_solution[i]] for i in reversed(range(a, b)))\n        reversed_cost2 = sum(distance_matrix_2[new_solution[(i+1)%n], new_solution[i]] for i in reversed(range(a, b)))\n\n        improvement1 = current_cost1 - reversed_cost1\n        improvement2 = current_cost2 - reversed_cost2\n\n        if (obj_weights[0] * improvement1 + obj_weights[1] * improvement2) > 0:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Simple repair mechanism\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [i for i, x in enumerate(new_solution) if list(new_solution).count(x) > 1]\n\n        if missing and duplicates:\n            for dup in duplicates:\n                if missing:\n                    new_solution[dup] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8955907482874895,
            4.980636894702911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on Pareto frontier and objective diversity\n    objectives = [obj for _, obj in archive]\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        # If no Pareto solutions, select based on objective space coverage\n        obj1_min, obj1_max = min(o[0] for o in objectives), max(o[0] for o in objectives)\n        obj2_min, obj2_max = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n        coverage_scores = []\n        for obj in objectives:\n            norm1 = (obj[0] - obj1_min) / (obj1_max - obj1_min) if obj1_max > obj1_min else 0.5\n            norm2 = (obj[1] - obj2_min) / (obj2_max - obj2_min) if obj2_max > obj2_min else 0.5\n            coverage_scores.append(norm1 + norm2)\n\n        selected_idx = coverage_scores.index(max(coverage_scores))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Dynamic segment swapping with objective bias\n    if n > 3:\n        # Select segment based on objective improvement potential\n        obj_weights = [0.5, 0.5]  # Equal weights for both objectives\n        segment_scores = []\n\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):\n                # Calculate potential improvement for both objectives\n                current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Alternative segment\n                alt_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                alt_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n                improvement1 = current_cost1 - alt_cost1\n                improvement2 = current_cost2 - alt_cost2\n\n                score = obj_weights[0] * improvement1 + obj_weights[1] * improvement2\n                segment_scores.append((i, j, score))\n\n        if segment_scores:\n            best_segment = max(segment_scores, key=lambda x: x[2])\n            i, j, _ = best_segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Objective-biased reversal\n    if n > 3:\n        obj_bias = random.choice([0, 1])  # Randomly select which objective to prioritize\n        obj_weights = [0.7, 0.3] if obj_bias == 0 else [0.3, 0.7]\n\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        # Evaluate potential improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b))\n\n        reversed_cost1 = sum(distance_matrix_1[new_solution[(i+1)%n], new_solution[i]] for i in reversed(range(a, b)))\n        reversed_cost2 = sum(distance_matrix_2[new_solution[(i+1)%n], new_solution[i]] for i in reversed(range(a, b)))\n\n        improvement1 = current_cost1 - reversed_cost1\n        improvement2 = current_cost2 - reversed_cost2\n\n        if (obj_weights[0] * improvement1 + obj_weights[1] * improvement2) > 0:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Simple repair mechanism\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [i for i, x in enumerate(new_solution) if list(new_solution).count(x) > 1]\n\n        if missing and duplicates:\n            for dup in duplicates:\n                if missing:\n                    new_solution[dup] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This novel local search algorithm combines an adaptive objective-based selection with a hybrid of segment rotation and node insertion operations, guided by a dynamic trade-off between objectives to efficiently explore the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive objective trade-off\n    weights = np.random.dirichlet([0.7, 0.3]) if np.random.random() < 0.5 else np.random.dirichlet([0.3, 0.7])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation operation\n        k = random.randint(1, n-3)\n        l = random.randint(k+1, n-2)\n        segment = new_solution[k:l]\n        rotated_segment = np.roll(segment, 1)\n        new_solution = np.concatenate([new_solution[:k], rotated_segment, new_solution[l:]])\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8423508161166251,
            2.4138941168785095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on adaptive objective trade-off\n    weights = np.random.dirichlet([0.7, 0.3]) if np.random.random() < 0.5 else np.random.dirichlet([0.3, 0.7])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation operation\n        k = random.randint(1, n-3)\n        l = random.randint(k+1, n-2)\n        segment = new_solution[k:l]\n        rotated_segment = np.roll(segment, 1)\n        new_solution = np.concatenate([new_solution[:k], rotated_segment, new_solution[l:]])\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{A novel local search heuristic selects solutions based on their dominance rank and applies a hybrid operator that combines edge insertion with adaptive perturbation, guided by the Pareto front to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest dominance rank (non-dominated solutions preferred)\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (edge insertion + adaptive perturbation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Remove the edge (i, j)\n        removed_node = new_solution[j]\n\n        # Insert the node at a new position\n        new_pos = random.randint(0, n-1)\n        if new_pos == i or new_pos == j:\n            new_pos = (new_pos + 1) % n\n\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        new_solution = np.insert(new_solution, new_pos, removed_node)\n\n        # Apply adaptive perturbation based on objective weights\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n\n        if total > 0:\n            weight1 = obj1 / total\n            weight2 = obj2 / total\n        else:\n            weight1, weight2 = 0.5, 0.5\n\n        # Perturb node positions based on weights\n        for node_idx in range(n):\n            perturbation1 = (random.random() - 0.5) * 2 * weight1\n            perturbation2 = (random.random() - 0.5) * 2 * weight2\n            instance[node_idx, :2] = instance[node_idx, :2] * (1 + perturbation1)\n            instance[node_idx, 2:] = instance[node_idx, 2:] * (1 + perturbation2)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9689832881351977,
            3.5540473461151123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest dominance rank (non-dominated solutions preferred)\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (edge insertion + adaptive perturbation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Remove the edge (i, j)\n        removed_node = new_solution[j]\n\n        # Insert the node at a new position\n        new_pos = random.randint(0, n-1)\n        if new_pos == i or new_pos == j:\n            new_pos = (new_pos + 1) % n\n\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        new_solution = np.insert(new_solution, new_pos, removed_node)\n\n        # Apply adaptive perturbation based on objective weights\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n\n        if total > 0:\n            weight1 = obj1 / total\n            weight2 = obj2 / total\n        else:\n            weight1, weight2 = 0.5, 0.5\n\n        # Perturb node positions based on weights\n        for node_idx in range(n):\n            perturbation1 = (random.random() - 0.5) * 2 * weight1\n            perturbation2 = (random.random() - 0.5) * 2 * weight2\n            instance[node_idx, :2] = instance[node_idx, :2] * (1 + perturbation1)\n            instance[node_idx, 2:] = instance[node_idx, 2:] * (1 + perturbation2)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This novel algorithm combines a dominance-based selection of solutions from the archive with a hybrid of adaptive segment insertion and objective-biased edge swapping, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective diversity\n    objectives = [obj for _, obj in archive]\n    selected_idx = 0\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n\n    for i, (obj1, obj2) in enumerate(objectives):\n        if obj1 <= min_obj1 and obj2 <= min_obj2 and (obj1 < min_obj1 or obj2 < min_obj2):\n            selected_idx = i\n            min_obj1, min_obj2 = obj1, obj2\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive segment insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment insertion\n        segment_length = random.randint(1, min(4, n//3))\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        new_segment = other_solution[start:end+1]\n\n        # Insert segment into current solution\n        insert_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            new_segment,\n            new_solution[insert_pos + segment_length:]\n        ])\n\n        # Objective-biased edge swapping\n        for _ in range(2):\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, n-1)\n\n            # Calculate objective-specific costs\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if at least one objective improves\n            if cost1_after < cost1_before or cost2_after < cost2_before:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = random.choice(list(missing_nodes))\n                missing_nodes.remove(new_solution[i])\n                if not missing_nodes:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8730772326924446,
            1.0507668852806091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective diversity\n    objectives = [obj for _, obj in archive]\n    selected_idx = 0\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n\n    for i, (obj1, obj2) in enumerate(objectives):\n        if obj1 <= min_obj1 and obj2 <= min_obj2 and (obj1 < min_obj1 or obj2 < min_obj2):\n            selected_idx = i\n            min_obj1, min_obj2 = obj1, obj2\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive segment insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment insertion\n        segment_length = random.randint(1, min(4, n//3))\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        new_segment = other_solution[start:end+1]\n\n        # Insert segment into current solution\n        insert_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            new_segment,\n            new_solution[insert_pos + segment_length:]\n        ])\n\n        # Objective-biased edge swapping\n        for _ in range(2):\n            i = random.randint(0, n-2)\n            j = random.randint(i+1, n-1)\n\n            # Calculate objective-specific costs\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if at least one objective improves\n            if cost1_after < cost1_before or cost2_after < cost2_before:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = random.choice(list(missing_nodes))\n                missing_nodes.remove(new_solution[i])\n                if not missing_nodes:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{A novel local search heuristic that combines adaptive Pareto-dominance filtering with a hybrid of node sequence rotation and edge expansion operations, guided by a dynamic objective trade-off to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Filter non-dominated solutions\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1]):\n                dominated[i] = True\n                break\n    non_dominated = [sol for i, sol in enumerate(archive) if not dominated[i]]\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select solution with highest diversity\n    objectives = np.array([obj for _, obj in non_dominated])\n    centroid = objectives.mean(axis=0)\n    diversity_scores = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid operations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node sequence rotation\n        k = random.randint(1, n-1)\n        rotation = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, rotation) if k % 2 == 0 else np.roll(new_solution, -rotation)\n\n        # Edge expansion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and abs(i-j) > 1:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.733611434792283,
            0.7828734517097473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Filter non-dominated solutions\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1]):\n                dominated[i] = True\n                break\n    non_dominated = [sol for i, sol in enumerate(archive) if not dominated[i]]\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select solution with highest diversity\n    objectives = np.array([obj for _, obj in non_dominated])\n    centroid = objectives.mean(axis=0)\n    diversity_scores = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid operations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node sequence rotation\n        k = random.randint(1, n-1)\n        rotation = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, rotation) if k % 2 == 0 else np.roll(new_solution, -rotation)\n\n        # Edge expansion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and abs(i-j) > 1:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This novel algorithm employs a multi-objective adaptive k-means clustering approach on the archive's objective space to identify under-explored regions, then applies a hybrid of edge insertion and node migration operations guided by both objective-specific distance metrics and a Pareto dominance-based selection criterion to generate diverse, high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Multi-objective adaptive k-means clustering\n    objectives = np.array([obj for _, obj in archive])\n    k = min(3, len(archive))\n    centroids = objectives[np.random.choice(len(archive), k, replace=False)]\n\n    for _ in range(5):\n        distances = np.linalg.norm(objectives[:, np.newaxis] - centroids, axis=2)\n        clusters = np.argmin(distances, axis=1)\n        new_centroids = np.array([objectives[clusters == i].mean(axis=0) if np.any(clusters == i) else centroids[i] for i in range(k)])\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n\n    # Select solution from least populated cluster\n    cluster_sizes = np.bincount(clusters, minlength=k)\n    least_populated = np.argmin(cluster_sizes)\n    candidates = [i for i, c in enumerate(clusters) if c == least_populated]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search with edge insertion and node migration\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge insertion operation\n        i, j = sorted(random.sample(range(n), 2))\n        node_to_move = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(i, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n        # Node migration guided by objective improvement\n        a, b = sorted(random.sample(range(n-1), 2))\n        node_a = new_solution[a]\n        node_b = new_solution[b]\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[node_a, new_solution[a-1]] + distance_matrix_1[new_solution[a+1], node_b]\n        new_dist1 = distance_matrix_1[node_b, new_solution[a-1]] + distance_matrix_1[new_solution[a+1], node_a]\n\n        old_dist2 = distance_matrix_2[node_a, new_solution[a-1]] + distance_matrix_2[new_solution[a+1], node_b]\n        new_dist2 = distance_matrix_2[node_b, new_solution[a-1]] + distance_matrix_2[new_solution[a+1], node_a]\n\n        if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or \\\n           (random.random() < 0.3):  # 30% chance to accept non-dominated moves\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7379131926044242,
            4.17807811498642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Multi-objective adaptive k-means clustering\n    objectives = np.array([obj for _, obj in archive])\n    k = min(3, len(archive))\n    centroids = objectives[np.random.choice(len(archive), k, replace=False)]\n\n    for _ in range(5):\n        distances = np.linalg.norm(objectives[:, np.newaxis] - centroids, axis=2)\n        clusters = np.argmin(distances, axis=1)\n        new_centroids = np.array([objectives[clusters == i].mean(axis=0) if np.any(clusters == i) else centroids[i] for i in range(k)])\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n\n    # Select solution from least populated cluster\n    cluster_sizes = np.bincount(clusters, minlength=k)\n    least_populated = np.argmin(cluster_sizes)\n    candidates = [i for i, c in enumerate(clusters) if c == least_populated]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search with edge insertion and node migration\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge insertion operation\n        i, j = sorted(random.sample(range(n), 2))\n        node_to_move = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(i, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n        # Node migration guided by objective improvement\n        a, b = sorted(random.sample(range(n-1), 2))\n        node_a = new_solution[a]\n        node_b = new_solution[b]\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[node_a, new_solution[a-1]] + distance_matrix_1[new_solution[a+1], node_b]\n        new_dist1 = distance_matrix_1[node_b, new_solution[a-1]] + distance_matrix_1[new_solution[a+1], node_a]\n\n        old_dist2 = distance_matrix_2[node_a, new_solution[a-1]] + distance_matrix_2[new_solution[a+1], node_b]\n        new_dist2 = distance_matrix_2[node_b, new_solution[a-1]] + distance_matrix_2[new_solution[a+1], node_a]\n\n        if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or \\\n           (random.random() < 0.3):  # 30% chance to accept non-dominated moves\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This novel local search heuristic selects solutions based on their dominance relationships in the objective space and applies a hybrid operator that combines node insertion with adaptive segment rotation, guided by the geometric properties of the nodes in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on dominance relationships\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1] and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                dominated[i] = True\n                break\n\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (insertion + rotation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment rotation operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate rotation angle based on geometric properties\n        center1 = instance[segment, :2].mean(axis=0)\n        center2 = instance[segment, 2:].mean(axis=0)\n        angle1 = np.arctan2(center1[1], center1[0])\n        angle2 = np.arctan2(center2[1], center2[0])\n        angle = (angle1 + angle2) / 2\n\n        # Apply rotation to segment\n        for node_idx in segment:\n            x1, y1, x2, y2 = instance[node_idx]\n            new_x1 = center1[0] + (x1 - center1[0]) * np.cos(angle) - (y1 - center1[1]) * np.sin(angle)\n            new_y1 = center1[1] + (x1 - center1[0]) * np.sin(angle) + (y1 - center1[1]) * np.cos(angle)\n            new_x2 = center2[0] + (x2 - center2[0]) * np.cos(angle) - (y2 - center2[1]) * np.sin(angle)\n            new_y2 = center2[1] + (x2 - center2[0]) * np.sin(angle) + (y2 - center2[1]) * np.cos(angle)\n            instance[node_idx] = [new_x1, new_y1, new_x2, new_y2]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.689423270702738,
            3.4123736023902893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on dominance relationships\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1] and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                dominated[i] = True\n                break\n\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (insertion + rotation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Segment rotation operation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate rotation angle based on geometric properties\n        center1 = instance[segment, :2].mean(axis=0)\n        center2 = instance[segment, 2:].mean(axis=0)\n        angle1 = np.arctan2(center1[1], center1[0])\n        angle2 = np.arctan2(center2[1], center2[0])\n        angle = (angle1 + angle2) / 2\n\n        # Apply rotation to segment\n        for node_idx in segment:\n            x1, y1, x2, y2 = instance[node_idx]\n            new_x1 = center1[0] + (x1 - center1[0]) * np.cos(angle) - (y1 - center1[1]) * np.sin(angle)\n            new_y1 = center1[1] + (x1 - center1[0]) * np.sin(angle) + (y1 - center1[1]) * np.cos(angle)\n            new_x2 = center2[0] + (x2 - center2[0]) * np.cos(angle) - (y2 - center2[1]) * np.sin(angle)\n            new_y2 = center2[1] + (x2 - center2[0]) * np.sin(angle) + (y2 - center2[1]) * np.cos(angle)\n            instance[node_idx] = [new_x1, new_y1, new_x2, new_y2]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{A novel local search heuristic selects solutions based on their crowding distance and applies a hybrid operator that combines segment reversal and geometric scaling, guided by the relative importance of each objective space to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        distances = np.linalg.norm(objectives - objectives[i], axis=1)\n        crowding_distances[i] = np.mean(np.sort(distances)[1:4])  # Average of 3 nearest neighbors\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate segment costs in both spaces\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Decide transformation based on relative costs\n        if cost1 > cost2:\n            # Reverse segment\n            segment = segment[::-1]\n        else:\n            # Scale segment\n            scale_factor = random.uniform(0.8, 1.2)\n            for node_idx in segment:\n                instance[node_idx, :2] *= scale_factor\n                instance[node_idx, 2:] *= scale_factor\n\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7581491001891845,
            2.4886310696601868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        distances = np.linalg.norm(objectives - objectives[i], axis=1)\n        crowding_distances[i] = np.mean(np.sort(distances)[1:4])  # Average of 3 nearest neighbors\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate segment costs in both spaces\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Decide transformation based on relative costs\n        if cost1 > cost2:\n            # Reverse segment\n            segment = segment[::-1]\n        else:\n            # Scale segment\n            scale_factor = random.uniform(0.8, 1.2)\n            for node_idx in segment:\n                instance[node_idx, :2] *= scale_factor\n                instance[node_idx, 2:] *= scale_factor\n\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm combines a non-dominated sorting-based selection with a hybrid segment relocation and path reversal operation to balance exploration and exploitation, using both spatial and objective-space information to guide the search toward diverse high-quality regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    fronts = []\n    remaining = list(range(len(objectives)))\n    while remaining:\n        front = []\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                               (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                    dominated = True\n                    break\n            if not dominated:\n                front.append(i)\n        fronts.append(front)\n        remaining = [i for i in remaining if i not in front]\n\n    selected_idx = random.choice(fronts[0]) if fronts else random.randint(0, len(solutions)-1)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid segment relocation and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relocation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            segment = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Path reversal with objective-based selection\n        if random.random() < 0.3:\n            a = random.randint(0, n-2)\n            b = random.randint(a+1, n-1)\n            segment = new_solution[a:b+1]\n            cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n            cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 < cost1 and reversed_cost2 < cost2) or (random.random() < 0.2):\n                new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8038568302125929,
            3.301191508769989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    fronts = []\n    remaining = list(range(len(objectives)))\n    while remaining:\n        front = []\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                               (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                    dominated = True\n                    break\n            if not dominated:\n                front.append(i)\n        fronts.append(front)\n        remaining = [i for i in remaining if i not in front]\n\n    selected_idx = random.choice(fronts[0]) if fronts else random.randint(0, len(solutions)-1)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid segment relocation and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment relocation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            segment = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Path reversal with objective-based selection\n        if random.random() < 0.3:\n            a = random.randint(0, n-2)\n            b = random.randint(a+1, n-1)\n            segment = new_solution[a:b+1]\n            cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n            cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 < cost1 and reversed_cost2 < cost2) or (random.random() < 0.2):\n                new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance guided selection of solutions from the archive, followed by a hybrid of edge-swap and random segment replacement operations, guided by a dynamic trade-off between the two objectives to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution with high diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap: randomly select two edges and swap their nodes\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n        # Random segment replacement: replace a random segment with a segment from another non-dominated solution\n        if non_dominated:\n            other_solution = archive[random.choice(non_dominated)][0]\n            a, b = sorted(random.sample(range(n), 2))\n            segment = other_solution[a:b+1]\n            new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8825975407224216,
            1.3238374590873718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution with high diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap: randomly select two edges and swap their nodes\n        a, b, c, d = random.sample(range(n), 4)\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n        # Random segment replacement: replace a random segment with a segment from another non-dominated solution\n        if non_dominated:\n            other_solution = archive[random.choice(non_dominated)][0]\n            a, b = sorted(random.sample(range(n), 2))\n            segment = other_solution[a:b+1]\n            new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This new algorithm selects solutions based on their crowding distance in the objective space and applies a segment reversal operator followed by a geometric scaling transformation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        neighbors = []\n        for j in range(len(archive)):\n            if i != j:\n                neighbors.append(j)\n        if not neighbors:\n            crowding_distances[i] = float('inf')\n            continue\n\n        # Calculate crowding distance\n        sorted_front = objectives[neighbors]\n        sorted_front = sorted_front[np.argsort(sorted_front[:, 0])]\n        crowding = 0.0\n        for m in range(1, len(sorted_front)-1):\n            crowding += abs(sorted_front[m+1, 0] - sorted_front[m-1, 0]) / (sorted_front[-1, 0] - sorted_front[0, 0] + 1e-10)\n        sorted_front = sorted_front[np.argsort(sorted_front[:, 1])]\n        for m in range(1, len(sorted_front)-1):\n            crowding += abs(sorted_front[m+1, 1] - sorted_front[m-1, 1]) / (sorted_front[-1, 1] - sorted_front[0, 1] + 1e-10)\n        crowding_distances[i] = crowding\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply segment reversal and scaling\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse and scale\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse the segment\n        segment = segment[::-1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply scaling transformation\n        scale1 = random.uniform(0.8, 1.2)\n        scale2 = random.uniform(0.8, 1.2)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Scale in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            instance[node_idx, :2] = np.array([x1 * scale1, y1 * scale1]) + centroid1\n\n            # Scale in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2:] = np.array([x2 * scale2, y2 * scale2]) + centroid2\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7960334897843488,
            6.970097243785858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        neighbors = []\n        for j in range(len(archive)):\n            if i != j:\n                neighbors.append(j)\n        if not neighbors:\n            crowding_distances[i] = float('inf')\n            continue\n\n        # Calculate crowding distance\n        sorted_front = objectives[neighbors]\n        sorted_front = sorted_front[np.argsort(sorted_front[:, 0])]\n        crowding = 0.0\n        for m in range(1, len(sorted_front)-1):\n            crowding += abs(sorted_front[m+1, 0] - sorted_front[m-1, 0]) / (sorted_front[-1, 0] - sorted_front[0, 0] + 1e-10)\n        sorted_front = sorted_front[np.argsort(sorted_front[:, 1])]\n        for m in range(1, len(sorted_front)-1):\n            crowding += abs(sorted_front[m+1, 1] - sorted_front[m-1, 1]) / (sorted_front[-1, 1] - sorted_front[0, 1] + 1e-10)\n        crowding_distances[i] = crowding\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply segment reversal and scaling\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse and scale\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Reverse the segment\n        segment = segment[::-1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply scaling transformation\n        scale1 = random.uniform(0.8, 1.2)\n        scale2 = random.uniform(0.8, 1.2)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Scale in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            instance[node_idx, :2] = np.array([x1 * scale1, y1 * scale1]) + centroid1\n\n            # Scale in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2:] = np.array([x2 * scale2, y2 * scale2]) + centroid2\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{A novel local search heuristic that combines a Pareto-frontier guided selection with a multi-segment perturbation operator, dynamically balancing objective improvements through a two-phase evaluation framework while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution from Pareto frontier\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    selected_solution, _ = random.choice(pareto_front)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-segment perturbation\n    if n > 4:\n        # Divide into 3 segments\n        split1 = random.randint(1, n-3)\n        split2 = random.randint(split1+1, n-2)\n\n        segments = [\n            new_solution[:split1],\n            new_solution[split1:split2],\n            new_solution[split2:]\n        ]\n\n        # Randomly permute segments\n        random.shuffle(segments)\n\n        # Reconstruct with possible reversals\n        new_solution = np.concatenate(segments)\n        for seg in segments:\n            if random.random() < 0.3:\n                seg_start = np.where(new_solution == seg[0])[0][0]\n                seg_end = seg_start + len(seg) - 1\n                new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Step 3: Probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        # Create a list of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        # Find duplicate nodes\n        duplicates = [item for item, count in Counter(new_solution).items() if count > 1]\n\n        for dup in duplicates:\n            if missing:\n                # Replace duplicate with missing node\n                idx = np.where(new_solution == dup)[0][0]\n                new_solution[idx] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8262180818654421,
            1.4873749017715454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution from Pareto frontier\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    selected_solution, _ = random.choice(pareto_front)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-segment perturbation\n    if n > 4:\n        # Divide into 3 segments\n        split1 = random.randint(1, n-3)\n        split2 = random.randint(split1+1, n-2)\n\n        segments = [\n            new_solution[:split1],\n            new_solution[split1:split2],\n            new_solution[split2:]\n        ]\n\n        # Randomly permute segments\n        random.shuffle(segments)\n\n        # Reconstruct with possible reversals\n        new_solution = np.concatenate(segments)\n        for seg in segments:\n            if random.random() < 0.3:\n                seg_start = np.where(new_solution == seg[0])[0][0]\n                seg_end = seg_start + len(seg) - 1\n                new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Step 3: Probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        # Create a list of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        # Find duplicate nodes\n        duplicates = [item for item, count in Counter(new_solution).items() if count > 1]\n\n        for dup in duplicates:\n            if missing:\n                # Replace duplicate with missing node\n                idx = np.where(new_solution == dup)[0][0]\n                new_solution[idx] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This novel heuristic combines a non-dominated sorting based selection with an adaptive segment reversal and node insertion operation, leveraging multi-objective spatial analysis to guide the search towards diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    fronts = []\n    n_points = len(objectives)\n    n_dominated = np.zeros(n_points)\n    dominated_by = [[] for _ in range(n_points)]\n\n    for i in range(n_points):\n        for j in range(n_points):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and \\\n                   (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                    dominated_by[j].append(i)\n                elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and \\\n                     (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                    n_dominated[i] += 1\n\n    current_front = [i for i in range(n_points) if n_dominated[i] == 0]\n    fronts.append(current_front)\n\n    while current_front:\n        next_front = []\n        for i in current_front:\n            for j in dominated_by[i]:\n                n_dominated[j] -= 1\n                if n_dominated[j] == 0:\n                    next_front.append(j)\n        current_front = next_front\n        fronts.append(current_front)\n\n    selected_idx = random.choice(fronts[0]) if fronts[0] else random.randint(0, len(solutions)-1)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply adaptive segment reversal and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion operation\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [node], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8601406705293365,
            2.1411973237991333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    fronts = []\n    n_points = len(objectives)\n    n_dominated = np.zeros(n_points)\n    dominated_by = [[] for _ in range(n_points)]\n\n    for i in range(n_points):\n        for j in range(n_points):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and \\\n                   (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                    dominated_by[j].append(i)\n                elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and \\\n                     (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                    n_dominated[i] += 1\n\n    current_front = [i for i in range(n_points) if n_dominated[i] == 0]\n    fronts.append(current_front)\n\n    while current_front:\n        next_front = []\n        for i in current_front:\n            for j in dominated_by[i]:\n                n_dominated[j] -= 1\n                if n_dominated[j] == 0:\n                    next_front.append(j)\n        current_front = next_front\n        fronts.append(current_front)\n\n    selected_idx = random.choice(fronts[0]) if fronts[0] else random.randint(0, len(solutions)-1)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply adaptive segment reversal and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node insertion operation\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [node], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This novel algorithm combines objective-based solution selection with a hybrid of geometric transformation and adaptive segment inversion, dynamically balancing the exploration of objective trade-offs by leveraging distance metrics and geometric properties to guide the search toward promising regions while preserving solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on geometric diversity and objective balance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate geometric diversity\n    centroids = np.array([instance[sol].mean(axis=0) for sol in solutions])\n    diversity = np.linalg.norm(centroids[:, :2] - centroids[:, 2:], axis=1)\n\n    # Calculate objective balance\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1]) / (objectives[:, 0] + objectives[:, 1] + 1e-6)\n\n    # Combine metrics for selection\n    selection_metric = diversity * obj_balance\n    selected_idx = np.argmax(selection_metric)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment for transformation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate transformation parameters\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        alpha = obj1 / total\n        beta = obj2 / total\n\n        # Apply adaptive geometric transformation\n        for node_idx in segment:\n            # Rotate coordinates in each space\n            x1, y1, x2, y2 = instance[node_idx]\n            # Rotation angle based on objective weights\n            angle1 = alpha * np.pi/4\n            angle2 = beta * np.pi/4\n            # Apply rotation\n            new_x1 = x1 * np.cos(angle1) - y1 * np.sin(angle1)\n            new_y1 = x1 * np.sin(angle1) + y1 * np.cos(angle1)\n            new_x2 = x2 * np.cos(angle2) - y2 * np.sin(angle2)\n            new_y2 = x2 * np.sin(angle2) + y2 * np.cos(angle2)\n            # Update instance\n            instance[node_idx] = [new_x1, new_y1, new_x2, new_y2]\n\n        # Apply segment inversion with probability based on objective balance\n        if random.random() < obj_balance[selected_idx]:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8372665833776631,
            6.572005927562714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on geometric diversity and objective balance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate geometric diversity\n    centroids = np.array([instance[sol].mean(axis=0) for sol in solutions])\n    diversity = np.linalg.norm(centroids[:, :2] - centroids[:, 2:], axis=1)\n\n    # Calculate objective balance\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1]) / (objectives[:, 0] + objectives[:, 1] + 1e-6)\n\n    # Combine metrics for selection\n    selection_metric = diversity * obj_balance\n    selected_idx = np.argmax(selection_metric)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment for transformation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate transformation parameters\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        alpha = obj1 / total\n        beta = obj2 / total\n\n        # Apply adaptive geometric transformation\n        for node_idx in segment:\n            # Rotate coordinates in each space\n            x1, y1, x2, y2 = instance[node_idx]\n            # Rotation angle based on objective weights\n            angle1 = alpha * np.pi/4\n            angle2 = beta * np.pi/4\n            # Apply rotation\n            new_x1 = x1 * np.cos(angle1) - y1 * np.sin(angle1)\n            new_y1 = x1 * np.sin(angle1) + y1 * np.cos(angle1)\n            new_x2 = x2 * np.cos(angle2) - y2 * np.sin(angle2)\n            new_y2 = x2 * np.sin(angle2) + y2 * np.cos(angle2)\n            # Update instance\n            instance[node_idx] = [new_x1, new_y1, new_x2, new_y2]\n\n        # Apply segment inversion with probability based on objective balance\n        if random.random() < obj_balance[selected_idx]:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This novel algorithm employs a dominance-based selection of solutions from the archive, combined with a hybrid of edge-recombination and segment-insertion operations, dynamically adjusting the search focus to under-explored regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective distances\n    objectives = [obj for _, obj in archive]\n    selected_idx = 0\n    min_dominance = float('inf')\n\n    for i in range(len(objectives)):\n        dominance = 0\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            if (objectives[i][0] >= objectives[j][0] and objectives[i][1] > objectives[j][1]) or \\\n               (objectives[i][0] > objectives[j][0] and objectives[i][1] >= objectives[j][1]):\n                dominance += 1\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-recombination operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Find common edges in other solutions\n        common_edges = set()\n        for sol, _ in archive:\n            for k in range(n):\n                edge = (sol[k], sol[(k+1)%n])\n                if edge in common_edges:\n                    common_edges.remove(edge)\n                else:\n                    common_edges.add(edge)\n\n        # Insert common edges if possible\n        if common_edges:\n            edge = random.choice(list(common_edges))\n            pos = new_solution.tolist().index(edge[0])\n            next_pos = (pos + 1) % n\n            if new_solution[next_pos] != edge[1]:\n                new_solution[pos], new_solution[next_pos] = edge[0], edge[1]\n\n        # Segment-insertion operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6291974456988816,
            2.5395997762680054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective distances\n    objectives = [obj for _, obj in archive]\n    selected_idx = 0\n    min_dominance = float('inf')\n\n    for i in range(len(objectives)):\n        dominance = 0\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            if (objectives[i][0] >= objectives[j][0] and objectives[i][1] > objectives[j][1]) or \\\n               (objectives[i][0] > objectives[j][0] and objectives[i][1] >= objectives[j][1]):\n                dominance += 1\n        if dominance < min_dominance:\n            min_dominance = dominance\n            selected_idx = i\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-recombination operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Find common edges in other solutions\n        common_edges = set()\n        for sol, _ in archive:\n            for k in range(n):\n                edge = (sol[k], sol[(k+1)%n])\n                if edge in common_edges:\n                    common_edges.remove(edge)\n                else:\n                    common_edges.add(edge)\n\n        # Insert common edges if possible\n        if common_edges:\n            edge = random.choice(list(common_edges))\n            pos = new_solution.tolist().index(edge[0])\n            next_pos = (pos + 1) % n\n            if new_solution[next_pos] != edge[1]:\n                new_solution[pos], new_solution[next_pos] = edge[0], edge[1]\n\n        # Segment-insertion operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{A novel local search heuristic that combines adaptive objective weighting with a hybrid of segment rotation and node insertion operations, dynamically balancing exploration and exploitation through a multi-stage validation process to ensure feasibility and solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Adaptive objective weighting\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = 1 / (1 + normalized_obj)\n    weighted_scores = np.sum(weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8155981591314498,
            2.218876540660858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Adaptive objective weighting\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = 1 / (1 + normalized_obj)\n    weighted_scores = np.sum(weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This heuristic combines a novel objective-space guided selection with a multi-segment relocation and inversion operator that dynamically adapts to the relative importance of each objective, while maintaining feasibility through a constrained neighborhood exploration strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Objective-space guided selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_obj, axis=0)\n    weights = diversity_scores / diversity_scores.sum()\n\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Multi-segment relocation and inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select multiple non-overlapping segments\n        segment_lengths = random.sample(range(1, min(4, n//3)), random.randint(1, 3))\n        points = sorted(random.sample(range(n), len(segment_lengths)*2))\n        segments = [(points[i], points[i+1]) for i in range(0, len(points), 2)]\n\n        # Process segments in random order\n        random.shuffle(segments)\n        for (start, end) in segments:\n            if end - start < 1:\n                continue\n\n            # Decide between relocation or inversion\n            if random.random() < 0.7:\n                # Relocation\n                segment = new_solution[start:end+1]\n                new_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[end+1:],\n                    segment\n                ])\n                # Insert at new position\n                insert_pos = random.randint(0, n - (end-start+1))\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n            else:\n                # Inversion\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair by ensuring all nodes are present\n        missing = set(range(n)) - set(new_solution)\n        extra = [node for node in new_solution if list(new_solution).count(node) > 1]\n        for m, e in zip(missing, extra):\n            new_solution[np.where(new_solution == e)[0][0]] = m\n\n    return new_solution\n\n",
        "score": [
            -0.9538674151371319,
            0.9475333094596863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Objective-space guided selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_obj, axis=0)\n    weights = diversity_scores / diversity_scores.sum()\n\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Multi-segment relocation and inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select multiple non-overlapping segments\n        segment_lengths = random.sample(range(1, min(4, n//3)), random.randint(1, 3))\n        points = sorted(random.sample(range(n), len(segment_lengths)*2))\n        segments = [(points[i], points[i+1]) for i in range(0, len(points), 2)]\n\n        # Process segments in random order\n        random.shuffle(segments)\n        for (start, end) in segments:\n            if end - start < 1:\n                continue\n\n            # Decide between relocation or inversion\n            if random.random() < 0.7:\n                # Relocation\n                segment = new_solution[start:end+1]\n                new_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[end+1:],\n                    segment\n                ])\n                # Insert at new position\n                insert_pos = random.randint(0, n - (end-start+1))\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n            else:\n                # Inversion\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair by ensuring all nodes are present\n        missing = set(range(n)) - set(new_solution)\n        extra = [node for node in new_solution if list(new_solution).count(node) > 1]\n        for m, e in zip(missing, extra):\n            new_solution[np.where(new_solution == e)[0][0]] = m\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{A novel local search heuristic selects solutions from the archive based on their Pareto dominance and objective diversity, then applies a hybrid of edge insertion and segment rotation to explore the solution space while ensuring feasibility through a feasibility-preserving repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    diversity_scores = np.linalg.norm(objectives[pareto_front] - objectives[pareto_front].mean(axis=0), axis=1)\n    selected_idx = pareto_front[np.argmax(diversity_scores)]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            node = new_solution[remove_pos]\n            new_solution = np.delete(new_solution, remove_pos)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5396102241692864,
            3.7768418192863464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    diversity_scores = np.linalg.norm(objectives[pareto_front] - objectives[pareto_front].mean(axis=0), axis=1)\n    selected_idx = pareto_front[np.argmax(diversity_scores)]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            node = new_solution[remove_pos]\n            new_solution = np.delete(new_solution, remove_pos)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{A novel local search heuristic that combines a dominance-based selection with a hybrid of segment-shuffling and path-contraction operations, dynamically balancing exploration and exploitation through adaptive neighborhood sizes while ensuring feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance-based approach\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Find non-dominated solutions\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply hybrid local search\n    if n > 4:\n        # Segment-shuffling operation\n        segment_size = random.randint(2, max(2, n//4))\n        start = random.randint(0, n-segment_size)\n        end = start + segment_size\n        segment = new_solution[start:end]\n        random.shuffle(segment)\n        new_solution[start:end] = segment\n\n        # Path-contraction operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        if b - a > 2:\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    # Step 3: Probabilistic validation\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.3:\n            # Apply random insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n        else:\n            # Apply random swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9030108694852181,
            2.8920605182647705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance-based approach\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Find non-dominated solutions\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply hybrid local search\n    if n > 4:\n        # Segment-shuffling operation\n        segment_size = random.randint(2, max(2, n//4))\n        start = random.randint(0, n-segment_size)\n        end = start + segment_size\n        segment = new_solution[start:end]\n        random.shuffle(segment)\n        new_solution[start:end] = segment\n\n        # Path-contraction operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        if b - a > 2:\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    # Step 3: Probabilistic validation\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.3:\n            # Apply random insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n        else:\n            # Apply random swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a Pareto-dominance based selection with a dynamic segment insertion and edge removal operation to balance exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge removal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Remove a random edge and insert it at a different position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while j == i or j == (i+1) % n:\n            j = random.randint(0, n-2)\n\n        # Remove edge (i, i+1)\n        removed_node = new_solution[i+1]\n\n        # Insert it after j\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [removed_node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator combining segment reversal with adaptive node swapping, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance\n    for i in range(2):  # For both objectives\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive node swapping based on distance\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate distance in both spaces\n            dist1 = distance_matrix_1[node_i, node_j]\n            dist2 = distance_matrix_2[node_i, node_j]\n\n            # Swap if it improves both distances\n            if dist1 < distance_matrix_1[new_solution[(i-1)%n], node_i] + distance_matrix_1[node_j, new_solution[(i+1)%n]] and \\\n               dist2 < distance_matrix_2[new_solution[(i-1)%n], node_i] + distance_matrix_2[node_j, new_solution[(i+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5903750821205217,
            2.2774155139923096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance\n    for i in range(2):  # For both objectives\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive node swapping based on distance\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate distance in both spaces\n            dist1 = distance_matrix_1[node_i, node_j]\n            dist2 = distance_matrix_2[node_i, node_j]\n\n            # Swap if it improves both distances\n            if dist1 < distance_matrix_1[new_solution[(i-1)%n], node_i] + distance_matrix_1[node_j, new_solution[(i+1)%n]] and \\\n               dist2 < distance_matrix_2[new_solution[(i-1)%n], node_i] + distance_matrix_2[node_j, new_solution[(i+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{The new algorithm selects solutions based on their geometric diversity in both objective spaces and applies a hybrid operator that combines node permutation with adaptive coordinate transformation, guided by the relative balance between the two objectives to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest geometric diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        solution = archive[i][0]\n        coords1 = instance[solution, :2]\n        coords2 = instance[solution, 2:]\n\n        # Calculate geometric spread in both spaces\n        spread1 = np.max(np.linalg.norm(coords1 - np.mean(coords1, axis=0), axis=1))\n        spread2 = np.max(np.linalg.norm(coords2 - np.mean(coords2, axis=0), axis=1))\n\n        # Balance between objectives\n        obj1, obj2 = objectives[i]\n        balance = abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n        diversity_scores[i] = (spread1 + spread2) * (1 - balance)\n\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (permutation + adaptive transformation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive permutation\n        k = random.randint(1, min(3, n//2))\n        indices = sorted(random.sample(range(n), k))\n        new_solution[indices] = new_solution[indices][::-1]\n\n        # Select segment for transformation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate transformation parameters\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        weight = obj1 / (obj1 + obj2 + 1e-10)\n\n        # Apply adaptive transformation\n        for node_idx in segment:\n            # First space transformation\n            x1, y1 = instance[node_idx, :2]\n            instance[node_idx, 0] = x1 * (0.8 + 0.4 * weight)\n            instance[node_idx, 1] = y1 * (0.8 + 0.4 * (1 - weight))\n\n            # Second space transformation\n            x2, y2 = instance[node_idx, 2:]\n            instance[node_idx, 2] = x2 * (0.8 + 0.4 * (1 - weight))\n            instance[node_idx, 3] = y2 * (0.8 + 0.4 * weight)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.833747268913086,
            9.328830897808075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest geometric diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        solution = archive[i][0]\n        coords1 = instance[solution, :2]\n        coords2 = instance[solution, 2:]\n\n        # Calculate geometric spread in both spaces\n        spread1 = np.max(np.linalg.norm(coords1 - np.mean(coords1, axis=0), axis=1))\n        spread2 = np.max(np.linalg.norm(coords2 - np.mean(coords2, axis=0), axis=1))\n\n        # Balance between objectives\n        obj1, obj2 = objectives[i]\n        balance = abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n        diversity_scores[i] = (spread1 + spread2) * (1 - balance)\n\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (permutation + adaptive transformation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive permutation\n        k = random.randint(1, min(3, n//2))\n        indices = sorted(random.sample(range(n), k))\n        new_solution[indices] = new_solution[indices][::-1]\n\n        # Select segment for transformation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate transformation parameters\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        weight = obj1 / (obj1 + obj2 + 1e-10)\n\n        # Apply adaptive transformation\n        for node_idx in segment:\n            # First space transformation\n            x1, y1 = instance[node_idx, :2]\n            instance[node_idx, 0] = x1 * (0.8 + 0.4 * weight)\n            instance[node_idx, 1] = y1 * (0.8 + 0.4 * (1 - weight))\n\n            # Second space transformation\n            x2, y2 = instance[node_idx, 2:]\n            instance[node_idx, 2] = x2 * (0.8 + 0.4 * (1 - weight))\n            instance[node_idx, 3] = y2 * (0.8 + 0.4 * weight)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominated solution selection with a dynamic segment merging and edge expansion operation, guided by an adaptive objective improvement criterion to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a Pareto-dominated solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        selected_solution = archive[random.randint(0, len(archive)-1)][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated).copy()\n\n    # Step 2: Apply dynamic segment merging and edge expansion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments and merge them\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n        # Expand a random edge by inserting a new node\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j or abs(i - j) == 1:\n            j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, max(i, j), new_solution[k])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.945648229722599,
            1.0656241178512573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a Pareto-dominated solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        is_dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        selected_solution = archive[random.randint(0, len(archive)-1)][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated).copy()\n\n    # Step 2: Apply dynamic segment merging and edge expansion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments and merge them\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n        # Expand a random edge by inserting a new node\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j or abs(i - j) == 1:\n            j = random.randint(0, n-1)\n        k = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, max(i, j), new_solution[k])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{A novel local search heuristic combines Pareto-dominance aware segment selection with a hybrid edge relinking and node insertion operator, guided by a geometric proximity metric in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto-dominance and geometric diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    # Combine dominance with geometric diversity\n    centroids = np.array([instance[sol[0], :2].mean(axis=0) for sol in archive])\n    diversity_scores = np.linalg.norm(centroids - centroids.mean(axis=0), axis=1)\n    combined_scores = dominance_counts + diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge relinking and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments\n        a1, b1 = sorted(random.sample(range(n), 2))\n        a2, b2 = sorted(random.sample(range(n), 2))\n\n        # Relink edges between segments\n        segment1 = new_solution[a1:b1+1]\n        segment2 = new_solution[a2:b2+1]\n\n        # Insert nodes from segment2 into segment1\n        if len(segment1) > 1 and len(segment2) > 1:\n            insert_pos = random.randint(1, len(segment1)-1)\n            new_segment = np.concatenate([segment1[:insert_pos], segment2, segment1[insert_pos:]])\n            new_solution[a1:b1+1] = new_segment[:min(len(new_segment), len(segment1))]\n\n        # Remove duplicate nodes (if any)\n        unique_nodes = []\n        seen = set()\n        for node in new_solution:\n            if node not in seen:\n                seen.add(node)\n                unique_nodes.append(node)\n        new_solution = np.array(unique_nodes)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        i = random.randint(0, len(new_solution)-1)\n        j = random.randint(0, len(new_solution)-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7732394566788494,
            2.5415377616882324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto-dominance and geometric diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    # Combine dominance with geometric diversity\n    centroids = np.array([instance[sol[0], :2].mean(axis=0) for sol in archive])\n    diversity_scores = np.linalg.norm(centroids - centroids.mean(axis=0), axis=1)\n    combined_scores = dominance_counts + diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid edge relinking and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments\n        a1, b1 = sorted(random.sample(range(n), 2))\n        a2, b2 = sorted(random.sample(range(n), 2))\n\n        # Relink edges between segments\n        segment1 = new_solution[a1:b1+1]\n        segment2 = new_solution[a2:b2+1]\n\n        # Insert nodes from segment2 into segment1\n        if len(segment1) > 1 and len(segment2) > 1:\n            insert_pos = random.randint(1, len(segment1)-1)\n            new_segment = np.concatenate([segment1[:insert_pos], segment2, segment1[insert_pos:]])\n            new_solution[a1:b1+1] = new_segment[:min(len(new_segment), len(segment1))]\n\n        # Remove duplicate nodes (if any)\n        unique_nodes = []\n        seen = set()\n        for node in new_solution:\n            if node not in seen:\n                seen.add(node)\n                unique_nodes.append(node)\n        new_solution = np.array(unique_nodes)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        i = random.randint(0, len(new_solution)-1)\n        j = random.randint(0, len(new_solution)-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{A novel local search heuristic that combines crowding-distance-based selection with a dynamic trade-off-aware segment exchange and node relocation strategy to explore the Pareto front efficiently while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(sorted_objectives))\n        distances[1:-1] = np.sum(np.abs(sorted_objectives[2:] - sorted_objectives[:-2]), axis=1)\n        selected_idx = sorted_indices[np.argmax(distances)]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic trade-off-aware local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic trade-off segment exchange\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n\n        # Calculate trade-off factor based on current objectives\n        obj1, obj2 = archive[selected_idx][1]\n        tradeoff = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n        # Apply segment with probability based on trade-off\n        if random.random() < tradeoff:\n            new_solution[a:b+1] = segment\n\n        # Node relocation with trade-off consideration\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_1[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_2[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n        # Accept move if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -1.002569312569761,
            1.577445924282074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(sorted_objectives))\n        distances[1:-1] = np.sum(np.abs(sorted_objectives[2:] - sorted_objectives[:-2]), axis=1)\n        selected_idx = sorted_indices[np.argmax(distances)]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic trade-off-aware local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic trade-off segment exchange\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n\n        # Calculate trade-off factor based on current objectives\n        obj1, obj2 = archive[selected_idx][1]\n        tradeoff = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n        # Apply segment with probability based on trade-off\n        if random.random() < tradeoff:\n            new_solution[a:b+1] = segment\n\n        # Node relocation with trade-off consideration\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_1[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_2[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n        # Accept move if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This novel local search heuristic combines a Pareto-dominance guided selection of solutions with a hybrid of adaptive segment rotation and node transposition operations, dynamically balancing exploration of the objective space with exploitation of promising regions while maintaining feasibility through a multi-phase validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto dominance and objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Find non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                is_dominated[i] = True\n                break\n\n    non_dominated = [i for i in range(len(archive)) if not is_dominated[i]]\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        # If no non-dominated solutions, select based on objective diversity\n        selected_idx = np.argmax(np.var(objectives, axis=0))\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while abs(l - k) < 2:\n            l = random.randint(1, n-2)\n        if k > l:\n            k, l = l, k\n        segment = new_solution[k:l]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[k:l] = rotated_segment\n\n        # Node transposition with objective-aware selection\n        obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        if obj1_cost > obj2_cost:\n            # Prefer transpositions that improve the weaker objective\n            candidates = [(i, j) for i in range(n) for j in range(i+1, n)\n                         if (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) <\n                            (distance_matrix_1[new_solution[i], new_solution[j]] +\n                             distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])]\n        else:\n            candidates = [(i, j) for i in range(n) for j in range(i+1, n)\n                         if (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) <\n                            (distance_matrix_2[new_solution[i], new_solution[j]] +\n                             distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])]\n\n        if candidates:\n            i, j = random.choice(candidates)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Multi-phase validation\n    if len(np.unique(new_solution)) != n:\n        # Phase 1: Random segment rotation\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n        segment = new_solution[k:l+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[k:l+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != n:\n        # Phase 2: Random node transposition\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7989453042030413,
            8.991217315196991
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto dominance and objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Find non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                is_dominated[i] = True\n                break\n\n    non_dominated = [i for i in range(len(archive)) if not is_dominated[i]]\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        # If no non-dominated solutions, select based on objective diversity\n        selected_idx = np.argmax(np.var(objectives, axis=0))\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while abs(l - k) < 2:\n            l = random.randint(1, n-2)\n        if k > l:\n            k, l = l, k\n        segment = new_solution[k:l]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[k:l] = rotated_segment\n\n        # Node transposition with objective-aware selection\n        obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        if obj1_cost > obj2_cost:\n            # Prefer transpositions that improve the weaker objective\n            candidates = [(i, j) for i in range(n) for j in range(i+1, n)\n                         if (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) <\n                            (distance_matrix_1[new_solution[i], new_solution[j]] +\n                             distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])]\n        else:\n            candidates = [(i, j) for i in range(n) for j in range(i+1, n)\n                         if (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) <\n                            (distance_matrix_2[new_solution[i], new_solution[j]] +\n                             distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])]\n\n        if candidates:\n            i, j = random.choice(candidates)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Multi-phase validation\n    if len(np.unique(new_solution)) != n:\n        # Phase 1: Random segment rotation\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k > l:\n            k, l = l, k\n        segment = new_solution[k:l+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[k:l+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != n:\n        # Phase 2: Random node transposition\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{A new local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines segment reversal with adaptive node insertion, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(objectives.shape[1]):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Adaptive node insertion based on geometric properties\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            x1, y1 = instance[node_idx, :2]\n            x2, y2 = instance[node_idx, 2:]\n\n            # Calculate distances to neighbors in both spaces\n            neighbors = [new_solution[(a+i-1)%n], new_solution[(a+i+1)%n]]\n            dist1 = sum(distance_matrix_1[node_idx, neighbor] for neighbor in neighbors)\n            dist2 = sum(distance_matrix_2[node_idx, neighbor] for neighbor in neighbors)\n\n            # Decide insertion position based on combined distance\n            if dist1 < dist2:\n                # Insert based on first space geometry\n                min_dist = float('inf')\n                best_pos = a+i\n                for pos in range(a, b+1):\n                    if pos != a+i:\n                        d1 = distance_matrix_1[new_solution[pos-1], node_idx] + distance_matrix_1[node_idx, new_solution[pos]]\n                        if d1 < min_dist:\n                            min_dist = d1\n                            best_pos = pos\n                if best_pos != a+i:\n                    new_solution = np.insert(new_solution, best_pos, node_idx)\n                    new_solution = np.delete(new_solution, a+i + (1 if best_pos > a+i else 0))\n            else:\n                # Insert based on second space geometry\n                min_dist = float('inf')\n                best_pos = a+i\n                for pos in range(a, b+1):\n                    if pos != a+i:\n                        d2 = distance_matrix_2[new_solution[pos-1], node_idx] + distance_matrix_2[node_idx, new_solution[pos]]\n                        if d2 < min_dist:\n                            min_dist = d2\n                            best_pos = pos\n                if best_pos != a+i:\n                    new_solution = np.insert(new_solution, best_pos, node_idx)\n                    new_solution = np.delete(new_solution, a+i + (1 if best_pos > a+i else 0))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8716030261158563,
            5.550345599651337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(objectives.shape[1]):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Adaptive node insertion based on geometric properties\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            x1, y1 = instance[node_idx, :2]\n            x2, y2 = instance[node_idx, 2:]\n\n            # Calculate distances to neighbors in both spaces\n            neighbors = [new_solution[(a+i-1)%n], new_solution[(a+i+1)%n]]\n            dist1 = sum(distance_matrix_1[node_idx, neighbor] for neighbor in neighbors)\n            dist2 = sum(distance_matrix_2[node_idx, neighbor] for neighbor in neighbors)\n\n            # Decide insertion position based on combined distance\n            if dist1 < dist2:\n                # Insert based on first space geometry\n                min_dist = float('inf')\n                best_pos = a+i\n                for pos in range(a, b+1):\n                    if pos != a+i:\n                        d1 = distance_matrix_1[new_solution[pos-1], node_idx] + distance_matrix_1[node_idx, new_solution[pos]]\n                        if d1 < min_dist:\n                            min_dist = d1\n                            best_pos = pos\n                if best_pos != a+i:\n                    new_solution = np.insert(new_solution, best_pos, node_idx)\n                    new_solution = np.delete(new_solution, a+i + (1 if best_pos > a+i else 0))\n            else:\n                # Insert based on second space geometry\n                min_dist = float('inf')\n                best_pos = a+i\n                for pos in range(a, b+1):\n                    if pos != a+i:\n                        d2 = distance_matrix_2[new_solution[pos-1], node_idx] + distance_matrix_2[node_idx, new_solution[pos]]\n                        if d2 < min_dist:\n                            min_dist = d2\n                            best_pos = pos\n                if best_pos != a+i:\n                    new_solution = np.insert(new_solution, best_pos, node_idx)\n                    new_solution = np.delete(new_solution, a+i + (1 if best_pos > a+i else 0))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm employs a hybrid selection strategy that combines dominance-based pruning with a novel \"multi-space edge exchange\" operator, which intelligently swaps segments between two randomly selected solutions from the archive while preserving feasibility and exploiting spatial locality in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select two random solutions from the archive\n    sol1_idx, sol2_idx = random.sample(range(len(archive)), 2)\n    sol1, obj1 = archive[sol1_idx]\n    sol2, obj2 = archive[sol2_idx]\n\n    # Step 2: Identify promising segments in both solutions\n    def find_promising_segment(solution, distance_matrix):\n        n = len(solution)\n        best_segment = None\n        best_cost = float('inf')\n\n        for i in range(n):\n            for j in range(i+1, min(i+10, n)):\n                segment = solution[i:j+1]\n                cost = sum(distance_matrix[segment[k-1], segment[k]] for k in range(1, len(segment))) + distance_matrix[segment[-1], segment[0]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_segment = (i, j)\n\n        return best_segment if best_segment else (0, 1)\n\n    seg1 = find_promising_segment(sol1, distance_matrix_1)\n    seg2 = find_promising_segment(sol2, distance_matrix_2)\n\n    # Step 3: Create neighbor by exchanging segments between solutions\n    new_solution = sol1.copy()\n    i1, j1 = seg1\n    i2, j2 = seg2\n\n    segment1 = sol1[i1:j1+1]\n    segment2 = sol2[i2:j2+1]\n\n    # Exchange segments while maintaining feasibility\n    new_solution = np.concatenate([\n        new_solution[:i1],\n        segment2,\n        new_solution[j1+1:i2],\n        segment1,\n        new_solution[j2+1:]\n    ])\n\n    # Ensure feasibility by fixing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for node in duplicates:\n        # Find missing nodes and swap\n        missing = set(range(len(instance))) - set(new_solution)\n        if missing:\n            idx = np.where(new_solution == node)[0][1]\n            new_solution[idx] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.7440616320081535,
            11.804710626602173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select two random solutions from the archive\n    sol1_idx, sol2_idx = random.sample(range(len(archive)), 2)\n    sol1, obj1 = archive[sol1_idx]\n    sol2, obj2 = archive[sol2_idx]\n\n    # Step 2: Identify promising segments in both solutions\n    def find_promising_segment(solution, distance_matrix):\n        n = len(solution)\n        best_segment = None\n        best_cost = float('inf')\n\n        for i in range(n):\n            for j in range(i+1, min(i+10, n)):\n                segment = solution[i:j+1]\n                cost = sum(distance_matrix[segment[k-1], segment[k]] for k in range(1, len(segment))) + distance_matrix[segment[-1], segment[0]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_segment = (i, j)\n\n        return best_segment if best_segment else (0, 1)\n\n    seg1 = find_promising_segment(sol1, distance_matrix_1)\n    seg2 = find_promising_segment(sol2, distance_matrix_2)\n\n    # Step 3: Create neighbor by exchanging segments between solutions\n    new_solution = sol1.copy()\n    i1, j1 = seg1\n    i2, j2 = seg2\n\n    segment1 = sol1[i1:j1+1]\n    segment2 = sol2[i2:j2+1]\n\n    # Exchange segments while maintaining feasibility\n    new_solution = np.concatenate([\n        new_solution[:i1],\n        segment2,\n        new_solution[j1+1:i2],\n        segment1,\n        new_solution[j2+1:]\n    ])\n\n    # Ensure feasibility by fixing duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for node in duplicates:\n        # Find missing nodes and swap\n        missing = set(range(len(instance))) - set(new_solution)\n        if missing:\n            idx = np.where(new_solution == node)[0][1]\n            new_solution[idx] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{A novel local search heuristic that combines a dominance-guided selection of solutions with a hybrid of node-swapping and segment-shuffling operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    max_dominance_idx = np.argmax(dominance_counts)\n    selected_solution = archive[max_dominance_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-shuffling operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8262111068002843,
            2.713135778903961
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    max_dominance_idx = np.argmax(dominance_counts)\n    selected_solution = archive[max_dominance_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-shuffling operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This novel local search heuristic dynamically selects solutions from the archive based on a weighted combination of objectives, then applies a hybrid of segment inversion and node relocation operations with adaptive segment sizes and relocation probabilities to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off with adaptive weights\n    norm_factors = np.array([max(x[1][0] for x in archive), max(x[1][1] for x in archive)])\n    weights = np.random.dirichlet([0.7, 0.3])  # Bias towards first objective\n    selected_solution = min(archive, key=lambda x: weights[0] * (x[1][0] / norm_factors[0]) + weights[1] * (x[1][1] / norm_factors[1]))[0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive segment sizes\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution = np.concatenate([new_solution[:start], segment[::-1], new_solution[start+segment_size:]])\n\n        # Adaptive node relocation with probability\n        if random.random() < 0.6:  # Higher relocation probability\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while i == j:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8057510862923963,
            2.015250027179718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off with adaptive weights\n    norm_factors = np.array([max(x[1][0] for x in archive), max(x[1][1] for x in archive)])\n    weights = np.random.dirichlet([0.7, 0.3])  # Bias towards first objective\n    selected_solution = min(archive, key=lambda x: weights[0] * (x[1][0] / norm_factors[0]) + weights[1] * (x[1][1] / norm_factors[1]))[0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive segment sizes\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution = np.concatenate([new_solution[:start], segment[::-1], new_solution[start+segment_size:]])\n\n        # Adaptive node relocation with probability\n        if random.random() < 0.6:  # Higher relocation probability\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while i == j:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{A novel local search heuristic that combines Pareto-ranking selection with a dynamic segment insertion and edge swapping operation, guided by a multi-objective improvement criterion to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto ranking\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, slice(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Swap two random edges\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random 2-opt if invalid\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8597676854637659,
            2.6520610451698303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto ranking\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, slice(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Swap two random edges\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random 2-opt if invalid\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This novel algorithm combines an objective-specific dominance-based selection with a multi-phase local search that dynamically adapts between node swapping, segment rotation, and objective-aware inversion operations, using spatial proximity in both objective spaces to guide the search toward diverse high-quality regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on objective dominance\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    candidates = [i for i, obj in enumerate(objectives) if obj[0] <= min_obj1 * 1.1 and obj[1] <= min_obj2 * 1.1]\n    if not candidates:\n        candidates = range(len(archive))\n    selected_idx = random.choice(candidates)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply multi-phase local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Phase 1: Node swapping based on spatial proximity\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate spatial distances in both objective spaces\n        dist1 = np.linalg.norm(instance[node_i, :2] - instance[node_j, 2:])\n        dist2 = np.linalg.norm(instance[node_i, 2:] - instance[node_j, :2])\n\n        if dist1 < dist2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Phase 2: Segment rotation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n        # Phase 3: Objective-aware inversion\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if obj1 > obj2:\n            c = random.randint(0, n-1)\n            d = random.randint(0, n-1)\n            if c > d:\n                c, d = d, c\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8815753261714683,
            2.3226781487464905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on objective dominance\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    candidates = [i for i, obj in enumerate(objectives) if obj[0] <= min_obj1 * 1.1 and obj[1] <= min_obj2 * 1.1]\n    if not candidates:\n        candidates = range(len(archive))\n    selected_idx = random.choice(candidates)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply multi-phase local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Phase 1: Node swapping based on spatial proximity\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate spatial distances in both objective spaces\n        dist1 = np.linalg.norm(instance[node_i, :2] - instance[node_j, 2:])\n        dist2 = np.linalg.norm(instance[node_i, 2:] - instance[node_j, :2])\n\n        if dist1 < dist2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Phase 2: Segment rotation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n        # Phase 3: Objective-aware inversion\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if obj1 > obj2:\n            c = random.randint(0, n-1)\n            d = random.randint(0, n-1)\n            if c > d:\n                c, d = d, c\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This novel algorithm combines a multi-objective dominance-based selection of solutions from the archive with a hybrid of edge insertion and node displacement operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front_indices = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front_indices.append(i)\n\n    if not pareto_front_indices:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        # Select from Pareto front with preference for more diverse solutions\n        front_objectives = objectives[pareto_front_indices]\n        diversity_scores = np.linalg.norm(front_objectives - front_objectives.mean(axis=0), axis=1)\n        selected_front_idx = np.argmax(diversity_scores)\n        selected_idx = pareto_front_indices[selected_front_idx]\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with edge insertion and node displacement\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge insertion operation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Remove a node between i and j\n            remove_pos = random.randint(i+1, j-1)\n            removed_node = new_solution[remove_pos]\n            new_solution = np.delete(new_solution, remove_pos)\n\n            # Insert the removed node at a different position\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n        # Node displacement operation\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            # Move a segment of nodes to a different position\n            segment = new_solution[a:b+1]\n            new_solution = np.delete(new_solution, slice(a, b+1))\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6862579361477146,
            3.2908945083618164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front_indices = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front_indices.append(i)\n\n    if not pareto_front_indices:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        # Select from Pareto front with preference for more diverse solutions\n        front_objectives = objectives[pareto_front_indices]\n        diversity_scores = np.linalg.norm(front_objectives - front_objectives.mean(axis=0), axis=1)\n        selected_front_idx = np.argmax(diversity_scores)\n        selected_idx = pareto_front_indices[selected_front_idx]\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search with edge insertion and node displacement\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge insertion operation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Remove a node between i and j\n            remove_pos = random.randint(i+1, j-1)\n            removed_node = new_solution[remove_pos]\n            new_solution = np.delete(new_solution, remove_pos)\n\n            # Insert the removed node at a different position\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n        # Node displacement operation\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            # Move a segment of nodes to a different position\n            segment = new_solution[a:b+1]\n            new_solution = np.delete(new_solution, slice(a, b+1))\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a dynamic node insertion and segment rotation operation, guided by a hypervolume improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]) and (objectives[i, 0] > objectives[j, 0] or objectives[i, 1] > objectives[j, 1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front[i] = True\n\n    if np.any(pareto_front):\n        candidates = np.where(pareto_front)[0]\n        selected_idx = candidates[np.argmin(np.linalg.norm(objectives[candidates] - objectives.mean(axis=0), axis=1))]\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node and insert it in a new position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Rotate a segment by a random amount\n        a, b = sorted(random.sample(range(n), 2))\n        rotation = random.randint(1, b-a)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6558807745568436,
            2.047674775123596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]) and (objectives[i, 0] > objectives[j, 0] or objectives[i, 1] > objectives[j, 1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front[i] = True\n\n    if np.any(pareto_front):\n        candidates = np.where(pareto_front)[0]\n        selected_idx = candidates[np.argmin(np.linalg.norm(objectives[candidates] - objectives.mean(axis=0), axis=1))]\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node and insert it in a new position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Rotate a segment by a random amount\n        a, b = sorted(random.sample(range(n), 2))\n        rotation = random.randint(1, b-a)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{An adaptive local search heuristic that combines quality-diversity selection with a hybrid of node insertion and edge inversion operations, guided by a Pareto-dominance aware multi-objective improvement criterion to efficiently explore the solution space while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.6 + diversity_scores * 0.4  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid node insertion and edge inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly select a node to reinsert at a different position\n        insert_pos = random.randint(0, n-1)\n        node_to_insert = new_solution[insert_pos]\n        new_solution = np.delete(new_solution, insert_pos)\n        new_insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5669502500692768,
            2.4322500824928284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.6 + diversity_scores * 0.4  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid node insertion and edge inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly select a node to reinsert at a different position\n        insert_pos = random.randint(0, n-1)\n        node_to_insert = new_solution[insert_pos]\n        new_solution = np.delete(new_solution, insert_pos)\n        new_insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This novel algorithm combines a non-dominated sorting-based selection of solutions from the archive with a hybrid of node insertion and edge flipping operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on non-dominated sorting and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Non-dominated sorting\n    fronts = []\n    dominated = [0] * len(archive)\n    dominating = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominating[i].append(j)\n            elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated[i] += 1\n\n        if dominated[i] == 0:\n            fronts.append([i])\n\n    # Select from the first front\n    selected_front = fronts[0]\n    if len(selected_front) > 1:\n        # Calculate crowding distance for the first front\n        crowding_distances = [0] * len(selected_front)\n        for m in range(2):  # For each objective\n            sorted_indices = sorted(selected_front, key=lambda x: objectives[x][m])\n            crowding_distances[sorted_indices[0]] = float('inf')\n            crowding_distances[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(sorted_indices)-1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m])\n\n        max_crowding = max(crowding_distances)\n        candidates = [i for i, d in zip(selected_front, crowding_distances) if d == max_crowding]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = selected_front[0]\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge flipping operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        # Check if flipping improves both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        flipped_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        flipped_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (flipped_cost1 < current_cost1 and flipped_cost2 < current_cost2) or random.random() < 0.3:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7109754721438298,
            2.935094177722931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on non-dominated sorting and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Non-dominated sorting\n    fronts = []\n    dominated = [0] * len(archive)\n    dominating = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominating[i].append(j)\n            elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated[i] += 1\n\n        if dominated[i] == 0:\n            fronts.append([i])\n\n    # Select from the first front\n    selected_front = fronts[0]\n    if len(selected_front) > 1:\n        # Calculate crowding distance for the first front\n        crowding_distances = [0] * len(selected_front)\n        for m in range(2):  # For each objective\n            sorted_indices = sorted(selected_front, key=lambda x: objectives[x][m])\n            crowding_distances[sorted_indices[0]] = float('inf')\n            crowding_distances[sorted_indices[-1]] = float('inf')\n            for i in range(1, len(sorted_indices)-1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m])\n\n        max_crowding = max(crowding_distances)\n        candidates = [i for i, d in zip(selected_front, crowding_distances) if d == max_crowding]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = selected_front[0]\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge flipping operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        # Check if flipping improves both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        flipped_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        flipped_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (flipped_cost1 < current_cost1 and flipped_cost2 < current_cost2) or random.random() < 0.3:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{A novel local search heuristic that combines a Pareto-dominance guided selection of solutions with a dynamic node-insertion and edge-deletion operation, guided by a multi-objective improvement criterion to explore the solution space while maintaining feasibility through a constraint-aware validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on Pareto dominance\n    pareto_front = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj) and any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node-insertion and edge-deletion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        node_to_insert = new_solution[j]\n        new_solution = np.insert(new_solution, i, node_to_insert)\n\n        # Edge-deletion operation\n        if len(new_solution) > n:\n            k = random.randint(0, len(new_solution)-1)\n            new_solution = np.delete(new_solution, k)\n\n    # Step 3: Constraint-aware validation\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # Fallback to random node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.726271970690644,
            1.7389673590660095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on Pareto dominance\n    pareto_front = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj) and any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node-insertion and edge-deletion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        node_to_insert = new_solution[j]\n        new_solution = np.insert(new_solution, i, node_to_insert)\n\n        # Edge-deletion operation\n        if len(new_solution) > n:\n            k = random.randint(0, len(new_solution)-1)\n            new_solution = np.delete(new_solution, k)\n\n    # Step 3: Constraint-aware validation\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # Fallback to random node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its dominance rank and applies a hybrid local search operator that combines path reversal with adaptive coordinate transformation, guided by the relative contribution of each objective to the solution's overall quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    dominance_ranks = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] < objectives[i, 1]) or \\\n                   (objectives[j, 0] < objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                    dominated_count += 1\n        dominance_ranks[i] = dominated_count\n\n    selected_idx = np.argmin(dominance_ranks)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (path reversal + adaptive transformation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Calculate objective contributions\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        contrib1 = obj1 / total\n        contrib2 = obj2 / total\n\n        # Apply adaptive coordinate transformation\n        for node_idx in new_solution[a:b+1]:\n            # Transform first objective space coordinates\n            instance[node_idx, :2] = instance[node_idx, :2] * (1 + 0.1 * contrib1 * random.uniform(-1, 1))\n            # Transform second objective space coordinates\n            instance[node_idx, 2:] = instance[node_idx, 2:] * (1 + 0.1 * contrib2 * random.uniform(-1, 1))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.778634504448372,
            2.063369035720825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    dominance_ranks = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] < objectives[i, 1]) or \\\n                   (objectives[j, 0] < objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                    dominated_count += 1\n        dominance_ranks[i] = dominated_count\n\n    selected_idx = np.argmin(dominance_ranks)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (path reversal + adaptive transformation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Calculate objective contributions\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        contrib1 = obj1 / total\n        contrib2 = obj2 / total\n\n        # Apply adaptive coordinate transformation\n        for node_idx in new_solution[a:b+1]:\n            # Transform first objective space coordinates\n            instance[node_idx, :2] = instance[node_idx, :2] * (1 + 0.1 * contrib1 * random.uniform(-1, 1))\n            # Transform second objective space coordinates\n            instance[node_idx, 2:] = instance[node_idx, 2:] * (1 + 0.1 * contrib2 * random.uniform(-1, 1))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This novel heuristic combines a multi-objective fitness-based selection with a dynamic node permutation and spatial-aware edge insertion operation to balance exploration and exploitation, leveraging both objective spaces to guide the search towards diverse high-quality regions of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on multi-objective fitness\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    fitness_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(fitness_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node permutation and spatial-aware edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node permutation operation\n        perm_length = random.randint(2, min(4, n//2))\n        perm_indices = sorted(random.sample(range(n), perm_length))\n        permuted_segment = new_solution[perm_indices]\n        np.random.shuffle(permuted_segment)\n        new_solution[perm_indices] = permuted_segment\n\n        # Spatial-aware edge insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            coords_i = instance[node_i]\n            coords_j = instance[node_j]\n\n            # Calculate spatial proximity in both objective spaces\n            dist1 = np.linalg.norm(coords_i[:2] - coords_j[:2])\n            dist2 = np.linalg.norm(coords_i[2:] - coords_j[2:])\n            combined_dist = dist1 + dist2\n\n            # Insert node_i after node_j if spatial proximity is high\n            if combined_dist < 0.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)):\n                new_solution = np.delete(new_solution, i)\n                insert_pos = np.where(new_solution == node_j)[0][0] + 1\n                new_solution = np.insert(new_solution, insert_pos, node_i)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6700620060733837,
            2.1506630778312683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on multi-objective fitness\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    fitness_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(fitness_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node permutation and spatial-aware edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node permutation operation\n        perm_length = random.randint(2, min(4, n//2))\n        perm_indices = sorted(random.sample(range(n), perm_length))\n        permuted_segment = new_solution[perm_indices]\n        np.random.shuffle(permuted_segment)\n        new_solution[perm_indices] = permuted_segment\n\n        # Spatial-aware edge insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n            coords_i = instance[node_i]\n            coords_j = instance[node_j]\n\n            # Calculate spatial proximity in both objective spaces\n            dist1 = np.linalg.norm(coords_i[:2] - coords_j[:2])\n            dist2 = np.linalg.norm(coords_i[2:] - coords_j[2:])\n            combined_dist = dist1 + dist2\n\n            # Insert node_i after node_j if spatial proximity is high\n            if combined_dist < 0.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)):\n                new_solution = np.delete(new_solution, i)\n                insert_pos = np.where(new_solution == node_j)[0][0] + 1\n                new_solution = np.insert(new_solution, insert_pos, node_i)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{A novel local search heuristic that combines a dominance-guided selection of solutions with a hybrid of edge-insertion and path-shuffling operations, dynamically optimizing the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1] and\n                    (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1])):\n                    dominance_counts[i] += 1\n\n    min_dominance_idx = np.argmin(dominance_counts)\n    selected_solution = archive[min_dominance_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Path-shuffling operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6908433679945446,
            10.262826561927795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1] and\n                    (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1])):\n                    dominance_counts[i] += 1\n\n    min_dominance_idx = np.argmin(dominance_counts)\n    selected_solution = archive[min_dominance_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Path-shuffling operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{A novel local search heuristic combines a Pareto-frontier-aware selection of solutions with a hybrid of edge-swap and segment-reversal operations, dynamically balancing exploration and exploitation using a weighted objective trade-off to generate high-quality neighbors while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        pareto_front[i] = not dominated\n\n    if np.any(pareto_front):\n        selected_idx = np.random.choice(np.where(pareto_front)[0])\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap: randomly select two edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9249068397023958,
            2.5392611622810364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        pareto_front[i] = not dominated\n\n    if np.any(pareto_front):\n        selected_idx = np.random.choice(np.where(pareto_front)[0])\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swap: randomly select two edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{A novel local search heuristic combines a hypervolume-based selection of solutions from the archive, followed by a dynamic segment rotation and edge fusion operation, guided by a multi-objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1  # Slightly worse than worst objectives\n    volumes = np.prod(ref_point - objectives, axis=1)\n    selected_idx = np.argmax(volumes)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment rotation and edge fusion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and rotate it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        k = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Fuse two edges by merging adjacent nodes\n        i = random.randint(0, n-2)\n        new_solution[i] = new_solution[i+1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8561476988317853,
            0.7273926734924316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1  # Slightly worse than worst objectives\n    volumes = np.prod(ref_point - objectives, axis=1)\n    selected_idx = np.argmax(volumes)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment rotation and edge fusion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and rotate it\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        k = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Fuse two edges by merging adjacent nodes\n        i = random.randint(0, n-2)\n        new_solution[i] = new_solution[i+1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{A novel local search heuristic that combines adaptive segment insertion and edge reversal operations, guided by a Pareto-dominance criterion to dynamically explore the solution space while ensuring feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment insertion and edge reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Reverse a random segment\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8388280927440714,
            3.280470550060272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment insertion and edge reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Reverse a random segment\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This novel local search heuristic combines a quality-aware selection of solutions from the archive with a hybrid of edge-swapping and segment-reversal operations, guided by a dynamic Pareto-based trade-off to explore the solution space while ensuring feasibility and promoting both diversity and convergence toward the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a high-quality solution from the archive\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(objectives, axis=1))  # Select solution with minimal combined cost\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping: randomly select two non-adjacent edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if i != 0 and j != n-1 and abs(i-j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal: reverse a random segment of the tour\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7659983270314736,
            2.5449823141098022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a high-quality solution from the archive\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(objectives, axis=1))  # Select solution with minimal combined cost\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping: randomly select two non-adjacent edges and swap their nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if i != 0 and j != n-1 and abs(i-j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-reversal: reverse a random segment of the tour\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{A novel local search heuristic employs a Pareto-dominance based selection of solutions from the archive, followed by a dynamic edge insertion and segment crossover operation, guided by a multi-objective improvement criterion to efficiently explore the solution space while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge insertion and segment crossover\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and crossover with another segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n        # Insert a random node between two existing nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            insert_pos = random.randint(i+1, j-1)\n            node_to_insert = random.choice(new_solution)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6338215652983541,
            2.6310726404190063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge insertion and segment crossover\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and crossover with another segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n        # Insert a random node between two existing nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            insert_pos = random.randint(i+1, j-1)\n            node_to_insert = random.choice(new_solution)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This novel algorithm combines a non-dominated sorting-based selection of solutions from the archive with a hybrid of adaptive segment swapping and multi-objective edge insertion operations, dynamically balancing the exploration of Pareto-optimal regions by leveraging objective-specific neighborhood structures to generate high-quality solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using non-dominated sorting\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    selected_idx = random.choice(fronts[0]) if fronts[0] else random.randint(0, len(archive)-1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        segment_length = random.randint(1, min(5, n//3))\n        pos1 = random.randint(0, n - segment_length - 1)\n        pos2 = random.randint(0, n - segment_length - 1)\n\n        segment1 = new_solution[pos1:pos1+segment_length]\n        segment2 = new_solution[pos2:pos2+segment_length]\n\n        new_solution[pos1:pos1+segment_length] = segment2\n        new_solution[pos2:pos2+segment_length] = segment1\n\n        # Multi-objective edge insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Objective-based edge selection\n        obj_weight = random.random()\n        if obj_weight < 0.5:\n            # Prefer edges with better distance in first objective\n            best_edge = None\n            best_dist = float('inf')\n            for k in range(n-1):\n                dist = distance_matrix_1[new_solution[k]][new_solution[k+1]]\n                if dist < best_dist:\n                    best_dist = dist\n                    best_edge = (k, k+1)\n            if best_edge:\n                a, b = best_edge\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Prefer edges with better distance in second objective\n            best_edge = None\n            best_dist = float('inf')\n            for k in range(n-1):\n                dist = distance_matrix_2[new_solution[k]][new_solution[k+1]]\n                if dist < best_dist:\n                    best_dist = dist\n                    best_edge = (k, k+1)\n            if best_edge:\n                a, b = best_edge\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8632793956758648,
            1.0533709526062012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using non-dominated sorting\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1] and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    selected_idx = random.choice(fronts[0]) if fronts[0] else random.randint(0, len(archive)-1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        segment_length = random.randint(1, min(5, n//3))\n        pos1 = random.randint(0, n - segment_length - 1)\n        pos2 = random.randint(0, n - segment_length - 1)\n\n        segment1 = new_solution[pos1:pos1+segment_length]\n        segment2 = new_solution[pos2:pos2+segment_length]\n\n        new_solution[pos1:pos1+segment_length] = segment2\n        new_solution[pos2:pos2+segment_length] = segment1\n\n        # Multi-objective edge insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(i - j) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Objective-based edge selection\n        obj_weight = random.random()\n        if obj_weight < 0.5:\n            # Prefer edges with better distance in first objective\n            best_edge = None\n            best_dist = float('inf')\n            for k in range(n-1):\n                dist = distance_matrix_1[new_solution[k]][new_solution[k+1]]\n                if dist < best_dist:\n                    best_dist = dist\n                    best_edge = (k, k+1)\n            if best_edge:\n                a, b = best_edge\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Prefer edges with better distance in second objective\n            best_edge = None\n            best_dist = float('inf')\n            for k in range(n-1):\n                dist = distance_matrix_2[new_solution[k]][new_solution[k+1]]\n                if dist < best_dist:\n                    best_dist = dist\n                    best_edge = (k, k+1)\n            if best_edge:\n                a, b = best_edge\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{A novel local search heuristic that combines non-dominated sorting with a dynamic segment insertion and reversal strategy, leveraging both distance matrices to guide the search while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting to identify promising solutions\n    fronts = []\n    dominated_counts = {}\n    dominating_sets = {}\n    for i, (sol, obj) in enumerate(archive):\n        dominated_counts[i] = 0\n        dominating_sets[i] = set()\n        for j, (_, other_obj) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj[0] <= other_obj[0] and obj[1] <= other_obj[1]) and (obj[0] < other_obj[0] or obj[1] < other_obj[1]):\n                dominating_sets[i].add(j)\n            elif (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated_counts[i] += 1\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    # Select from the first front\n    selected_idx = random.choice(fronts[0]) if fronts else random.randint(0, len(archive)-1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Dynamic segment insertion and reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Extract and reverse segments\n        segment1 = new_solution[a:b+1][::-1]\n        segment2 = new_solution[c:d+1][::-1]\n\n        # Insert segments with probability based on distance improvement\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:a], segment1, new_solution[b+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:c], segment2, new_solution[d+1:]])\n\n        # Randomly reverse a segment\n        x, y = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Step 3: Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.7:\n            # Repair by reinserting missing nodes\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, pos, node)\n            new_solution = new_solution[:n]  # Ensure correct length\n        else:\n            # Random shuffle fallback\n            np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7892065475424872,
            3.0081868171691895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting to identify promising solutions\n    fronts = []\n    dominated_counts = {}\n    dominating_sets = {}\n    for i, (sol, obj) in enumerate(archive):\n        dominated_counts[i] = 0\n        dominating_sets[i] = set()\n        for j, (_, other_obj) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj[0] <= other_obj[0] and obj[1] <= other_obj[1]) and (obj[0] < other_obj[0] or obj[1] < other_obj[1]):\n                dominating_sets[i].add(j)\n            elif (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated_counts[i] += 1\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    # Select from the first front\n    selected_idx = random.choice(fronts[0]) if fronts else random.randint(0, len(archive)-1)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Dynamic segment insertion and reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Extract and reverse segments\n        segment1 = new_solution[a:b+1][::-1]\n        segment2 = new_solution[c:d+1][::-1]\n\n        # Insert segments with probability based on distance improvement\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:a], segment1, new_solution[b+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:c], segment2, new_solution[d+1:]])\n\n        # Randomly reverse a segment\n        x, y = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Step 3: Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.7:\n            # Repair by reinserting missing nodes\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, pos, node)\n            new_solution = new_solution[:n]  # Ensure correct length\n        else:\n            # Random shuffle fallback\n            np.random.shuffle(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines crowding-distance-based selection with a dynamic trade-off-aware segment exchange and node relocation strategy to explore the Pareto front efficiently while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(sorted_objectives))\n        distances[1:-1] = np.sum(np.abs(sorted_objectives[2:] - sorted_objectives[:-2]), axis=1)\n        selected_idx = sorted_indices[np.argmax(distances)]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic trade-off-aware local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic trade-off segment exchange\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n\n        # Calculate trade-off factor based on current objectives\n        obj1, obj2 = archive[selected_idx][1]\n        tradeoff = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n        # Apply segment with probability based on trade-off\n        if random.random() < tradeoff:\n            new_solution[a:b+1] = segment\n\n        # Node relocation with trade-off consideration\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_1[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_2[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n        # Accept move if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{A novel local search heuristic that combines dominance-based selection with an adaptive segment inversion and node swap strategy to explore the Pareto front efficiently while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion with adaptive probability\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1][::-1]\n\n        # Adaptive probability based on segment length\n        inversion_prob = min(0.5, (b - a) / n)\n\n        if random.random() < inversion_prob:\n            new_solution[a:b+1] = segment\n\n        # Node swap with dominance consideration\n        i, j = random.sample(range(n), 2)\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] + \\\n                   distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] + \\\n                   distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] + \\\n                   distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] + \\\n                   distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]]\n\n        # Accept swap if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6464441770335011,
            14.704573452472687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion with adaptive probability\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1][::-1]\n\n        # Adaptive probability based on segment length\n        inversion_prob = min(0.5, (b - a) / n)\n\n        if random.random() < inversion_prob:\n            new_solution[a:b+1] = segment\n\n        # Node swap with dominance consideration\n        i, j = random.sample(range(n), 2)\n        node_i, node_j = new_solution[i], new_solution[j]\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] + \\\n                   distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] + \\\n                   distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] + \\\n                   distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] + \\\n                   distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]]\n\n        # Accept swap if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel local search heuristic that combines a dominance-based selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(objectives), dtype=bool)\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1] and (objectives[i, 0] > objectives[j, 0] or objectives[i, 1] > objectives[j, 1])):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_solution = solutions[random.choice(non_dominated_indices)].copy()\n    else:\n        selected_solution = solutions[np.argmin(np.sum(objectives, axis=1))].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2\n        new_solution[j:j+2] = segment1\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9439192609817395,
            2.7153356075286865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(objectives), dtype=bool)\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1] and (objectives[i, 0] > objectives[j, 0] or objectives[i, 1] > objectives[j, 1])):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_solution = solutions[random.choice(non_dominated_indices)].copy()\n    else:\n        selected_solution = solutions[np.argmin(np.sum(objectives, axis=1))].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2\n        new_solution[j:j+2] = segment1\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This novel algorithm selects high-potential solutions based on their objective-space diversity and applies a hybrid of segment-wise displacement and objective-aware edge swapping, dynamically balancing exploration and exploitation by leveraging geometric properties of node positions to generate highly diverse neighbors while maintaining feasibility and preserving Pareto-front structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = []\n    for i in range(len(objectives)):\n        dist1 = np.linalg.norm(objectives[i] - objectives, axis=1)\n        dist2 = np.linalg.norm(objectives[i] - objectives, axis=1)\n        diversity_scores.append(np.mean(dist1) + np.mean(dist2))\n\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-wise displacement\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate displacement vector based on objective space properties\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply displacement to nodes in the segment\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Displace in first space\n            disp1 = instance[node_idx, :2] - centroid1\n            instance[node_idx, :2] += disp1 * 0.3\n\n            # Displace in second space\n            disp2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2:] += disp2 * 0.3\n\n        # Objective-aware edge swapping\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = (i + 1) % n\n\n            # Calculate edge costs in both spaces\n            cost1_before = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            cost2_before = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            cost1_after = distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_1[new_solution[(j+1)%n], new_solution[j]]\n            cost2_after = distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(j+1)%n], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9538985302853871,
            14.810297191143036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = []\n    for i in range(len(objectives)):\n        dist1 = np.linalg.norm(objectives[i] - objectives, axis=1)\n        dist2 = np.linalg.norm(objectives[i] - objectives, axis=1)\n        diversity_scores.append(np.mean(dist1) + np.mean(dist2))\n\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-wise displacement\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate displacement vector based on objective space properties\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply displacement to nodes in the segment\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Displace in first space\n            disp1 = instance[node_idx, :2] - centroid1\n            instance[node_idx, :2] += disp1 * 0.3\n\n            # Displace in second space\n            disp2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2:] += disp2 * 0.3\n\n        # Objective-aware edge swapping\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = (i + 1) % n\n\n            # Calculate edge costs in both spaces\n            cost1_before = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            cost2_before = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            cost1_after = distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_1[new_solution[(j+1)%n], new_solution[j]]\n            cost2_after = distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(j+1)%n], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines crowding-distance-based selection with a dynamic trade-off-aware segment exchange and node relocation strategy to explore the Pareto front efficiently while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(sorted_objectives))\n        distances[1:-1] = np.sum(np.abs(sorted_objectives[2:] - sorted_objectives[:-2]), axis=1)\n        selected_idx = sorted_indices[np.argmax(distances)]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic trade-off-aware local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic trade-off segment exchange\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n\n        # Calculate trade-off factor based on current objectives\n        obj1, obj2 = archive[selected_idx][1]\n        tradeoff = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n        # Apply segment with probability based on trade-off\n        if random.random() < tradeoff:\n            new_solution[a:b+1] = segment\n\n        # Node relocation with trade-off consideration\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_1[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_2[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n        # Accept move if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{A novel local search heuristic that combines a multi-objective adaptive path decomposition with a probabilistic segment inversion and reinsertion strategy, dynamically balancing the trade-off between objectives through a weighted distance evaluation while maintaining feasibility through a hierarchical validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with adaptive weighting\n    weights = np.array([(obj[0] + obj[1]) / (sum(obj) + 1e-10) for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    obj1, obj2 = archive[selected_idx][1]\n\n    # Step 2: Multi-objective adaptive path decomposition\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Split into segments with adaptive size\n    segment_size = max(2, min(4, n // 3))\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 3: Probabilistic segment operations\n    new_solution = base_solution.copy()\n    for i in range(len(segments)):\n        if random.random() < 0.3:  # 30% chance to process segment\n            segment = segments[i]\n\n            # Weighted probability based on objectives\n            prob_invert = (obj1 / (obj1 + obj2)) * 0.7 + (obj2 / (obj1 + obj2)) * 0.3\n\n            if random.random() < prob_invert:\n                # Segment inversion\n                new_solution[np.where(np.isin(new_solution, segment))[0]] = segment[::-1]\n            else:\n                # Segment reinsertion\n                pos = np.where(np.isin(new_solution, segment))[0]\n                new_solution = np.delete(new_solution, pos)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 4: Hierarchical validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to node reinsertion\n        for node in np.setdiff1d(base_solution, new_solution):\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8006955724331689,
            2.954793632030487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with adaptive weighting\n    weights = np.array([(obj[0] + obj[1]) / (sum(obj) + 1e-10) for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    obj1, obj2 = archive[selected_idx][1]\n\n    # Step 2: Multi-objective adaptive path decomposition\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Split into segments with adaptive size\n    segment_size = max(2, min(4, n // 3))\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 3: Probabilistic segment operations\n    new_solution = base_solution.copy()\n    for i in range(len(segments)):\n        if random.random() < 0.3:  # 30% chance to process segment\n            segment = segments[i]\n\n            # Weighted probability based on objectives\n            prob_invert = (obj1 / (obj1 + obj2)) * 0.7 + (obj2 / (obj1 + obj2)) * 0.3\n\n            if random.random() < prob_invert:\n                # Segment inversion\n                new_solution[np.where(np.isin(new_solution, segment))[0]] = segment[::-1]\n            else:\n                # Segment reinsertion\n                pos = np.where(np.isin(new_solution, segment))[0]\n                new_solution = np.delete(new_solution, pos)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 4: Hierarchical validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to node reinsertion\n        for node in np.setdiff1d(base_solution, new_solution):\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This novel algorithm selects solutions based on their dominance rank and applies a hybrid operator combining path reversal with adaptive node perturbation, guided by objective trade-offs to diversify the search while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n\n    # Calculate dominance ranks\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                dominated += 1\n        ranks[i] = dominated\n\n    selected_idx = np.argmin(ranks)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (path reversal + adaptive perturbation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments for reversal\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Adaptive perturbation based on objective differences\n        obj1, obj2 = archive[selected_idx][1]\n        if abs(obj1 - obj2) > 0.1 * (obj1 + obj2):\n            # Perturb more aggressively if objectives are imbalanced\n            num_perturbations = min(3, n // 4)\n            for _ in range(num_perturbations):\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8058189356382347,
            1.8933597207069397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n\n    # Calculate dominance ranks\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                dominated += 1\n        ranks[i] = dominated\n\n    selected_idx = np.argmin(ranks)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (path reversal + adaptive perturbation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments for reversal\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Adaptive perturbation based on objective differences\n        obj1, obj2 = archive[selected_idx][1]\n        if abs(obj1 - obj2) > 0.1 * (obj1 + obj2):\n            # Perturb more aggressively if objectives are imbalanced\n            num_perturbations = min(3, n // 4)\n            for _ in range(num_perturbations):\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This novel approach combines a Pareto-dominance-based selection of solutions with a dynamic segment rotation and node reinsertion operation, guided by a multi-objective improvement criterion that prioritizes non-dominated solutions while ensuring feasibility through a constrained search strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select non-dominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n    non_dominated_indices = np.where(~is_dominated)[0]\n\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    selected_idx = np.random.choice(non_dominated_indices)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment rotation and node reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Rotate a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Reinsert a random node at a new position\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7826481848179565,
            2.6684911847114563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select non-dominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n    non_dominated_indices = np.where(~is_dominated)[0]\n\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    selected_idx = np.random.choice(non_dominated_indices)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment rotation and node reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Rotate a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Reinsert a random node at a new position\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm combines Pareto-dominance-based solution selection with a hybrid local search operator that dynamically adapts its structure based on the relative performance of each objective, using a novel segment insertion and rotation mechanism to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest Pareto dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid segment insertion and rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Remove the segment\n        new_solution = np.delete(new_solution, np.arange(a, b+1))\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Rotate the segment based on objective weights\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n\n        if obj1 > obj2:\n            # Rotate segment clockwise if first objective is worse\n            new_solution[insert_pos:insert_pos+len(segment)] = np.roll(segment, 1)\n        else:\n            # Rotate segment counter-clockwise if second objective is worse\n            new_solution[insert_pos:insert_pos+len(segment)] = np.roll(segment, -1)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8080146313116523,
            3.4154029488563538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest Pareto dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid segment insertion and rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Remove the segment\n        new_solution = np.delete(new_solution, np.arange(a, b+1))\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Rotate the segment based on objective weights\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n\n        if obj1 > obj2:\n            # Rotate segment clockwise if first objective is worse\n            new_solution[insert_pos:insert_pos+len(segment)] = np.roll(segment, 1)\n        else:\n            # Rotate segment counter-clockwise if second objective is worse\n            new_solution[insert_pos:insert_pos+len(segment)] = np.roll(segment, -1)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a dynamic node insertion and edge reversal operation, guided by a hypervolume improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with Pareto dominance and hypervolume improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        # If no Pareto front, select the one with best hypervolume contribution\n        hypervolumes = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                hypervolumes.append(np.prod(objectives[i]))\n            else:\n                hypervolumes.append(0)\n        selected_idx = np.argmax(hypervolumes)\n    else:\n        selected_idx = random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node insertion and edge reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Insert a random node at a random position\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n        # Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9419251537019883,
            3.8801318407058716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with Pareto dominance and hypervolume improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        # If no Pareto front, select the one with best hypervolume contribution\n        hypervolumes = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                hypervolumes.append(np.prod(objectives[i]))\n            else:\n                hypervolumes.append(0)\n        selected_idx = np.argmax(hypervolumes)\n    else:\n        selected_idx = random.choice(pareto_front)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic node insertion and edge reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Insert a random node at a random position\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n        # Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{A novel local search heuristic that combines a Pareto-frontier guided selection of solutions with a dynamic segment insertion and edge rotation operation, guided by a multi-objective improvement criterion to explore the solution space efficiently while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto-frontier analysis\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Rotate a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n    # Step 3: Probabilistic validation\n    if len(np.unique(new_solution)) != n:\n        # Randomly accept or reject the operation\n        if random.random() < 0.5:\n            # Accept with random swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Revert to original\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8347738306384161,
            4.016412854194641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto-frontier analysis\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment insertion and edge rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and insert it elsewhere\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, range(a, b+1))\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Rotate a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n    # Step 3: Probabilistic validation\n    if len(np.unique(new_solution)) != n:\n        # Randomly accept or reject the operation\n        if random.random() < 0.5:\n            # Accept with random swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Revert to original\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{A novel local search heuristic first identifies a solution from the archive with balanced quality and diversity, then applies a combination of edge insertion and segment rotation to generate a neighbor solution while ensuring feasibility through a dynamic node reordering mechanism guided by Pareto dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Total cost as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply edge insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes and insert one after the other\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            node_to_insert = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Rotate a segment of the tour\n        a, b = sorted(random.sample(range(n), 2))\n        rotation = random.randint(1, b - a)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        node_to_insert = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.57056124593794,
            4.2639079093933105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Total cost as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply edge insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes and insert one after the other\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            node_to_insert = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Rotate a segment of the tour\n        a, b = sorted(random.sample(range(n), 2))\n        rotation = random.randint(1, b - a)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        node_to_insert = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{A novel local search heuristic selects solutions based on their trade-off between objective improvements and solution diversity, then applies a hybrid operator that combines node insertion with adaptive edge flipping, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high trade-off between objective improvements and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)\n    diversity_scores = np.linalg.norm(objectives - np.median(objectives, axis=0), axis=1)\n    combined_scores = quality_scores * 0.6 + diversity_scores * 0.4\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator combining node insertion and adaptive edge flipping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            insert_pos = random.randint(i+1, j-1)\n            node_to_move = new_solution[insert_pos]\n            new_solution = np.delete(new_solution, insert_pos)\n            new_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Adaptive edge flipping\n        a, b = sorted(random.sample(range(len(new_solution)), 2))\n        segment = new_solution[a:b+1]\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Flip edges based on relative positions\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            if np.linalg.norm([x1, y1]) > np.linalg.norm([x2, y2]):\n                instance[node_idx, :2] = -instance[node_idx, :2] + 2 * centroid1\n            else:\n                instance[node_idx, 2:] = -instance[node_idx, 2:] + 2 * centroid2\n\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.661766453124972,
            5.8528942465782166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high trade-off between objective improvements and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)\n    diversity_scores = np.linalg.norm(objectives - np.median(objectives, axis=0), axis=1)\n    combined_scores = quality_scores * 0.6 + diversity_scores * 0.4\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator combining node insertion and adaptive edge flipping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            insert_pos = random.randint(i+1, j-1)\n            node_to_move = new_solution[insert_pos]\n            new_solution = np.delete(new_solution, insert_pos)\n            new_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n        # Adaptive edge flipping\n        a, b = sorted(random.sample(range(len(new_solution)), 2))\n        segment = new_solution[a:b+1]\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Flip edges based on relative positions\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            if np.linalg.norm([x1, y1]) > np.linalg.norm([x2, y2]):\n                instance[node_idx, :2] = -instance[node_idx, :2] + 2 * centroid1\n            else:\n                instance[node_idx, 2:] = -instance[node_idx, 2:] + 2 * centroid2\n\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{A novel heuristic combines Pareto-dominance-based selection with a dynamic edge insertion and segment rotation operator, guided by a hybrid objective improvement criterion to efficiently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto-dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = range(len(archive))\n\n    selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges and insert a new node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            insert_pos = random.randint(i+1, j-1)\n            new_node = random.choice(new_solution)\n            new_solution = np.insert(new_solution, insert_pos, new_node)\n\n        # Rotate a random segment by one position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        i = random.randint(0, len(new_solution)-1)\n        new_node = random.choice(new_solution)\n        new_solution = np.insert(new_solution, i, new_node)\n\n    return new_solution\n\n",
        "score": [
            -0.5067849724717866,
            1.012162446975708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto-dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = range(len(archive))\n\n    selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic edge insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges and insert a new node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            insert_pos = random.randint(i+1, j-1)\n            new_node = random.choice(new_solution)\n            new_solution = np.insert(new_solution, insert_pos, new_node)\n\n        # Rotate a random segment by one position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        i = random.randint(0, len(new_solution)-1)\n        new_node = random.choice(new_solution)\n        new_solution = np.insert(new_solution, i, new_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This novel algorithm employs a non-dominated sorting-based selection of solutions from the archive, combined with a hybrid of edge-swapping and segment-shuffling operations, dynamically prioritizing solutions with better objective-specific dominance while ensuring feasibility through a controlled perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using non-dominated sorting\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            obj1_i, obj2_i = archive[i][1]\n            obj1_j, obj2_j = archive[j][1]\n\n            if (obj1_i <= obj1_j and obj2_i <= obj2_j) and (obj1_i < obj1_j or obj2_i < obj2_j):\n                dominating_sets[i].append(j)\n            elif (obj1_j <= obj1_i and obj2_j <= obj2_i) and (obj1_j < obj1_i or obj2_j < obj2_i):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    selected_idx = random.choice(fronts[0]) if fronts[0] else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        # Determine segment to shuffle\n        segment_length = random.randint(2, min(4, n//3))\n        start = a\n        end = min(start + segment_length, n-1)\n\n        # Shuffle the segment\n        segment = new_solution[start:end+1]\n        np.random.shuffle(segment)\n        new_solution[start:end+1] = segment\n\n        # Edge-swapping with objective-specific consideration\n        obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        if random.random() < 0.5:\n            # Prefer solutions with better objective 1\n            candidates = []\n            for i in range(n):\n                for j in range(i+2, n):\n                    new_obj1 = obj1_cost - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                    if new_obj1 < obj1_cost:\n                        candidates.append((i, j))\n            if candidates:\n                i, j = random.choice(candidates)\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Prefer solutions with better objective 2\n            candidates = []\n            for i in range(n):\n                for j in range(i+2, n):\n                    new_obj2 = obj2_cost - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                    if new_obj2 < obj2_cost:\n                        candidates.append((i, j))\n            if candidates:\n                i, j = random.choice(candidates)\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8825837818463439,
            11.969048619270325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using non-dominated sorting\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            obj1_i, obj2_i = archive[i][1]\n            obj1_j, obj2_j = archive[j][1]\n\n            if (obj1_i <= obj1_j and obj2_i <= obj2_j) and (obj1_i < obj1_j or obj2_i < obj2_j):\n                dominating_sets[i].append(j)\n            elif (obj1_j <= obj1_i and obj2_j <= obj2_i) and (obj1_j < obj1_i or obj2_j < obj2_i):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    selected_idx = random.choice(fronts[0]) if fronts[0] else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n\n        # Determine segment to shuffle\n        segment_length = random.randint(2, min(4, n//3))\n        start = a\n        end = min(start + segment_length, n-1)\n\n        # Shuffle the segment\n        segment = new_solution[start:end+1]\n        np.random.shuffle(segment)\n        new_solution[start:end+1] = segment\n\n        # Edge-swapping with objective-specific consideration\n        obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        if random.random() < 0.5:\n            # Prefer solutions with better objective 1\n            candidates = []\n            for i in range(n):\n                for j in range(i+2, n):\n                    new_obj1 = obj1_cost - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                    if new_obj1 < obj1_cost:\n                        candidates.append((i, j))\n            if candidates:\n                i, j = random.choice(candidates)\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        else:\n            # Prefer solutions with better objective 2\n            candidates = []\n            for i in range(n):\n                for j in range(i+2, n):\n                    new_obj2 = obj2_cost - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                    if new_obj2 < obj2_cost:\n                        candidates.append((i, j))\n            if candidates:\n                i, j = random.choice(candidates)\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This novel algorithm combines a dominance-based selection of solutions from the archive with a hybrid of node-sequence rotation and multi-objective-aware edge swapping operations, dynamically balancing the exploration of trade-off regions by leveraging Pareto-dominance relationships and objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-sequence rotation operation\n        k = random.randint(1, min(5, n//2))\n        rotation_point = random.randint(0, n-1)\n        new_solution = np.roll(new_solution, -k)\n        new_solution[rotation_point:rotation_point+k] = new_solution[rotation_point:rotation_point+k][::-1]\n\n        # Multi-objective-aware edge swapping\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i:\n                j = random.randint(0, n-1)\n\n            # Calculate objective improvements\n            prev_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            prev_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < prev_cost1 and new_cost2 < prev_cost2) or \\\n               (new_cost1 < prev_cost1 and new_cost2 <= prev_cost2 * 1.05) or \\\n               (new_cost2 < prev_cost2 and new_cost1 <= prev_cost1 * 1.05):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Find a cycle and reverse it\n        visited = set()\n        for i in range(n):\n            if i not in visited:\n                cycle = []\n                current = i\n                while current not in visited:\n                    visited.add(current)\n                    cycle.append(current)\n                    current = new_solution[current]\n                if len(cycle) > 1:\n                    for j in range(len(cycle)//2):\n                        new_solution[cycle[j]], new_solution[cycle[-j-1]] = new_solution[cycle[-j-1]], new_solution[cycle[j]]\n\n    return new_solution\n\n",
        "score": [
            -0.7452994980246312,
            2.092505931854248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and dominates(other_obj, obj):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-sequence rotation operation\n        k = random.randint(1, min(5, n//2))\n        rotation_point = random.randint(0, n-1)\n        new_solution = np.roll(new_solution, -k)\n        new_solution[rotation_point:rotation_point+k] = new_solution[rotation_point:rotation_point+k][::-1]\n\n        # Multi-objective-aware edge swapping\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i:\n                j = random.randint(0, n-1)\n\n            # Calculate objective improvements\n            prev_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            prev_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < prev_cost1 and new_cost2 < prev_cost2) or \\\n               (new_cost1 < prev_cost1 and new_cost2 <= prev_cost2 * 1.05) or \\\n               (new_cost2 < prev_cost2 and new_cost1 <= prev_cost1 * 1.05):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Find a cycle and reverse it\n        visited = set()\n        for i in range(n):\n            if i not in visited:\n                cycle = []\n                current = i\n                while current not in visited:\n                    visited.add(current)\n                    cycle.append(current)\n                    current = new_solution[current]\n                if len(cycle) > 1:\n                    for j in range(len(cycle)//2):\n                        new_solution[cycle[j]], new_solution[cycle[-j-1]] = new_solution[cycle[-j-1]], new_solution[cycle[j]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This novel local search heuristic integrates a Pareto-dominance guided selection of solutions with a multi-segment insertion and reversal operation, dynamically balancing objective improvements through a hybrid of edge-swapping and node-reinsertion strategies while maintaining feasibility through a hierarchical validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto dominance and objective trade-off\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        # If no non-dominated, select based on trade-off between objectives\n        trade_off = objectives[:, 0] + 0.5 * objectives[:, 1]\n        selected_idx = np.argmin(trade_off)\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply multi-segment insertion and reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select multiple segments and perform insertion and reversal\n        num_segments = random.randint(2, min(4, n//3))\n        segment_indices = sorted(random.sample(range(n), num_segments))\n\n        # Create segments and reverse them\n        segments = []\n        for i in range(num_segments):\n            start = segment_indices[i]\n            end = segment_indices[(i+1)%num_segments] if i < num_segments-1 else n\n            if start > end:\n                start, end = end, start\n            segments.append(new_solution[start:end][::-1])\n\n        # Reinsert segments at new positions\n        for i, seg in enumerate(segments):\n            new_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, new_pos, seg)\n            n = len(new_solution)\n\n        # Remove duplicates (if any) by reinserting missing nodes\n        missing_nodes = set(range(len(instance))) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Hierarchical validation\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to node reinsertion\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = set(range(len(instance))) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(new_solution) > len(instance):\n        # Remove excess nodes by random selection\n        excess = len(new_solution) - len(instance)\n        remove_indices = random.sample(range(len(new_solution)), excess)\n        new_solution = np.delete(new_solution, sorted(remove_indices, reverse=True))\n\n    return new_solution\n\n",
        "score": [
            -0.9234607811795501,
            2.924092411994934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto dominance and objective trade-off\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        # If no non-dominated, select based on trade-off between objectives\n        trade_off = objectives[:, 0] + 0.5 * objectives[:, 1]\n        selected_idx = np.argmin(trade_off)\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply multi-segment insertion and reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select multiple segments and perform insertion and reversal\n        num_segments = random.randint(2, min(4, n//3))\n        segment_indices = sorted(random.sample(range(n), num_segments))\n\n        # Create segments and reverse them\n        segments = []\n        for i in range(num_segments):\n            start = segment_indices[i]\n            end = segment_indices[(i+1)%num_segments] if i < num_segments-1 else n\n            if start > end:\n                start, end = end, start\n            segments.append(new_solution[start:end][::-1])\n\n        # Reinsert segments at new positions\n        for i, seg in enumerate(segments):\n            new_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, new_pos, seg)\n            n = len(new_solution)\n\n        # Remove duplicates (if any) by reinserting missing nodes\n        missing_nodes = set(range(len(instance))) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Hierarchical validation\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to node reinsertion\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = set(range(len(instance))) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(new_solution) > len(instance):\n        # Remove excess nodes by random selection\n        excess = len(new_solution) - len(instance)\n        remove_indices = random.sample(range(len(new_solution)), excess)\n        new_solution = np.delete(new_solution, sorted(remove_indices, reverse=True))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This novel heuristic combines a Pareto front dominance-based selection with a hybrid of adaptive segment rotation and node reordering operations, guided by a multi-objective fitness estimation to explore diverse regions of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and fitness\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Find non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    non_dominated_idx = np.where(~is_dominated)[0]\n    if len(non_dominated_idx) > 0:\n        selected_idx = np.random.choice(non_dominated_idx)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        k = random.randint(1, n-2)\n        rotation = random.randint(1, n-1)\n        segment = new_solution[k:]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution = np.concatenate([new_solution[:k], rotated_segment])\n\n        # Node reordering based on distance trade-off\n        weights = np.random.dirichlet([1, 1])\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate combined distance\n        dist1 = distance_matrix_1[node_i, node_j]\n        dist2 = distance_matrix_2[node_i, node_j]\n        combined_dist = weights[0] * dist1 + weights[1] * dist2\n\n        # Decide whether to swap based on combined distance\n        if combined_dist < (distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[node_j, new_solution[(i+1)%n]]) * weights[0] + \\\n           (distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[node_j, new_solution[(i+1)%n]]) * weights[1]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8880872471770747,
            2.5252092480659485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto dominance and fitness\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Find non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    non_dominated_idx = np.where(~is_dominated)[0]\n    if len(non_dominated_idx) > 0:\n        selected_idx = np.random.choice(non_dominated_idx)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        k = random.randint(1, n-2)\n        rotation = random.randint(1, n-1)\n        segment = new_solution[k:]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution = np.concatenate([new_solution[:k], rotated_segment])\n\n        # Node reordering based on distance trade-off\n        weights = np.random.dirichlet([1, 1])\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate combined distance\n        dist1 = distance_matrix_1[node_i, node_j]\n        dist2 = distance_matrix_2[node_i, node_j]\n        combined_dist = weights[0] * dist1 + weights[1] * dist2\n\n        # Decide whether to swap based on combined distance\n        if combined_dist < (distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[node_j, new_solution[(i+1)%n]]) * weights[0] + \\\n           (distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[node_j, new_solution[(i+1)%n]]) * weights[1]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{A novel local search heuristic selects solutions based on their dominance rank and applies a hybrid operator that combines node insertion with adaptive geometric transformation, guided by the relative improvement potential of each objective to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    dominance_ranks = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated += 1\n        dominance_ranks[i] = dominated\n\n    selected_idx = np.argmin(dominance_ranks)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (insertion + adaptive transformation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node to insert elsewhere\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Calculate improvement potential\n        obj1_improvement = distance_matrix_1[new_solution[insert_pos-1], node] + distance_matrix_1[node, new_solution[(insert_pos+1)%n]] - distance_matrix_1[new_solution[insert_pos-1], new_solution[insert_pos]]\n        obj2_improvement = distance_matrix_2[new_solution[insert_pos-1], node] + distance_matrix_2[node, new_solution[(insert_pos+1)%n]] - distance_matrix_2[new_solution[insert_pos-1], new_solution[insert_pos]]\n\n        # Apply adaptive transformation\n        if obj1_improvement > obj2_improvement:\n            scale_factor = 0.9 + 0.2 * (obj1_improvement / (obj1_improvement + obj2_improvement))\n            instance[node, :2] = (instance[node, :2] - instance[node, :2].mean()) * scale_factor + instance[node, :2].mean()\n        else:\n            scale_factor = 0.9 + 0.2 * (obj2_improvement / (obj1_improvement + obj2_improvement))\n            instance[node, 2:] = (instance[node, 2:] - instance[node, 2:].mean()) * scale_factor + instance[node, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8178080963914283,
            2.162030816078186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    dominance_ranks = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated += 1\n        dominance_ranks[i] = dominated\n\n    selected_idx = np.argmin(dominance_ranks)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (insertion + adaptive transformation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node to insert elsewhere\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Calculate improvement potential\n        obj1_improvement = distance_matrix_1[new_solution[insert_pos-1], node] + distance_matrix_1[node, new_solution[(insert_pos+1)%n]] - distance_matrix_1[new_solution[insert_pos-1], new_solution[insert_pos]]\n        obj2_improvement = distance_matrix_2[new_solution[insert_pos-1], node] + distance_matrix_2[node, new_solution[(insert_pos+1)%n]] - distance_matrix_2[new_solution[insert_pos-1], new_solution[insert_pos]]\n\n        # Apply adaptive transformation\n        if obj1_improvement > obj2_improvement:\n            scale_factor = 0.9 + 0.2 * (obj1_improvement / (obj1_improvement + obj2_improvement))\n            instance[node, :2] = (instance[node, :2] - instance[node, :2].mean()) * scale_factor + instance[node, :2].mean()\n        else:\n            scale_factor = 0.9 + 0.2 * (obj2_improvement / (obj1_improvement + obj2_improvement))\n            instance[node, 2:] = (instance[node, 2:] - instance[node, 2:].mean()) * scale_factor + instance[node, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines crowding-distance-based selection with a dynamic trade-off-aware segment exchange and node relocation strategy to explore the Pareto front efficiently while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(sorted_objectives))\n        distances[1:-1] = np.sum(np.abs(sorted_objectives[2:] - sorted_objectives[:-2]), axis=1)\n        selected_idx = sorted_indices[np.argmax(distances)]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic trade-off-aware local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic trade-off segment exchange\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n\n        # Calculate trade-off factor based on current objectives\n        obj1, obj2 = archive[selected_idx][1]\n        tradeoff = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n        # Apply segment with probability based on trade-off\n        if random.random() < tradeoff:\n            new_solution[a:b+1] = segment\n\n        # Node relocation with trade-off consideration\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_1[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_2[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n        # Accept move if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This novel local search heuristic combines crowding-distance-based selection with a geometric transformation-based neighborhood exploration that dynamically adapts the solution structure based on the relative importance of objectives while maintaining feasibility through constrained geometric operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation neighborhood\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Calculate objective weights\n        obj1, obj2 = archive[selected_idx][1]\n        total = obj1 + obj2\n        weight1 = obj1 / total if total > 0 else 0.5\n        weight2 = obj2 / total if total > 0 else 0.5\n\n        # Select a segment for transformation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Apply weighted geometric transformation\n        for node_idx in segment:\n            # Get original coordinates\n            x1, y1, x2, y2 = instance[node_idx]\n\n            # Calculate new coordinates based on weights\n            new_x1 = x1 * (1 + weight1 * 0.1) - weight2 * 0.05 * (y1 - x1)\n            new_y1 = y1 * (1 + weight1 * 0.1) - weight2 * 0.05 * (x1 - y1)\n            new_x2 = x2 * (1 + weight2 * 0.1) - weight1 * 0.05 * (y2 - x2)\n            new_y2 = y2 * (1 + weight2 * 0.1) - weight1 * 0.05 * (x2 - y2)\n\n            # Update instance coordinates\n            instance[node_idx] = [new_x1, new_y1, new_x2, new_y2]\n\n        # Apply segment inversion with probability based on trade-off\n        if random.random() < weight1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Apply node relocation based on geometric properties\n        node_to_move = random.choice(segment)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = (current_pos + random.randint(1, n//2)) % n\n\n        # Calculate distance impact\n        old_dist = (weight1 * distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] +\n                    weight2 * distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]])\n        new_dist = (weight1 * distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[new_pos]] +\n                    weight2 * distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[new_pos]])\n\n        if new_dist < old_dist:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.914486624847432,
            4.180338442325592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation neighborhood\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Calculate objective weights\n        obj1, obj2 = archive[selected_idx][1]\n        total = obj1 + obj2\n        weight1 = obj1 / total if total > 0 else 0.5\n        weight2 = obj2 / total if total > 0 else 0.5\n\n        # Select a segment for transformation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Apply weighted geometric transformation\n        for node_idx in segment:\n            # Get original coordinates\n            x1, y1, x2, y2 = instance[node_idx]\n\n            # Calculate new coordinates based on weights\n            new_x1 = x1 * (1 + weight1 * 0.1) - weight2 * 0.05 * (y1 - x1)\n            new_y1 = y1 * (1 + weight1 * 0.1) - weight2 * 0.05 * (x1 - y1)\n            new_x2 = x2 * (1 + weight2 * 0.1) - weight1 * 0.05 * (y2 - x2)\n            new_y2 = y2 * (1 + weight2 * 0.1) - weight1 * 0.05 * (x2 - y2)\n\n            # Update instance coordinates\n            instance[node_idx] = [new_x1, new_y1, new_x2, new_y2]\n\n        # Apply segment inversion with probability based on trade-off\n        if random.random() < weight1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Apply node relocation based on geometric properties\n        node_to_move = random.choice(segment)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = (current_pos + random.randint(1, n//2)) % n\n\n        # Calculate distance impact\n        old_dist = (weight1 * distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] +\n                    weight2 * distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]])\n        new_dist = (weight1 * distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[new_pos]] +\n                    weight2 * distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[new_pos]])\n\n        if new_dist < old_dist:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective dominance and applies a novel geometric transformation operator that combines node reordering with adaptive coordinate scaling, guided by the relative objective contributions, to explore diverse regions of the Pareto front while preserving tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on objective dominance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(objectives, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate objective weights\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        weight1 = obj1 / total\n        weight2 = obj2 / total\n\n        # Apply adaptive scaling\n        for node in segment:\n            # Transform coordinates based on weighted objectives\n            x1, y1, x2, y2 = instance[node]\n            instance[node, 0] = x1 * (1 + 0.1 * weight1 * random.uniform(-1, 1))\n            instance[node, 1] = y1 * (1 + 0.1 * weight1 * random.uniform(-1, 1))\n            instance[node, 2] = x2 * (1 + 0.1 * weight2 * random.uniform(-1, 1))\n            instance[node, 3] = y2 * (1 + 0.1 * weight2 * random.uniform(-1, 1))\n\n        # Apply node reordering\n        if len(segment) > 2:\n            # Randomly shuffle the segment\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6399752262043105,
            2.571609079837799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on objective dominance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(objectives, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate objective weights\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        weight1 = obj1 / total\n        weight2 = obj2 / total\n\n        # Apply adaptive scaling\n        for node in segment:\n            # Transform coordinates based on weighted objectives\n            x1, y1, x2, y2 = instance[node]\n            instance[node, 0] = x1 * (1 + 0.1 * weight1 * random.uniform(-1, 1))\n            instance[node, 1] = y1 * (1 + 0.1 * weight1 * random.uniform(-1, 1))\n            instance[node, 2] = x2 * (1 + 0.1 * weight2 * random.uniform(-1, 1))\n            instance[node, 3] = y2 * (1 + 0.1 * weight2 * random.uniform(-1, 1))\n\n        # Apply node reordering\n        if len(segment) > 2:\n            # Randomly shuffle the segment\n            np.random.shuffle(segment)\n            new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This novel algorithm combines a non-dominated sorting-based selection of solutions from the archive with a hybrid of edge-swapping and segment-shuffling operations, dynamically adapting the search to the local Pareto front while preserving feasibility through a multi-objective feasibility-aware validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    fronts = []\n    dominated_counts = np.zeros(len(objectives))\n    dominating_sets = [[] for _ in range(len(objectives))]\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    front_indices = fronts[0]\n    if not front_indices:\n        front_indices = range(len(archive))\n\n    selected_idx = random.choice(front_indices)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        a, b, c = sorted(random.sample(range(n), 3))\n        if distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[c]] > distance_matrix_1[new_solution[a], new_solution[c]]:\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n        # Segment-shuffling operation\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair by inserting missing nodes\n        missing_nodes = list(set(range(n)) - set(new_solution))\n        if missing_nodes:\n            insert_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, random.choice(missing_nodes))\n\n    return new_solution\n\n",
        "score": [
            -0.8274487626646746,
            3.2936460375785828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on non-dominated sorting\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    fronts = []\n    dominated_counts = np.zeros(len(objectives))\n    dominating_sets = [[] for _ in range(len(objectives))]\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    front_indices = fronts[0]\n    if not front_indices:\n        front_indices = range(len(archive))\n\n    selected_idx = random.choice(front_indices)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        a, b, c = sorted(random.sample(range(n), 3))\n        if distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[c]] > distance_matrix_1[new_solution[a], new_solution[c]]:\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n        # Segment-shuffling operation\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Repair by inserting missing nodes\n        missing_nodes = list(set(range(n)) - set(new_solution))\n        if missing_nodes:\n            insert_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, random.choice(missing_nodes))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel local search heuristic that combines non-dominated sorting with a hybrid of segment insertion and edge reversal operations, adaptively balancing exploration and exploitation by leveraging objective-space diversity while maintaining feasibility through a multi-phase validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting and selection\n    fronts = []\n    remaining = [i for i in range(len(archive))]\n    while remaining:\n        front = []\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if all(archive[j][1][k] <= archive[i][1][k] for k in range(2)) and any(archive[j][1][k] < archive[i][1][k] for k in range(2)):\n                    dominated = True\n                    break\n            if not dominated:\n                front.append(i)\n        fronts.append(front)\n        remaining = [i for i in remaining if i not in front]\n\n    selected_front = fronts[0] if fronts else [0]\n    selected_idx = random.choice(selected_front)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment insertion operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Edge reversal operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n        if i > j:\n            i, j = j, i\n\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Multi-phase validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random insertion\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    return new_solution\n\n",
        "score": [
            -0.8005195392316536,
            3.1019734740257263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting and selection\n    fronts = []\n    remaining = [i for i in range(len(archive))]\n    while remaining:\n        front = []\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if all(archive[j][1][k] <= archive[i][1][k] for k in range(2)) and any(archive[j][1][k] < archive[i][1][k] for k in range(2)):\n                    dominated = True\n                    break\n            if not dominated:\n                front.append(i)\n        fronts.append(front)\n        remaining = [i for i in remaining if i not in front]\n\n    selected_front = fronts[0] if fronts else [0]\n    selected_idx = random.choice(selected_front)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment insertion operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Edge reversal operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n        if i > j:\n            i, j = j, i\n\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Multi-phase validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random insertion\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion, node relocation, and a novel \"objective-balanced\" edge swap operation, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution, objectives = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 2: Apply hybrid local search with novel operations\n        # Objective-balanced edge swap\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate cost before swap\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after swap\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if either objective improves\n        if (cost1_after < cost1_before and cost2_after <= cost2_before) or (cost2_after < cost2_before and cost1_after <= cost1_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.874936418176947,
            1.3594382405281067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution, objectives = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 2: Apply hybrid local search with novel operations\n        # Objective-balanced edge swap\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate cost before swap\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after swap\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if either objective improves\n        if (cost1_after < cost1_before and cost2_after <= cost2_before) or (cost2_after < cost2_before and cost1_after <= cost1_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{A novel local search heuristic combines a Pareto-dominance-based selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a multi-objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) and (other_obj[0] != obj[0] or other_obj[1] != obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    diversity_scores = np.linalg.norm(objectives[pareto_front] - objectives[pareto_front].mean(axis=0), axis=1)\n    selected_idx = pareto_front[np.argmax(diversity_scores)]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8388429298968079,
            1.003652036190033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) and (other_obj[0] != obj[0] or other_obj[1] != obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    diversity_scores = np.linalg.norm(objectives[pareto_front] - objectives[pareto_front].mean(axis=0), axis=1)\n    selected_idx = pareto_front[np.argmax(diversity_scores)]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their crowding distance in the objective space and applies a hybrid operator that combines node swapping with geometric scaling, guided by the relative importance of each objective to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distances\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (swapping + scaling)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random nodes for swapping\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Select a segment for scaling\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate scaling factors based on objective importance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        total = obj1 + obj2\n        scale_factor1 = 0.9 + 0.2 * (obj1 / total)\n        scale_factor2 = 0.9 + 0.2 * (obj2 / total)\n\n        # Apply scaling to segment\n        for node_idx in segment:\n            instance[node_idx, :2] = (instance[node_idx, :2] - instance[node_idx, :2].mean()) * scale_factor1 + instance[node_idx, :2].mean()\n            instance[node_idx, 2:] = (instance[node_idx, 2:] - instance[node_idx, 2:].mean()) * scale_factor2 + instance[node_idx, 2:].mean()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{The new algorithm selects solutions based on their dominance rank in the objective space and applies a hybrid operator that combines node insertion with adaptive path reversal, guided by the Pareto-frontier proximity to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with lowest dominance rank (non-dominated solutions preferred)\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (insertion + adaptive reversal)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node to insert elsewhere\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Adaptive path reversal based on objective dominance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if obj1 > obj2:\n            # Reverse a random segment if first objective dominates\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Reverse a random segment if second objective dominates\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8388728877530135,
            3.6031183004379272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution with lowest dominance rank (non-dominated solutions preferred)\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid operator (insertion + adaptive reversal)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node to insert elsewhere\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Adaptive path reversal based on objective dominance\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if obj1 > obj2:\n            # Reverse a random segment if first objective dominates\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Reverse a random segment if second objective dominates\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This novel algorithm employs a dominance-based selection of solutions from the archive, combining a hybrid of crossover and mutation operations with a dynamic segment-shuffling mechanism to explore the Pareto front while maintaining feasibility through a node-swap validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Crossover operation\n        other_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n        # Dynamic segment shuffling\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.roll(new_solution[start:end], random.randint(1, segment_size-1))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        while new_solution[i] == new_solution[j]:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7657458585908197,
            1.6785945892333984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Crossover operation\n        other_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n        # Dynamic segment shuffling\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.roll(new_solution[start:end], random.randint(1, segment_size-1))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        while new_solution[i] == new_solution[j]:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This novel heuristic combines a dominance-based selection with a hybrid path inversion and segment relocation operation, incorporating spatial locality analysis to guide the search toward high-quality regions of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(non_dominated_indices)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid path inversion and segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment relocation operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7423801177190942,
            4.600370287895203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a non-dominated solution\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(non_dominated_indices)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid path inversion and segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment relocation operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{A novel local search heuristic that combines adaptive crowding distance selection with a hybrid of edge-insertion and segment-reversal operations, guided by a dynamic trade-off between solution quality and diversity to efficiently explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = np.argmin(np.sum((objectives - objectives[i])**2, axis=1))\n        right = np.argmax(np.sum((objectives - objectives[i])**2, axis=1))\n        crowding_dist[i] = np.sum(objectives[right] - objectives[left])\n\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-insertion: insert a random edge from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        edge = other_solution[a], other_solution[(a+1)%n]\n\n        # Find positions to insert the edge\n        pos1 = np.where(new_solution == edge[0])[0][0]\n        pos2 = np.where(new_solution == edge[1])[0][0]\n\n        # Reverse segment between pos1 and pos2\n        if pos1 > pos2:\n            pos1, pos2 = pos2, pos1\n        new_solution[pos1:pos2+1] = new_solution[pos1:pos2+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6281452832404322,
            10.935255706310272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = np.argmin(np.sum((objectives - objectives[i])**2, axis=1))\n        right = np.argmax(np.sum((objectives - objectives[i])**2, axis=1))\n        crowding_dist[i] = np.sum(objectives[right] - objectives[left])\n\n    selected_idx = np.argmax(crowding_dist)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-insertion: insert a random edge from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        edge = other_solution[a], other_solution[(a+1)%n]\n\n        # Find positions to insert the edge\n        pos1 = np.where(new_solution == edge[0])[0][0]\n        pos2 = np.where(new_solution == edge[1])[0][0]\n\n        # Reverse segment between pos1 and pos2\n        if pos1 > pos2:\n            pos1, pos2 = pos2, pos1\n        new_solution[pos1:pos2+1] = new_solution[pos1:pos2+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines crowding-distance-based selection with a dynamic trade-off-aware segment exchange and node relocation strategy to explore the Pareto front efficiently while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(sorted_objectives))\n        distances[1:-1] = np.sum(np.abs(sorted_objectives[2:] - sorted_objectives[:-2]), axis=1)\n        selected_idx = sorted_indices[np.argmax(distances)]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic trade-off-aware local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic trade-off segment exchange\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n\n        # Calculate trade-off factor based on current objectives\n        obj1, obj2 = archive[selected_idx][1]\n        tradeoff = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n        # Apply segment with probability based on trade-off\n        if random.random() < tradeoff:\n            new_solution[a:b+1] = segment\n\n        # Node relocation with trade-off consideration\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_1[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_2[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n        # Accept move if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{A novel local search heuristic that combines adaptive segment inversion with geometric scaling and node reordering based on the trade-off between objectives, guided by the harmonic mean of the normalized distances in both spaces to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high trade-off potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / objectives.max(axis=0)\n    tradeoff_scores = 2 / (1/normalized_obj[:,0] + 1/normalized_obj[:,1])\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate geometric scaling factor\n        obj1, obj2 = archive[selected_idx][1]\n        scaling_factor = (obj1 + obj2) / (2 * np.sqrt(obj1 * obj2)) if (obj1 * obj2) > 0 else 1.0\n\n        # Apply segment inversion with scaling\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n        # Apply geometric scaling to the inverted segment\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Scale in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            instance[node_idx, :2] = np.array([x1 * scaling_factor, y1 * scaling_factor]) + centroid1\n\n            # Scale in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2:] = np.array([x2 * (1/scaling_factor), y2 * (1/scaling_factor)]) + centroid2\n\n        # Reorder nodes based on trade-off\n        segment_indices = np.where(np.isin(new_solution, segment))[0]\n        segment_objectives = np.array([archive[selected_idx][1] for _ in segment])\n        segment_tradeoffs = 2 / (1/segment_objectives[:,0] + 1/segment_objectives[:,1])\n        new_solution[segment_indices] = segment[np.argsort(segment_tradeoffs)]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Randomly swap two nodes if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            NaN,
            5.680114209651947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high trade-off potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / objectives.max(axis=0)\n    tradeoff_scores = 2 / (1/normalized_obj[:,0] + 1/normalized_obj[:,1])\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate geometric scaling factor\n        obj1, obj2 = archive[selected_idx][1]\n        scaling_factor = (obj1 + obj2) / (2 * np.sqrt(obj1 * obj2)) if (obj1 * obj2) > 0 else 1.0\n\n        # Apply segment inversion with scaling\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n        # Apply geometric scaling to the inverted segment\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Scale in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            instance[node_idx, :2] = np.array([x1 * scaling_factor, y1 * scaling_factor]) + centroid1\n\n            # Scale in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2:] = np.array([x2 * (1/scaling_factor), y2 * (1/scaling_factor)]) + centroid2\n\n        # Reorder nodes based on trade-off\n        segment_indices = np.where(np.isin(new_solution, segment))[0]\n        segment_objectives = np.array([archive[selected_idx][1] for _ in segment])\n        segment_tradeoffs = 2 / (1/segment_objectives[:,0] + 1/segment_objectives[:,1])\n        new_solution[segment_indices] = segment[np.argsort(segment_tradeoffs)]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Randomly swap two nodes if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This novel algorithm combines a Pareto-frontier-based selection of solutions with a hybrid of segment-shifting and node-swapping operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-frontier dominance\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shifting operation\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n        shift_amount = random.randint(1, n - segment_length)\n\n        segment = new_solution[start:end+1]\n        new_solution = np.delete(new_solution, slice(start, end+1))\n        insert_pos = (start + shift_amount) % (n - segment_length)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Node-swapping operation with objective-aware selection\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]]\n\n        if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8234399865208121,
            2.484831392765045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-frontier dominance\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shifting operation\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n        shift_amount = random.randint(1, n - segment_length)\n\n        segment = new_solution[start:end+1]\n        new_solution = np.delete(new_solution, slice(start, end+1))\n        insert_pos = (start + shift_amount) % (n - segment_length)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Node-swapping operation with objective-aware selection\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]]\n\n        if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{A novel local search heuristic combines Pareto frontier-aware solution selection with a dynamic edge insertion and segment rotation operation, guided by a multi-objective improvement criterion to efficiently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Identify Pareto frontier solutions\n    def is_dominated(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    objectives = [obj for _, obj in archive]\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other in objectives:\n            if is_dominated(obj, other):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    # Step 2: Select a solution from Pareto frontier with highest combined diversity\n    selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply dynamic edge insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random positions and rotate the segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n        # Insert a random node at a random position\n        if len(new_solution) < len(instance):\n            node_to_insert = random.choice([node for node in range(len(instance)) if node not in new_solution])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        unique_nodes = set(new_solution)\n        missing_nodes = [node for node in range(len(instance)) if node not in unique_nodes]\n        if missing_nodes:\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, random.choice(missing_nodes))\n\n    return new_solution\n\n",
        "score": [
            -0.5450862786027332,
            4.73192822933197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Identify Pareto frontier solutions\n    def is_dominated(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    objectives = [obj for _, obj in archive]\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other in objectives:\n            if is_dominated(obj, other):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    # Step 2: Select a solution from Pareto frontier with highest combined diversity\n    selected_idx = random.choice(pareto_front)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply dynamic edge insertion and segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random positions and rotate the segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = segment\n\n        # Insert a random node at a random position\n        if len(new_solution) < len(instance):\n            node_to_insert = random.choice([node for node in range(len(instance)) if node not in new_solution])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random insertion if invalid\n        unique_nodes = set(new_solution)\n        missing_nodes = [node for node in range(len(instance)) if node not in unique_nodes]\n        if missing_nodes:\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, random.choice(missing_nodes))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This novel algorithm combines a hybrid selection strategy based on normalized objective scores and a dynamic edge exchange and multi-segment relocation operator to balance exploration and exploitation, leveraging spatial diversity in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using normalized objective scores\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate selection scores\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic edge exchange and multi-segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge exchange operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        k = random.randint(0, n-2)\n        l = random.randint(k+1, n-1)\n\n        # Swap edges\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Multi-segment relocation\n        a = random.randint(0, n-3)\n        b = random.randint(a+1, n-2)\n        c = random.randint(b+1, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8108279743570588,
            4.530377626419067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using normalized objective scores\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate selection scores\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic edge exchange and multi-segment relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge exchange operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        k = random.randint(0, n-2)\n        l = random.randint(k+1, n-1)\n\n        # Swap edges\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Multi-segment relocation\n        a = random.randint(0, n-3)\n        b = random.randint(a+1, n-2)\n        c = random.randint(b+1, n-1)\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a diversity-aware selection of solutions from the archive, followed by a hybrid of path-relinking and node-insertion operations, guided by a dynamic Pareto-based trade-off to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a diverse solution from the archive\n    # Choose a solution with high diversity (far from others in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(np.sum((objectives - objectives.mean(axis=0))**2, axis=1)))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking: randomly select a segment and replace it with a segment from another solution\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n        new_solution[a:b+1] = segment\n\n        # Node-insertion: move a random node to a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This novel local search heuristic combines a dynamic Pareto-based selection of solutions from the archive with a hybrid of segment rotation and node swapping operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum((objectives - objectives.min(axis=0))**2, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation operation\n        k = random.randint(1, n-3)\n        segment = new_solution[k:k+2]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[k:k+2] = rotated_segment\n\n        # Node swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.96775602295776,
            4.494487762451172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum((objectives - objectives.min(axis=0))**2, axis=1))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation operation\n        k = random.randint(1, n-3)\n        segment = new_solution[k:k+2]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[k:k+2] = rotated_segment\n\n        # Node swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This novel algorithm combines a dominance-based selection of solutions from the archive with a hybrid of edge-swapping and segment-shifting operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance\n    dominated_indices = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j:\n                obj_i = archive[i][1]\n                obj_j = archive[j][1]\n                if obj_i[0] >= obj_j[0] and obj_i[1] >= obj_j[1] and (obj_i[0] > obj_j[0] or obj_i[1] > obj_j[1]):\n                    is_dominated = True\n                    break\n        if not is_dominated:\n            dominated_indices.append(i)\n\n    if dominated_indices:\n        selected_idx = random.choice(dominated_indices)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-shifting operation\n        segment_length = random.randint(2, min(4, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n        shift_amount = random.randint(1, min(3, n - segment_length))\n\n        segment = new_solution[start:end+1]\n        if random.random() < 0.5:\n            new_solution[start:end+1] = np.roll(segment, shift_amount)\n        else:\n            new_solution[start:end+1] = np.roll(segment, -shift_amount)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8546206965438832,
            1.9782987833023071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance\n    dominated_indices = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j:\n                obj_i = archive[i][1]\n                obj_j = archive[j][1]\n                if obj_i[0] >= obj_j[0] and obj_i[1] >= obj_j[1] and (obj_i[0] > obj_j[0] or obj_i[1] > obj_j[1]):\n                    is_dominated = True\n                    break\n        if not is_dominated:\n            dominated_indices.append(i)\n\n    if dominated_indices:\n        selected_idx = random.choice(dominated_indices)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment-shifting operation\n        segment_length = random.randint(2, min(4, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n        shift_amount = random.randint(1, min(3, n - segment_length))\n\n        segment = new_solution[start:end+1]\n        if random.random() < 0.5:\n            new_solution[start:end+1] = np.roll(segment, shift_amount)\n        else:\n            new_solution[start:end+1] = np.roll(segment, -shift_amount)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This new algorithm uses a hybrid approach combining adaptive selection based on objective-specific dominance metrics with a novel segment-swap and inversion operator, dynamically adjusting the search focus to under-explored regions of the Pareto front while maintaining feasibility through constrained node swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Adaptive selection based on dominance and objective-specific metrics\n    objectives = [obj for _, obj in archive]\n    n = len(archive)\n\n    # Calculate dominance counts and objective-specific distances\n    dominance_counts = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]:\n                    if objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]:\n                        dominance_counts[i] += 1\n\n    # Calculate objective-specific distances\n    obj1_distances = []\n    obj2_distances = []\n    for i in range(n):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%n][0] if i < n-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%n][1] if i < n-1 else float('inf')\n\n        obj1_distances.append(abs(right_obj1 - left_obj1))\n        obj2_distances.append(abs(right_obj2 - left_obj2))\n\n    # Combine metrics for selection\n    selection_scores = []\n    for i in range(n):\n        score = dominance_counts[i] * 0.5 + (obj1_distances[i] + obj2_distances[i]) * 0.5\n        selection_scores.append(score)\n\n    selected_idx = np.argmax(selection_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search with segment-swap and inversion\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Segment-swap operation\n        a = random.randint(0, n_nodes-1)\n        b = random.randint(0, n_nodes-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n_nodes-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment_length = random.randint(1, min(5, (b - a) // 2))\n        swap_start = random.randint(a, b - segment_length)\n        swap_end = swap_start + segment_length\n\n        # Find another solution for segment swap\n        other_solution = random.choice(archive)[0]\n        other_segment = other_solution[swap_start:swap_end+1]\n\n        # Ensure no duplicates\n        current_nodes = set(new_solution)\n        valid = True\n        for node in other_segment:\n            if node in current_nodes and node not in new_solution[swap_start:swap_end+1]:\n                valid = False\n                break\n\n        if valid:\n            new_solution[swap_start:swap_end+1] = other_segment\n\n        # Segment inversion with objective-aware constraints\n        c = random.randint(0, n_nodes-1)\n        d = random.randint(0, n_nodes-1)\n        while abs(d - c) < 2:\n            d = random.randint(0, n_nodes-1)\n\n        if c > d:\n            c, d = d, c\n\n        # Calculate cost change for inversion\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n_nodes]] for i in range(n_nodes))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n_nodes]] for i in range(n_nodes))\n\n        inverted_segment = new_solution[c:d+1][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[c:d+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n_nodes]] for i in range(n_nodes))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n_nodes]] for i in range(n_nodes))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 1.05) or \\\n           (new_cost1 < current_cost1 * 1.05 and new_cost2 < current_cost2 * 0.95):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n_nodes:\n        # Find duplicate nodes\n        _, counts = np.unique(new_solution, return_counts=True)\n        duplicates = np.where(counts > 1)[0]\n\n        # Replace duplicates with missing nodes\n        all_nodes = set(range(n_nodes))\n        current_nodes = set(new_solution)\n        missing_nodes = list(all_nodes - current_nodes)\n\n        for dup in duplicates:\n            if missing_nodes:\n                replace_pos = np.where(new_solution == dup)[0][1]\n                new_solution[replace_pos] = random.choice(missing_nodes)\n                missing_nodes.remove(new_solution[replace_pos])\n\n    return new_solution\n\n",
        "score": [
            -0.5756796158404898,
            6.613390505313873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Adaptive selection based on dominance and objective-specific metrics\n    objectives = [obj for _, obj in archive]\n    n = len(archive)\n\n    # Calculate dominance counts and objective-specific distances\n    dominance_counts = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]:\n                    if objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]:\n                        dominance_counts[i] += 1\n\n    # Calculate objective-specific distances\n    obj1_distances = []\n    obj2_distances = []\n    for i in range(n):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%n][0] if i < n-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%n][1] if i < n-1 else float('inf')\n\n        obj1_distances.append(abs(right_obj1 - left_obj1))\n        obj2_distances.append(abs(right_obj2 - left_obj2))\n\n    # Combine metrics for selection\n    selection_scores = []\n    for i in range(n):\n        score = dominance_counts[i] * 0.5 + (obj1_distances[i] + obj2_distances[i]) * 0.5\n        selection_scores.append(score)\n\n    selected_idx = np.argmax(selection_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search with segment-swap and inversion\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Segment-swap operation\n        a = random.randint(0, n_nodes-1)\n        b = random.randint(0, n_nodes-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n_nodes-1)\n\n        if a > b:\n            a, b = b, a\n\n        segment_length = random.randint(1, min(5, (b - a) // 2))\n        swap_start = random.randint(a, b - segment_length)\n        swap_end = swap_start + segment_length\n\n        # Find another solution for segment swap\n        other_solution = random.choice(archive)[0]\n        other_segment = other_solution[swap_start:swap_end+1]\n\n        # Ensure no duplicates\n        current_nodes = set(new_solution)\n        valid = True\n        for node in other_segment:\n            if node in current_nodes and node not in new_solution[swap_start:swap_end+1]:\n                valid = False\n                break\n\n        if valid:\n            new_solution[swap_start:swap_end+1] = other_segment\n\n        # Segment inversion with objective-aware constraints\n        c = random.randint(0, n_nodes-1)\n        d = random.randint(0, n_nodes-1)\n        while abs(d - c) < 2:\n            d = random.randint(0, n_nodes-1)\n\n        if c > d:\n            c, d = d, c\n\n        # Calculate cost change for inversion\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n_nodes]] for i in range(n_nodes))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n_nodes]] for i in range(n_nodes))\n\n        inverted_segment = new_solution[c:d+1][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[c:d+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n_nodes]] for i in range(n_nodes))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n_nodes]] for i in range(n_nodes))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 1.05) or \\\n           (new_cost1 < current_cost1 * 1.05 and new_cost2 < current_cost2 * 0.95):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n_nodes:\n        # Find duplicate nodes\n        _, counts = np.unique(new_solution, return_counts=True)\n        duplicates = np.where(counts > 1)[0]\n\n        # Replace duplicates with missing nodes\n        all_nodes = set(range(n_nodes))\n        current_nodes = set(new_solution)\n        missing_nodes = list(all_nodes - current_nodes)\n\n        for dup in duplicates:\n            if missing_nodes:\n                replace_pos = np.where(new_solution == dup)[0][1]\n                new_solution[replace_pos] = random.choice(missing_nodes)\n                missing_nodes.remove(new_solution[replace_pos])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility, but introduces a novel segment cross operation that swaps segments between two randomly selected solutions in the archive to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select two solutions based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[:2]\n    sol1, sol2 = selected_solutions[0][0].copy(), selected_solutions[1][0].copy()\n\n    # Step 2: Apply segment cross operation\n    n = len(sol1)\n    if n > 3:\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        min_k, max_k = min(k, l), max(k, l)\n        new_solution = np.concatenate([sol1[:min_k], sol2[min_k:max_k], sol1[max_k:]])\n    else:\n        new_solution = sol1.copy()\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            idx = random.randint(0, n-1)\n            new_solution[idx] = node\n\n    return new_solution\n\n",
        "score": [
            -0.7360233586689495,
            3.5513115525245667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select two solutions based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solutions = sorted(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[:2]\n    sol1, sol2 = selected_solutions[0][0].copy(), selected_solutions[1][0].copy()\n\n    # Step 2: Apply segment cross operation\n    n = len(sol1)\n    if n > 3:\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        min_k, max_k = min(k, l), max(k, l)\n        new_solution = np.concatenate([sol1[:min_k], sol2[min_k:max_k], sol1[max_k:]])\n    else:\n        new_solution = sol1.copy()\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            idx = random.randint(0, n-1)\n            new_solution[idx] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm combines a non-dominated sorting-based selection with a hybrid of segment-shuffling and objective-aware edge swaps, dynamically adjusting the search intensity based on objective space dominance while maintaining feasibility through constrained edge operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting and selection\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1] and\n                    (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1])):\n                    dominating_sets[i].append(j)\n                elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                      (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                    dominated_counts[i] += 1\n\n    fronts.append([i for i in range(len(archive)) if dominated_counts[i] == 0])\n    current_front = 0\n\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shuffling operation\n        segment_length = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        random.shuffle(segment)\n        new_solution[start:end] = segment\n\n        # Objective-aware edge swap\n        for _ in range(min(3, n//2)):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i:\n                j = random.randint(0, n-1)\n\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate improvement potential\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            delta1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                     distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]) - \\\n                    (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                     distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n\n            delta2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                     distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]) - \\\n                    (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                     distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            if (delta1 <= 0 and delta2 <= 0) or (random.random() < 0.3):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8676160337719268,
            2.549205958843231
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting and selection\n    objectives = [obj for _, obj in archive]\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1] and\n                    (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1])):\n                    dominating_sets[i].append(j)\n                elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                      (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                    dominated_counts[i] += 1\n\n    fronts.append([i for i in range(len(archive)) if dominated_counts[i] == 0])\n    current_front = 0\n\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment-shuffling operation\n        segment_length = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        random.shuffle(segment)\n        new_solution[start:end] = segment\n\n        # Objective-aware edge swap\n        for _ in range(min(3, n//2)):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i:\n                j = random.randint(0, n-1)\n\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate improvement potential\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            delta1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                     distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]) - \\\n                    (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                     distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n\n            delta2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                     distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]) - \\\n                    (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                     distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            if (delta1 <= 0 and delta2 <= 0) or (random.random() < 0.3):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel local search heuristic combines a dynamic objective-based selection of solutions from the archive with a hybrid of segment inversion and node relocation operations, guided by an adaptive trade-off between the two objectives to explore the Pareto front while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dynamic objective trade-off\n    weights = np.random.dirichlet([1, 1])\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion operation\n        k = random.randint(1, n-2)\n        l = random.randint(1, n-2)\n        while k == l:\n            l = random.randint(1, n-2)\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n        # Node relocation operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This novel local search heuristic employs a dynamic Pareto-dominance guided selection of solutions from the archive, followed by a hybrid of adaptive segment inversion and multi-node relocation operations, with an adaptive weighting scheme to balance exploration and exploitation across the Pareto front while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance guided selection\n    def dominance_score(sol):\n        dominated = 0\n        for other in archive:\n            if (other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and\n                (other[1][0] < sol[1][0] or other[1][1] < sol[1][1])):\n                dominated += 1\n        return dominated\n\n    selected = min(archive, key=lambda x: dominance_score(x))[0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive operations\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion\n        segment_size = min(random.randint(2, n//2), n-2)\n        start = random.randint(0, n-segment_size-1)\n        segment = new_solution[start:start+segment_size]\n        if random.random() < 0.7:\n            new_solution[start:start+segment_size] = segment[::-1]\n        else:\n            new_solution[start:start+segment_size] = np.roll(segment, random.randint(1, segment_size-1))\n\n        # Multi-node relocation\n        num_relocations = random.randint(1, min(3, n//2))\n        for _ in range(num_relocations):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while i == j:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7310893115100172,
            1.5722808837890625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on Pareto-dominance guided selection\n    def dominance_score(sol):\n        dominated = 0\n        for other in archive:\n            if (other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and\n                (other[1][0] < sol[1][0] or other[1][1] < sol[1][1])):\n                dominated += 1\n        return dominated\n\n    selected = min(archive, key=lambda x: dominance_score(x))[0].copy()\n\n    # Step 2: Apply hybrid local search with adaptive operations\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion\n        segment_size = min(random.randint(2, n//2), n-2)\n        start = random.randint(0, n-segment_size-1)\n        segment = new_solution[start:start+segment_size]\n        if random.random() < 0.7:\n            new_solution[start:start+segment_size] = segment[::-1]\n        else:\n            new_solution[start:start+segment_size] = np.roll(segment, random.randint(1, segment_size-1))\n\n        # Multi-node relocation\n        num_relocations = random.randint(1, min(3, n//2))\n        for _ in range(num_relocations):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while i == j:\n                j = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic selects solutions based on their dominance count and applies a geometric transformation operator that combines node rotation and mirroring, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high dominance count\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply geometric transformation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to transform\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid of the segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Apply rotation and mirroring\n        angle = random.uniform(0, 2*np.pi)\n        cos_theta, sin_theta = np.cos(angle), np.sin(angle)\n        rotation_matrix = np.array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            x1_new, y1_new = rotation_matrix @ np.array([x1, y1])\n            instance[node_idx, :2] = np.array([x1_new, y1_new]) + centroid1\n\n            # Mirror in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2] = x2 * (1 if random.random() > 0.5 else -1) + centroid2[0]\n            instance[node_idx, 3] = y2 * (1 if random.random() > 0.5 else -1) + centroid2[1]\n\n        # Rebuild the solution with transformed nodes\n        new_solution[a:b+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with balanced quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.max(objectives, axis=1)  # Simple quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores + diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{A novel local search heuristic selects solutions based on their Pareto-frontier proximity and applies a hybrid of node reinsertion and geometric scaling, guided by the geometric properties of the nodes' positions in both objective spaces to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_frontier = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_frontier.append(i)\n\n    if not pareto_frontier:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(pareto_frontier)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid geometric scaling and reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Find insertion point based on geometric scaling\n        node_coords1 = instance[node, :2]\n        node_coords2 = instance[node, 2:]\n\n        min_dist = float('inf')\n        best_pos = 0\n\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n\n            # Calculate scaled distance in both spaces\n            dist1 = np.linalg.norm(instance[prev_node, :2] - node_coords1) + np.linalg.norm(node_coords1 - instance[curr_node, :2])\n            dist2 = np.linalg.norm(instance[prev_node, 2:] - node_coords2) + np.linalg.norm(node_coords2 - instance[curr_node, 2:])\n            scaled_dist = dist1 * 0.7 + dist2 * 0.3  # Weighted sum\n\n            if scaled_dist < min_dist:\n                min_dist = scaled_dist\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Apply geometric scaling to a random segment\n        a, b = sorted(random.sample(range(n-1), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Scale segment\n        scale_factor = random.uniform(0.8, 1.2)\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            instance[node_idx, :2] = centroid1 + (instance[node_idx, :2] - centroid1) * scale_factor\n            instance[node_idx, 2:] = centroid2 + (instance[node_idx, 2:] - centroid2) * scale_factor\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5308741141403519,
            5.903447449207306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    pareto_frontier = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_frontier.append(i)\n\n    if not pareto_frontier:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(pareto_frontier)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid geometric scaling and reinsertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Find insertion point based on geometric scaling\n        node_coords1 = instance[node, :2]\n        node_coords2 = instance[node, 2:]\n\n        min_dist = float('inf')\n        best_pos = 0\n\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n\n            # Calculate scaled distance in both spaces\n            dist1 = np.linalg.norm(instance[prev_node, :2] - node_coords1) + np.linalg.norm(node_coords1 - instance[curr_node, :2])\n            dist2 = np.linalg.norm(instance[prev_node, 2:] - node_coords2) + np.linalg.norm(node_coords2 - instance[curr_node, 2:])\n            scaled_dist = dist1 * 0.7 + dist2 * 0.3  # Weighted sum\n\n            if scaled_dist < min_dist:\n                min_dist = scaled_dist\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Apply geometric scaling to a random segment\n        a, b = sorted(random.sample(range(n-1), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate centroid in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        # Scale segment\n        scale_factor = random.uniform(0.8, 1.2)\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            instance[node_idx, :2] = centroid1 + (instance[node_idx, :2] - centroid1) * scale_factor\n            instance[node_idx, 2:] = centroid2 + (instance[node_idx, 2:] - centroid2) * scale_factor\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines crowding-distance-based selection with a dynamic trade-off-aware segment exchange and node relocation strategy to explore the Pareto front efficiently while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(sorted_objectives))\n        distances[1:-1] = np.sum(np.abs(sorted_objectives[2:] - sorted_objectives[:-2]), axis=1)\n        selected_idx = sorted_indices[np.argmax(distances)]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic trade-off-aware local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Dynamic trade-off segment exchange\n        other_solution = random.choice(archive)[0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b+1]\n\n        # Calculate trade-off factor based on current objectives\n        obj1, obj2 = archive[selected_idx][1]\n        tradeoff = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n        # Apply segment with probability based on trade-off\n        if random.random() < tradeoff:\n            new_solution[a:b+1] = segment\n\n        # Node relocation with trade-off consideration\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        old_dist1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist1 = distance_matrix_1[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_1[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n        old_dist2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n        new_dist2 = distance_matrix_2[new_solution[(current_pos-1)%n], new_solution[(current_pos+1)%n]] + \\\n                   distance_matrix_2[new_solution[(current_pos-1)%n], node_to_move] + \\\n                   distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n        # Accept move if it improves at least one objective\n        if (new_dist1 < old_dist1 and new_dist2 <= old_dist2) or \\\n           (new_dist2 < old_dist2 and new_dist1 <= old_dist1):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random insertion if invalid\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This novel algorithm combines a dominance-based selection with a hybrid of path-segment rotation and node reinsertion, dynamically balancing objective improvements through a multi-criteria acceptance mechanism while ensuring feasibility through a hierarchical validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate dominance counts\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    # Select solution with highest dominance count\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[c-b:], segment[:c-b]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Node reinsertion with multi-criteria acceptance\n        node_to_move = new_solution[random.randint(0, n-1)]\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        # Evaluate potential insertion points\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n-1):\n            # Calculate potential improvement\n            old_dist1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + \\\n                       distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            new_dist1 = distance_matrix_1[new_solution[pos-1], node_to_move] + \\\n                       distance_matrix_1[node_to_move, new_solution[(pos+1)%(n-1)]] + \\\n                       distance_matrix_1[new_solution[pos-1], new_solution[(pos+1)%(n-1)]]\n\n            old_dist2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + \\\n                       distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            new_dist2 = distance_matrix_2[new_solution[pos-1], node_to_move] + \\\n                       distance_matrix_2[node_to_move, new_solution[(pos+1)%(n-1)]] + \\\n                       distance_matrix_2[new_solution[pos-1], new_solution[(pos+1)%(n-1)]]\n\n            # Multi-criteria improvement score\n            improvement = (new_dist1 - old_dist1) + (new_dist2 - old_dist2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Step 3: Hierarchical validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8402933177643181,
            4.8985894322395325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution based on dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate dominance counts\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    # Select solution with highest dominance count\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[c-b:], segment[:c-b]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Node reinsertion with multi-criteria acceptance\n        node_to_move = new_solution[random.randint(0, n-1)]\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, current_pos)\n\n        # Evaluate potential insertion points\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n-1):\n            # Calculate potential improvement\n            old_dist1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + \\\n                       distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            new_dist1 = distance_matrix_1[new_solution[pos-1], node_to_move] + \\\n                       distance_matrix_1[node_to_move, new_solution[(pos+1)%(n-1)]] + \\\n                       distance_matrix_1[new_solution[pos-1], new_solution[(pos+1)%(n-1)]]\n\n            old_dist2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + \\\n                       distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            new_dist2 = distance_matrix_2[new_solution[pos-1], node_to_move] + \\\n                       distance_matrix_2[node_to_move, new_solution[(pos+1)%(n-1)]] + \\\n                       distance_matrix_2[new_solution[pos-1], new_solution[(pos+1)%(n-1)]]\n\n            # Multi-criteria improvement score\n            improvement = (new_dist1 - old_dist1) + (new_dist2 - old_dist2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Step 3: Hierarchical validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines a crowding-distance-based selection of solutions from the archive with a hybrid of path-relinking and segment-reversal operations, dynamically balancing the exploration of trade-off regions by leveraging objective-specific distance metrics to guide the search toward diverse Pareto-optimal regions while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left_obj1 = objectives[i-1][0] if i > 0 else float('inf')\n        right_obj1 = objectives[(i+1)%len(objectives)][0] if i < len(objectives)-1 else float('inf')\n        left_obj2 = objectives[i-1][1] if i > 0 else float('inf')\n        right_obj2 = objectives[(i+1)%len(objectives)][1] if i < len(objectives)-1 else float('inf')\n\n        dist1 = abs(right_obj1 - left_obj1)\n        dist2 = abs(right_obj2 - left_obj2)\n        crowding_distances.append(dist1 + dist2)\n\n    if all(d == 0 for d in crowding_distances):\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        max_dist = max(crowding_distances)\n        candidates = [i for i, d in enumerate(crowding_distances) if d == max_dist]\n        selected_idx = random.choice(candidates)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path-relinking operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Determine segment to replace\n        segment_length = random.randint(1, min(5, n//2))\n        start = min(i, j)\n        end = start + segment_length\n        if end >= n:\n            end = n - 1\n            start = end - segment_length\n\n        # Create new segment from other solution\n        other_solution = random.choice(archive)[0]\n        other_nodes = set(other_solution[start:end+1])\n        current_nodes = set(new_solution[start:end+1])\n        missing_nodes = list(other_nodes - current_nodes)\n\n        if missing_nodes:\n            replace_pos = random.randint(start, end)\n            new_solution[replace_pos] = random.choice(missing_nodes)\n\n        # Segment reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This novel algorithm combines a dominance-based selection of solutions with a hybrid of node-swap and segment-rotation operations, dynamically balancing exploration of the Pareto front by leveraging both objective-specific distance metrics and spatial locality in the two coordinate spaces to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominance_count = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_count[i] += 1\n\n    if np.max(dominance_count) > 0:\n        candidates = np.where(dominance_count == np.max(dominance_count))[0]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swap operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while a == b:\n            b = random.randint(0, n-1)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment rotation operation\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7987528885766708,
            3.437288999557495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution based on dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominance_count = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_count[i] += 1\n\n    if np.max(dominance_count) > 0:\n        candidates = np.where(dominance_count == np.max(dominance_count))[0]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node-swap operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while a == b:\n            b = random.randint(0, n-1)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment rotation operation\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that combines adaptive segment inversion with geometric scaling and node reordering based on the trade-off between objectives, guided by the harmonic mean of the normalized distances in both spaces to balance exploration and exploitation while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high trade-off potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / objectives.max(axis=0)\n    tradeoff_scores = 2 / (1/normalized_obj[:,0] + 1/normalized_obj[:,1])\n    selected_idx = np.argmax(tradeoff_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate geometric scaling factor\n        obj1, obj2 = archive[selected_idx][1]\n        scaling_factor = (obj1 + obj2) / (2 * np.sqrt(obj1 * obj2)) if (obj1 * obj2) > 0 else 1.0\n\n        # Apply segment inversion with scaling\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n        # Apply geometric scaling to the inverted segment\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            # Scale in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            instance[node_idx, :2] = np.array([x1 * scaling_factor, y1 * scaling_factor]) + centroid1\n\n            # Scale in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            instance[node_idx, 2:] = np.array([x2 * (1/scaling_factor), y2 * (1/scaling_factor)]) + centroid2\n\n        # Reorder nodes based on trade-off\n        segment_indices = np.where(np.isin(new_solution, segment))[0]\n        segment_objectives = np.array([archive[selected_idx][1] for _ in segment])\n        segment_tradeoffs = 2 / (1/segment_objectives[:,0] + 1/segment_objectives[:,1])\n        new_solution[segment_indices] = segment[np.argsort(segment_tradeoffs)]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Randomly swap two nodes if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm combines a Pareto-dominance guided selection with a novel adaptive segment rotation operator that dynamically adjusts the rotation angle based on the trade-off between objectives, while maintaining feasibility through a geometric transformation validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto dominance and trade-off\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Select from Pareto front with highest trade-off\n        pareto_objectives = objectives[pareto_front]\n        tradeoff_scores = 2 / (1/pareto_objectives[:,0] + 1/pareto_objectives[:,1])\n        selected_idx = pareto_front[np.argmax(tradeoff_scores)]\n    else:\n        # Fallback to highest trade-off in general population\n        tradeoff_scores = 2 / (1/objectives[:,0] + 1/objectives[:,1])\n        selected_idx = np.argmax(tradeoff_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate rotation angle based on trade-off\n        obj1, obj2 = archive[selected_idx][1]\n        angle = np.arctan2(obj2, obj1) * (180 / np.pi)\n\n        # Rotate segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            rad = np.radians(angle)\n            x1_rot = x1 * np.cos(rad) - y1 * np.sin(rad)\n            y1_rot = x1 * np.sin(rad) + y1 * np.cos(rad)\n            instance[node_idx, :2] = np.array([x1_rot, y1_rot]) + centroid1\n\n            # Rotate in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            rad = np.radians(-angle)  # Opposite rotation\n            x2_rot = x2 * np.cos(rad) - y2 * np.sin(rad)\n            y2_rot = x2 * np.sin(rad) + y2 * np.cos(rad)\n            instance[node_idx, 2:] = np.array([x2_rot, y2_rot]) + centroid2\n\n        # Reorder nodes based on rotated positions\n        rotated_coords1 = instance[segment, :2]\n        rotated_coords2 = instance[segment, 2:]\n        combined_dist = np.sum(distance_matrix_1[np.ix_(segment, segment)], axis=1) + np.sum(distance_matrix_2[np.ix_(segment, segment)], axis=1)\n        new_solution[a:b+1] = segment[np.argsort(combined_dist)]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Randomly swap two nodes if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6753741669889893,
            3.2045633792877197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using Pareto dominance and trade-off\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Select from Pareto front with highest trade-off\n        pareto_objectives = objectives[pareto_front]\n        tradeoff_scores = 2 / (1/pareto_objectives[:,0] + 1/pareto_objectives[:,1])\n        selected_idx = pareto_front[np.argmax(tradeoff_scores)]\n    else:\n        # Fallback to highest trade-off in general population\n        tradeoff_scores = 2 / (1/objectives[:,0] + 1/objectives[:,1])\n        selected_idx = np.argmax(tradeoff_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate rotation angle based on trade-off\n        obj1, obj2 = archive[selected_idx][1]\n        angle = np.arctan2(obj2, obj1) * (180 / np.pi)\n\n        # Rotate segment in both spaces\n        centroid1 = instance[segment, :2].mean(axis=0)\n        centroid2 = instance[segment, 2:].mean(axis=0)\n\n        for i in range(len(segment)):\n            node_idx = segment[i]\n\n            # Rotate in first space\n            x1, y1 = instance[node_idx, :2] - centroid1\n            rad = np.radians(angle)\n            x1_rot = x1 * np.cos(rad) - y1 * np.sin(rad)\n            y1_rot = x1 * np.sin(rad) + y1 * np.cos(rad)\n            instance[node_idx, :2] = np.array([x1_rot, y1_rot]) + centroid1\n\n            # Rotate in second space\n            x2, y2 = instance[node_idx, 2:] - centroid2\n            rad = np.radians(-angle)  # Opposite rotation\n            x2_rot = x2 * np.cos(rad) - y2 * np.sin(rad)\n            y2_rot = x2 * np.sin(rad) + y2 * np.cos(rad)\n            instance[node_idx, 2:] = np.array([x2_rot, y2_rot]) + centroid2\n\n        # Reorder nodes based on rotated positions\n        rotated_coords1 = instance[segment, :2]\n        rotated_coords2 = instance[segment, 2:]\n        combined_dist = np.sum(distance_matrix_1[np.ix_(segment, segment)], axis=1) + np.sum(distance_matrix_2[np.ix_(segment, segment)], axis=1)\n        new_solution[a:b+1] = segment[np.argsort(combined_dist)]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Randomly swap two nodes if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic combines a quality-diversity trade-off selection of solutions from the archive, followed by a dynamic segment reversal and edge contraction operation, guided by a Pareto-based objective improvement criterion to explore the solution space efficiently while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality_scores = np.sum(objectives, axis=1)  # Sum of objectives as quality metric\n    diversity_scores = np.linalg.norm(objectives - objectives.mean(axis=0), axis=1)\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3  # Weighted combination\n    selected_idx = np.argmin(combined_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply dynamic segment reversal and edge contraction\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Contract two random edges by removing one node between them\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            remove_pos = random.randint(i+1, j-1)\n            new_solution = np.delete(new_solution, remove_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel heuristic combines a crowding-distance based selection with a dynamic path inversion and segment transposition operation to balance exploration and exploitation, leveraging spatial locality in both objective spaces to guide the search towards high-quality regions of the Pareto front while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic path inversion and segment transposition\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Path inversion operation\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment transposition operation\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        c = random.randint(0, n-2)\n        d = random.randint(c+1, n-1)\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This novel heuristic combines a Pareto-dominance guided selection with a dynamic node reinsertion and edge flipping operation, leveraging both spatial and objective-space locality to explore high-potential regions of the solution space while maintaining feasibility through constrained random perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance and objective-space distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify non-dominated solutions\n    is_dominated = np.zeros(len(objectives), dtype=bool)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    non_dominated_idx = np.where(~is_dominated)[0]\n    if len(non_dominated_idx) == 0:\n        # If no non-dominated solutions, select the one with minimal sum of objectives\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n    else:\n        # Among non-dominated, select the one with highest objective-space distance to others\n        distances = np.zeros(len(non_dominated_idx))\n        for i, idx in enumerate(non_dominated_idx):\n            distances[i] = np.min(np.linalg.norm(objectives[non_dominated_idx] - objectives[idx], axis=1))\n        selected_idx = non_dominated_idx[np.argmax(distances)]\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic node reinsertion and edge flipping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node reinsertion operation\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge flipping operation\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8089666809816468,
            2.5760228037834167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution using Pareto-dominance and objective-space distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify non-dominated solutions\n    is_dominated = np.zeros(len(objectives), dtype=bool)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    non_dominated_idx = np.where(~is_dominated)[0]\n    if len(non_dominated_idx) == 0:\n        # If no non-dominated solutions, select the one with minimal sum of objectives\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n    else:\n        # Among non-dominated, select the one with highest objective-space distance to others\n        distances = np.zeros(len(non_dominated_idx))\n        for i, idx in enumerate(non_dominated_idx):\n            distances[i] = np.min(np.linalg.norm(objectives[non_dominated_idx] - objectives[idx], axis=1))\n        selected_idx = non_dominated_idx[np.argmax(distances)]\n\n    selected_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply dynamic node reinsertion and edge flipping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node reinsertion operation\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Edge flipping operation\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that combines a crowding-distance guided selection of solutions with a hybrid of edge-swapping and path-reversal operations, dynamically adjusting the trade-off between objectives while ensuring feasibility through a multi-stage validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select solution using crowding distance\n    crowding_distances = []\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        sorted_objectives = objectives[sorted_indices, obj_idx]\n        crowding = np.zeros(len(sorted_objectives))\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, len(sorted_objectives)-1):\n            crowding[i] = abs(sorted_objectives[i+1] - sorted_objectives[i-1])\n        crowding_distances.append(crowding[np.argsort(sorted_indices)])\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    max_crowding_idx = np.argmax(total_crowding)\n    selected_solution = solutions[max_crowding_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-swapping operation\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-2)\n\n        # Swap edges (i,i+1) and (j,j+1)\n        segment1 = new_solution[i:i+2]\n        segment2 = new_solution[j:j+2]\n        new_solution[i:i+2] = segment2[::-1]\n        new_solution[j:j+2] = segment1[::-1]\n\n        # Path-reversal operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        while abs(b - a) < 2:\n            b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Multi-stage validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{An adaptive local search heuristic that combines non-dominated sorting with a dynamic edge-insertion and segment-shifting strategy, balancing exploration and exploitation by leveraging both objective-specific distance matrices to guide the search while maintaining feasibility through a hierarchical validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting to select promising solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Find non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                if any(objectives[j] < objectives[i]):\n                    is_dominated[i] = True\n                    break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    selected_idx = random.choice(non_dominated_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Dynamic edge-insertion and segment-shifting\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        # Segment-shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        shift = random.randint(1, min(3, n-1))\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Insert shifted segment at new position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Hierarchical validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment rotation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random insertion\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    return new_solution\n\n",
        "score": [
            -0.5818412474115184,
            0.7314527630805969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Non-dominated sorting to select promising solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Find non-dominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                if any(objectives[j] < objectives[i]):\n                    is_dominated[i] = True\n                    break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    selected_idx = random.choice(non_dominated_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Dynamic edge-insertion and segment-shifting\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-insertion operation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while abs(j - i) < 2:\n            j = random.randint(0, n-1)\n\n        if i > j:\n            i, j = j, i\n\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        # Segment-shifting operation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        shift = random.randint(1, min(3, n-1))\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Insert shifted segment at new position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Hierarchical validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment rotation\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if len(np.unique(new_solution)) != n:\n        # Final fallback to random insertion\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    return new_solution\n\n"
    }
]