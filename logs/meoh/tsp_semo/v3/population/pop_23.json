[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            6.369828450537811,
            5.631717197948714
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.3 + 0.4 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Node relocation with probabilistic edge swapping\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.2 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    # Segment inversion with adaptive probability\n    if np.random.rand() < 0.2 + 0.3 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.410972004000388,
            5.612202811021727
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with equal weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.120311480775534,
            5.790523628268353
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.678733823516097,
            6.312686110122009
        ]
    }
]