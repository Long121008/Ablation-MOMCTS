[
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search combining node relocation with a dynamic segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Determine insertion position based on both distance matrices\n        costs = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            costs.append(cost1 + cost2)\n\n        # Insert at position that minimizes the combined cost\n        insert_pos = np.argmin(costs)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Apply dynamic segment inversion based on cost improvement\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost difference for inversion\n        prev_node = new_solution[start-1]\n        next_node = new_solution[end+1] if (end+1) < n else new_solution[0]\n        cost1_before = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        cost1_after = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n        cost2_before = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n        cost2_after = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.2320630997998165,
            6.8175123747628295
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining edge insertion with a dynamic subtour reordering strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random edge to remove and reinsert\n        edge_start = np.random.randint(0, n)\n        edge_end = (edge_start + 1) % n\n        node1, node2 = new_solution[edge_start], new_solution[edge_end]\n        new_solution = np.delete(new_solution, [edge_start, edge_end])\n\n        # Find best insertion position for the removed nodes\n        costs = []\n        for i in range(len(new_solution) + 1):\n            if i == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i] if i < len(new_solution) else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node1] + distance_matrix_1[node1, node2] + distance_matrix_1[node2, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node1] + distance_matrix_2[node1, node2] + distance_matrix_2[node2, next_node] - distance_matrix_2[prev_node, next_node]\n            costs.append(cost1 + cost2)\n\n        insert_pos = np.argmin(costs)\n        if insert_pos == len(new_solution):\n            new_solution = np.append(new_solution, [node1, node2])\n        else:\n            new_solution = np.insert(new_solution, insert_pos, [node1, node2])\n\n        # Apply dynamic subtour reordering based on cost improvement\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 1, n)\n        segment = new_solution[segment_start:segment_end+1]\n        reversed_segment = segment[::-1]\n\n        prev_node = new_solution[segment_start-1] if segment_start > 0 else new_solution[-1]\n        next_node = new_solution[segment_end+1] if segment_end+1 < n else new_solution[0]\n\n        cost1_before = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        cost1_after = distance_matrix_1[prev_node, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_node]\n        cost2_before = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n        cost2_after = distance_matrix_2[prev_node, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_node]\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[segment_start:segment_end+1] = reversed_segment\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.228070732300494,
            5.938902591764764
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel scoring function that considers both objective values and the diversity of the solution, then applies a hybrid local search combining node relocation and segment inversion, guided by a weighted combination of distances from both objectives, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and diversity)\n    def score(sol_obj):\n        sol, obj = sol_obj\n        # Weighted combination of objectives and solution diversity\n        return (obj[0] + obj[1]) * 0.7 + (len(set(sol)) / len(sol)) * 0.3\n\n    selected_solution = min(archive, key=score)[0].copy()\n\n    # Hybrid local search: Node relocation and segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Node relocation: Move a node to a position that reduces weighted distance\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i == node_idx or i == (node_idx - 1) % n or i == (node_idx + 1) % n:\n                continue\n\n            # Weighted cost calculation\n            prev_node = new_solution[(i - 1) % n]\n            next_node = new_solution[i]\n            cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) * 0.6 + \\\n                   (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]) * 0.4\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Segment inversion: Invert a segment if it reduces weighted distance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        # Calculate weighted cost before inversion\n        cost_before = (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]]) * 0.6 + \\\n                      (distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]) * 0.4\n\n        # Calculate weighted cost after inversion\n        cost_after = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]) * 0.6 + \\\n                     (distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]) * 0.4\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.971702591740229,
            6.250890165802183
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a tournament selection based on Pareto dominance, then applies a hybrid local search combining randomized k-opt moves (for k=3) and path relinking with guidance from the combined objective-specific distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), tournament_size, replace=False)\n    selected_solutions = [archive[i] for i in selected_indices]\n\n    # Select the solution with best combined objective\n    selected_solution = min(selected_solutions, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt move with combined objective guidance\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        # Try all possible 3-opt configurations\n        configurations = [\n            (a, b, c),\n            (a, c, b),\n            (b, a, c),\n            (b, c, a),\n            (c, a, b),\n            (c, b, a)\n        ]\n\n        best_cost = float('inf')\n        best_config = None\n\n        for config in configurations:\n            temp_solution = new_solution.copy()\n            temp_solution[config[0]:config[1]] = temp_solution[config[0]:config[1]][::-1]\n            temp_solution[config[1]:config[2]] = temp_solution[config[1]:config[2]][::-1]\n\n            cost = 0\n            for i in range(n):\n                cost += distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i-1], temp_solution[i]]\n\n            if cost < best_cost:\n                best_cost = cost\n                best_config = config\n\n        if best_config is not None:\n            new_solution[best_config[0]:best_config[1]] = new_solution[best_config[0]:best_config[1]][::-1]\n            new_solution[best_config[1]:best_config[2]] = new_solution[best_config[1]:best_config[2]][::-1]\n\n    # Path relinking with combined objective guidance\n    if n > 3 and len(archive) > 1:\n        target_solution = archive[np.random.choice(len(archive))][0]\n        for i in range(n):\n            if new_solution[i] != target_solution[i]:\n                # Find the position of target_solution[i] in new_solution\n                pos = np.where(new_solution == target_solution[i])[0][0]\n                # Calculate cost before and after swap\n                cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                             distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n                cost_after = distance_matrix_1[new_solution[i-1], target_solution[i]] + distance_matrix_2[new_solution[i-1], target_solution[i]] + \\\n                             distance_matrix_1[new_solution[pos-1], new_solution[i]] + distance_matrix_2[new_solution[pos-1], new_solution[i]]\n\n                if cost_after < cost_before:\n                    new_solution[i], new_solution[pos] = new_solution[pos], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            6.103403477041013,
            5.95314481229739
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a promising solution from the archive, applies a randomized edge-swap and segment-reversal hybrid operator to generate a neighbor solution while ensuring feasibility, and balances exploration and exploitation by leveraging both objective-specific distance matrices to guide the search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good trade-off between objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with objective guidance\n    if n > 3:\n        # Choose a segment to reverse based on high edge cost\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        # Decide reversal based on combined distance cost\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility (permutation)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.696815469537818,
            6.918070498217975
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node relocation with a dynamic segment rotation strategy to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to rotate\n        segment_start = np.random.randint(0, n - 2)\n        segment_length = np.random.randint(2, min(4, n - segment_start))\n        segment = new_solution[segment_start:segment_start + segment_length]\n\n        # Rotate the segment\n        rotated_segment = np.roll(segment, 1)\n\n        # Calculate cost difference for rotation\n        prev_node = new_solution[segment_start - 1] if segment_start > 0 else new_solution[-1]\n        next_node = new_solution[segment_start + segment_length] if (segment_start + segment_length) < n else new_solution[0]\n        cost1_before = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        cost1_after = distance_matrix_1[prev_node, rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], next_node]\n        cost2_before = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n        cost2_after = distance_matrix_2[prev_node, rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], next_node]\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[segment_start:segment_start + segment_length] = rotated_segment\n\n        # Apply node relocation based on both distance matrices\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        costs = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            costs.append(cost1 + cost2)\n\n        insert_pos = np.argmin(costs)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.988045360266611,
            6.283820815791001
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement by evaluating both objective values and applies a novel hybrid local search combining node relinking and path inversion, guided by the combined distance metrics from both objectives, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined objective cost)\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Node relinking and path inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Node relinking: Relocate a node to a position that reduces combined distance\n    if n > 2:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find the best insertion position based on combined distance\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(n):\n            if i == node_idx or i == (node_idx - 1) % n or i == (node_idx + 1) % n:\n                continue  # Skip adjacent positions to maintain tour structure\n\n            # Calculate cost of inserting node before position i\n            prev_node = new_solution[(i - 1) % n]\n            next_node = new_solution[i]\n            cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                   distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove the node and insert it at the best position\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Path inversion: Invert a segment if it reduces combined distance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        # Calculate cost before inversion\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after inversion\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility (permutation)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            6.218180912611799,
            6.194297664309102
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement by considering both objective values and dominance rank, then applies a novel hybrid local search combining adaptive segment swapping, dynamic node insertion, and probabilistic edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['segment_swap', 'dynamic_insertion', 'probabilistic_reversal'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'segment_swap':\n            # Adaptive segment swapping\n            segment_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - segment_length)\n            start2 = np.random.randint(0, n - segment_length)\n            while abs(start1 - start2) < segment_length:\n                start2 = np.random.randint(0, n - segment_length)\n\n            segment1 = new_solution[start1:start1+segment_length]\n            segment2 = new_solution[start2:start2+segment_length]\n            new_solution[start1:start1+segment_length] = segment2\n            new_solution[start2:start2+segment_length] = segment1\n\n        elif operation == 'dynamic_insertion':\n            # Dynamic node insertion based on both objectives\n            node = new_solution[np.random.randint(0, n)]\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position that minimizes the combined cost\n            insert_pos = np.argmin(costs)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Probabilistic edge reversal\n            for _ in range(min(3, n//2)):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i != j and abs(i - j) > 1:\n                    # Calculate cost difference\n                    cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                                 distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                                (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                 distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                    cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                                 distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                                (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                 distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                    if weights[0]*cost_diff_1 + weights[1]*cost_diff_2 < 0:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.265006812840178,
            6.127225222954669
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search combining node relocation with a dynamic segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Determine insertion position based on both distance matrices\n        costs = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            costs.append(cost1 + cost2)\n\n        # Insert at position that minimizes the combined cost\n        insert_pos = np.argmin(costs)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Apply dynamic segment inversion based on cost improvement\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost difference for inversion\n        prev_node = new_solution[start-1]\n        next_node = new_solution[end+1] if (end+1) < n else new_solution[0]\n        cost1_before = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        cost1_after = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n        cost2_before = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n        cost2_after = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.2320630997998165,
            6.8175123747628295
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search combining node relocation with a dynamic segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Determine insertion position based on both distance matrices\n        costs = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            costs.append(cost1 + cost2)\n\n        # Insert at position that minimizes the combined cost\n        insert_pos = np.argmin(costs)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Apply dynamic segment inversion based on cost improvement\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost difference for inversion\n        prev_node = new_solution[start-1]\n        next_node = new_solution[end+1] if (end+1) < n else new_solution[0]\n        cost1_before = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        cost1_after = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n        cost2_before = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n        cost2_after = distance_matrix_2[prev_node, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_node]\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.2320630997998165,
            6.8175123747628295
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    }
]