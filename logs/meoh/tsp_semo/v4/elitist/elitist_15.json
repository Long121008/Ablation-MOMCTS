[
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined metric of objective values and solution quality, then applies a hybrid local search combining adaptive segment swapping, dynamic node relocation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and quality metrics\n    scores = []\n    for sol, obj in archive:\n        obj_score = 0.3 * obj[0] + 0.7 * obj[1]\n        quality_score = np.mean([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n        scores.append(obj_score + 0.5 * quality_score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['swap', 'relocate', 'invert'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'swap':\n            k = np.random.randint(2, min(4, n//2))\n            start1 = np.random.randint(0, n - k)\n            start2 = np.random.randint(0, n - k)\n            while abs(start1 - start2) < k:\n                start2 = np.random.randint(0, n - k)\n            segment1 = new_solution[start1:start1+k]\n            segment2 = new_solution[start2:start2+k]\n            new_solution[start1:start1+k] = segment2\n            new_solution[start2:start2+k] = segment1\n\n        elif operation == 'relocate':\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < 2:\n                j = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i or j == (i+1)%n or j == (i-1)%n:\n                    j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                segment = new_solution[i:j+1]\n                inverted = segment[::-1]\n                cost1_diff = (sum(distance_matrix_1[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_1[new_solution[i-1], inverted[0]] +\n                             distance_matrix_1[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_1[new_solution[i-1], segment[0]] +\n                             distance_matrix_1[segment[-1], new_solution[j]])\n                cost2_diff = (sum(distance_matrix_2[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_2[new_solution[i-1], inverted[0]] +\n                             distance_matrix_2[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_2[new_solution[i-1], segment[0]] +\n                             distance_matrix_2[segment[-1], new_solution[j]])\n                candidates.append((i, j, cost1_diff + cost2_diff))\n\n            best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n            if best_i > best_j:\n                best_i, best_j = best_j, best_i\n            segment = new_solution[best_i:best_j+1]\n            new_solution[best_i:best_j+1] = segment[::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.196582362480023,
            5.081888973265188
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized dominance score and adaptive weights, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with dynamically adjusted probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Adaptive weighting based on objective range\n    weights = (max_vals - min_vals) / np.sum(max_vals - min_vals)\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic operation probabilities based on solution quality\n        quality = scores[selected_idx]\n        probabilities = [0.2 + 0.4*(1-quality), 0.3 + 0.2*(1-quality), 0.3 - 0.2*quality, 0.2 - 0.1*quality]\n        probabilities = [max(0.05, p) for p in probabilities]\n        probabilities = [p/sum(probabilities) for p in probabilities]\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=probabilities)\n\n        if operation == 'reversal':\n            length = np.random.randint(2, min(8, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            if n > 5:\n                split1 = np.random.randint(1, n//3)\n                split2 = np.random.randint(2*n//3, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.780648900462513,
            5.945860251541944
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized dominance score and adaptive weights, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with dynamically adjusted probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Adaptive weighting based on objective range\n    weights = (max_vals - min_vals) / np.sum(max_vals - min_vals)\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic operation probabilities based on solution quality\n        quality = scores[selected_idx]\n        probabilities = [0.2 + 0.4*(1-quality), 0.3 + 0.2*(1-quality), 0.3 - 0.2*quality, 0.2 - 0.1*quality]\n        probabilities = [max(0.05, p) for p in probabilities]\n        probabilities = [p/sum(probabilities) for p in probabilities]\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=probabilities)\n\n        if operation == 'reversal':\n            length = np.random.randint(2, min(8, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            if n > 5:\n                split1 = np.random.randint(1, n//3)\n                split2 = np.random.randint(2*n//3, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.780648900462513,
            5.945860251541944
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined metric of objective values and solution quality, then applies a hybrid local search combining adaptive segment swapping, dynamic node relocation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and quality metrics\n    scores = []\n    for sol, obj in archive:\n        obj_score = 0.3 * obj[0] + 0.7 * obj[1]\n        quality_score = np.mean([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n        scores.append(obj_score + 0.5 * quality_score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['swap', 'relocate', 'invert'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'swap':\n            k = np.random.randint(2, min(4, n//2))\n            start1 = np.random.randint(0, n - k)\n            start2 = np.random.randint(0, n - k)\n            while abs(start1 - start2) < k:\n                start2 = np.random.randint(0, n - k)\n            segment1 = new_solution[start1:start1+k]\n            segment2 = new_solution[start2:start2+k]\n            new_solution[start1:start1+k] = segment2\n            new_solution[start2:start2+k] = segment1\n\n        elif operation == 'relocate':\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < 2:\n                j = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i or j == (i+1)%n or j == (i-1)%n:\n                    j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                segment = new_solution[i:j+1]\n                inverted = segment[::-1]\n                cost1_diff = (sum(distance_matrix_1[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_1[new_solution[i-1], inverted[0]] +\n                             distance_matrix_1[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_1[new_solution[i-1], segment[0]] +\n                             distance_matrix_1[segment[-1], new_solution[j]])\n                cost2_diff = (sum(distance_matrix_2[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_2[new_solution[i-1], inverted[0]] +\n                             distance_matrix_2[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_2[new_solution[i-1], segment[0]] +\n                             distance_matrix_2[segment[-1], new_solution[j]])\n                candidates.append((i, j, cost1_diff + cost2_diff))\n\n            best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n            if best_i > best_j:\n                best_i, best_j = best_j, best_i\n            segment = new_solution[best_i:best_j+1]\n            new_solution[best_i:best_j+1] = segment[::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.196582362480023,
            5.081888973265188
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-weighted combination of objective values and solution structure, then applies a hybrid local search combining segment rotation, edge relocation, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (diversity-weighted combination)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_weights = [0.5, 0.5]  # Balance between objective improvement and solution diversity\n    scores = [sum(w * (1 - norm) for w, norm in zip(diversity_weights, normalized[i])) for i in range(len(archive))]\n\n    # Add structural diversity to selection\n    for i in range(len(archive)):\n        sol = archive[i][0]\n        # Calculate solution diversity based on edge uniqueness\n        unique_edges = len(set((min(sol[j], sol[(j+1)%len(sol)]), max(sol[j], sol[(j+1)%len(sol)])) for j in range(len(sol))))\n        edge_diversity = unique_edges / len(sol)\n        scores[i] *= (0.7 + 0.3 * edge_diversity)  # Weighted combination\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'relocation', 'insertion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation (circular shift)\n            start = np.random.randint(0, n - 1)\n            end = np.random.randint(start + 1, n)\n            shift = np.random.randint(1, end - start + 1)\n            segment = new_solution[start:end+1]\n            rotated = np.concatenate([segment[shift:], segment[:shift]])\n            new_solution[start:end+1] = rotated\n\n        elif operation == 'relocation':\n            # Edge relocation with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i or j == (i+1)%n or j == (i-1)%n:\n                    j = np.random.randint(0, n)\n\n                # Calculate cost difference for relocation\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                              distance_matrix_1[base_solution[(j-1)%n], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                             (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                              distance_matrix_1[base_solution[(j-1)%n], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                              distance_matrix_2[base_solution[(j-1)%n], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                             (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                              distance_matrix_2[base_solution[(j-1)%n], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: diversity_weights[0]*x[2] + diversity_weights[1]*x[3])\n                # Relocate node i to position j\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                insert_pos = min(best_j, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:  # insertion\n            # Adaptive node insertion with structural awareness\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            temp_sol = np.delete(new_solution, i)\n\n            # Find insertion positions based on both distance and structural diversity\n            candidate_positions = []\n            for pos in range(len(temp_sol)):\n                # Calculate both distance cost and structural diversity\n                if pos > 0:\n                    dist1 = distance_matrix_1[temp_sol[pos-1], node] + distance_matrix_1[node, temp_sol[pos]]\n                    dist2 = distance_matrix_2[temp_sol[pos-1], node] + distance_matrix_2[node, temp_sol[pos]]\n                    # Calculate structural diversity (number of new unique edges)\n                    new_edges = set()\n                    if pos < len(temp_sol):\n                        new_edges.add((min(node, temp_sol[pos]), max(node, temp_sol[pos])))\n                    if pos > 1:\n                        new_edges.add((min(temp_sol[pos-2], node), max(temp_sol[pos-2], node)))\n                    candidate_positions.append((pos, diversity_weights[0]*dist1 + diversity_weights[1]*dist2, len(new_edges)))\n\n            if candidate_positions:\n                # Prefer positions that create more unique edges\n                best_pos, _, _ = max(candidate_positions, key=lambda x: x[2] - 0.5*x[1])\n                new_solution = np.insert(temp_sol, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.722928073048209,
            6.2824586491554175
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of normalized objectives and solution quality scores, then applies a hybrid local search combining adaptive edge swapping, probabilistic node insertion, and segment reversal with cost estimation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate solution quality scores\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate solution quality scores\n    quality_scores = []\n    for i, (sol, _) in enumerate(archive):\n        n = len(sol)\n        total_cost = 0\n        for j in range(n):\n            total_cost += distance_matrix_1[sol[j-1], sol[j]] + distance_matrix_2[sol[j-1], sol[j]]\n        quality_scores.append(total_cost)\n\n    # Combine normalized objectives and quality scores for selection\n    combined_scores = [0.5*norm[0] + 0.3*norm[1] + 0.2*(qual/max(quality_scores)) for norm, qual in zip(normalized, quality_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['swap', 'insert', 'reverse'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'swap':\n            # Adaptive edge swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [0.5*x[2] + 0.5*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        elif operation == 'insert':\n            # Probabilistic node insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate insertion costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Segment reversal with cost estimation\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate reversal cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = 0.5*cost1 + 0.5*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.597751520720218,
            8.068557995811494
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined metric of objective values and solution quality, then applies a hybrid local search combining adaptive segment swapping, dynamic node relocation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and quality metrics\n    scores = []\n    for sol, obj in archive:\n        obj_score = 0.3 * obj[0] + 0.7 * obj[1]\n        quality_score = np.mean([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n        scores.append(obj_score + 0.5 * quality_score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['swap', 'relocate', 'invert'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'swap':\n            k = np.random.randint(2, min(4, n//2))\n            start1 = np.random.randint(0, n - k)\n            start2 = np.random.randint(0, n - k)\n            while abs(start1 - start2) < k:\n                start2 = np.random.randint(0, n - k)\n            segment1 = new_solution[start1:start1+k]\n            segment2 = new_solution[start2:start2+k]\n            new_solution[start1:start1+k] = segment2\n            new_solution[start2:start2+k] = segment1\n\n        elif operation == 'relocate':\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < 2:\n                j = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i or j == (i+1)%n or j == (i-1)%n:\n                    j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                segment = new_solution[i:j+1]\n                inverted = segment[::-1]\n                cost1_diff = (sum(distance_matrix_1[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_1[new_solution[i-1], inverted[0]] +\n                             distance_matrix_1[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_1[new_solution[i-1], segment[0]] +\n                             distance_matrix_1[segment[-1], new_solution[j]])\n                cost2_diff = (sum(distance_matrix_2[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_2[new_solution[i-1], inverted[0]] +\n                             distance_matrix_2[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_2[new_solution[i-1], segment[0]] +\n                             distance_matrix_2[segment[-1], new_solution[j]])\n                candidates.append((i, j, cost1_diff + cost2_diff))\n\n            best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n            if best_i > best_j:\n                best_i, best_j = best_j, best_i\n            segment = new_solution[best_i:best_j+1]\n            new_solution[best_i:best_j+1] = segment[::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.196582362480023,
            5.081888973265188
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized dominance score and adaptive weights, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with dynamically adjusted probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Adaptive weighting based on objective range\n    weights = (max_vals - min_vals) / np.sum(max_vals - min_vals)\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic operation probabilities based on solution quality\n        quality = scores[selected_idx]\n        probabilities = [0.2 + 0.4*(1-quality), 0.3 + 0.2*(1-quality), 0.3 - 0.2*quality, 0.2 - 0.1*quality]\n        probabilities = [max(0.05, p) for p in probabilities]\n        probabilities = [p/sum(probabilities) for p in probabilities]\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=probabilities)\n\n        if operation == 'reversal':\n            length = np.random.randint(2, min(8, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            if n > 5:\n                split1 = np.random.randint(1, n//3)\n                split2 = np.random.randint(2*n//3, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.780648900462513,
            5.945860251541944
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment rotation, node chain insertion, and probabilistic edge flipping with cost-sensitive acceptance to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate solution structure entropy and combine with objectives\n    def calculate_entropy(sol):\n        n = len(sol)\n        entropy = 0.0\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            dist1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            dist2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            entropy += abs(dist1 - dist2) / (dist1 + dist2 + 1e-10)\n        return entropy / n\n\n    weights = [0.5, 0.3, 0.2]  # Weights for objectives and entropy\n    scores = []\n    for sol, obj in archive:\n        entropy = calculate_entropy(sol)\n        score = weights[0] * obj[0] + weights[1] * obj[1] + weights[2] * entropy\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['rotation', 'chain', 'flip'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'rotation':\n            # Adaptive segment rotation\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n            k = np.random.randint(1, len(segment))\n            rotated = np.concatenate([segment[k:], segment[:k]])\n            new_solution[start:end+1] = rotated\n\n        elif operation == 'chain':\n            # Node chain insertion\n            chain_length = min(3, n//2)\n            chain = np.random.choice(new_solution, size=chain_length, replace=False)\n            new_solution = new_solution[~np.isin(new_solution, chain)]\n            insert_pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, insert_pos, chain)\n\n        else:\n            # Probabilistic edge flipping\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                total_cost = weights[0]*cost1 + weights[1]*cost2\n                if np.random.random() < 1 / (1 + np.exp(total_cost / 5)):\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.875422573298113,
            7.214763236078257
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized dominance score and adaptive weights, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with dynamically adjusted probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Adaptive weighting based on objective range\n    weights = (max_vals - min_vals) / np.sum(max_vals - min_vals)\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic operation probabilities based on solution quality\n        quality = scores[selected_idx]\n        probabilities = [0.2 + 0.4*(1-quality), 0.3 + 0.2*(1-quality), 0.3 - 0.2*quality, 0.2 - 0.1*quality]\n        probabilities = [max(0.05, p) for p in probabilities]\n        probabilities = [p/sum(probabilities) for p in probabilities]\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=probabilities)\n\n        if operation == 'reversal':\n            length = np.random.randint(2, min(8, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            if n > 5:\n                split1 = np.random.randint(1, n//3)\n                split2 = np.random.randint(2*n//3, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.780648900462513,
            5.945860251541944
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a hybrid local search combining adaptive route segmentation, probabilistic edge swapping, and dynamic node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.sum(normalized, axis=1)\n    scores = 0.7 * np.sum(normalized, axis=1) + 0.3 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['segmentation', 'swapping', 'reinsertion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'segmentation':\n            # Adaptive route segmentation\n            split_points = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            segments = [new_solution[:split_points[0]], new_solution[split_points[0]:split_points[1]], new_solution[split_points[1]:]]\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n        elif operation == 'swapping':\n            # Probabilistic edge swapping\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if abs(i-j) > 1:\n                    cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] - \\\n                           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]])\n                    cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] - \\\n                           (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n                    candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                costs = [0.5*c[2] + 0.5*c[3] for c in candidates]\n                probabilities = np.exp(-np.array(costs) / (np.max(np.abs(costs)) + 1e-10))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                i, j, _, _ = candidates[selected]\n                if i > j:\n                    i, j = j, i\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        else:\n            # Dynamic node reinsertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs\n            costs = []\n            for i in range(len(new_solution)):\n                cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]] - distance_matrix_1[new_solution[i-1], new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]]\n                costs.append(cost1 + cost2)\n\n            if costs:\n                probabilities = np.exp(-np.array(costs) / (np.max(np.abs(costs)) + 1e-10))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.743757935447802,
            6.25993225392098
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined metric of objective values and solution quality, then applies a hybrid local search combining adaptive segment swapping, dynamic node relocation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and quality metrics\n    scores = []\n    for sol, obj in archive:\n        obj_score = 0.3 * obj[0] + 0.7 * obj[1]\n        quality_score = np.mean([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n        scores.append(obj_score + 0.5 * quality_score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['swap', 'relocate', 'invert'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'swap':\n            k = np.random.randint(2, min(4, n//2))\n            start1 = np.random.randint(0, n - k)\n            start2 = np.random.randint(0, n - k)\n            while abs(start1 - start2) < k:\n                start2 = np.random.randint(0, n - k)\n            segment1 = new_solution[start1:start1+k]\n            segment2 = new_solution[start2:start2+k]\n            new_solution[start1:start1+k] = segment2\n            new_solution[start2:start2+k] = segment1\n\n        elif operation == 'relocate':\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < 2:\n                j = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i or j == (i+1)%n or j == (i-1)%n:\n                    j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                segment = new_solution[i:j+1]\n                inverted = segment[::-1]\n                cost1_diff = (sum(distance_matrix_1[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_1[new_solution[i-1], inverted[0]] +\n                             distance_matrix_1[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_1[new_solution[i-1], segment[0]] +\n                             distance_matrix_1[segment[-1], new_solution[j]])\n                cost2_diff = (sum(distance_matrix_2[inverted[k-1], inverted[k]] for k in range(1, len(inverted))) +\n                             distance_matrix_2[new_solution[i-1], inverted[0]] +\n                             distance_matrix_2[inverted[-1], new_solution[j]]) - \\\n                            (sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) +\n                             distance_matrix_2[new_solution[i-1], segment[0]] +\n                             distance_matrix_2[segment[-1], new_solution[j]])\n                candidates.append((i, j, cost1_diff + cost2_diff))\n\n            best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n            if best_i > best_j:\n                best_i, best_j = best_j, best_i\n            segment = new_solution[best_i:best_j+1]\n            new_solution[best_i:best_j+1] = segment[::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.196582362480023,
            5.081888973265188
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized dominance score and adaptive weights, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with dynamically adjusted probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Adaptive weighting based on objective range\n    weights = (max_vals - min_vals) / np.sum(max_vals - min_vals)\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic operation probabilities based on solution quality\n        quality = scores[selected_idx]\n        probabilities = [0.2 + 0.4*(1-quality), 0.3 + 0.2*(1-quality), 0.3 - 0.2*quality, 0.2 - 0.1*quality]\n        probabilities = [max(0.05, p) for p in probabilities]\n        probabilities = [p/sum(probabilities) for p in probabilities]\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=probabilities)\n\n        if operation == 'reversal':\n            length = np.random.randint(2, min(8, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            if n > 5:\n                split1 = np.random.randint(1, n//3)\n                split2 = np.random.randint(2*n//3, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.780648900462513,
            5.945860251541944
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines path segment rotation and adaptive edge crossovers to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and diversity)\n    weights = [0.5, 0.5]\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) + np.random.uniform(0, 0.1) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        start = np.random.randint(0, n)\n        new_solution = np.roll(new_solution, shift=start)\n    else:\n        # Novel local search combining segment rotation and adaptive edge crossovers\n        operation = np.random.choice(['rotation', 'crossover'], p=[0.6, 0.4])\n\n        if operation == 'rotation':\n            # Path segment rotation\n            start = np.random.randint(0, n)\n            length = np.random.randint(2, min(5, n))\n            segment = new_solution[start:start+length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+length:], segment])\n\n        else:\n            # Adaptive edge crossover\n            crossover_points = sorted(np.random.choice(n, size=3, replace=False))\n            a, b, c = crossover_points\n            new_solution = np.concatenate([\n                base_solution[:a],\n                base_solution[b:c],\n                base_solution[a:b],\n                base_solution[c:]\n            ])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        start = np.random.randint(0, n)\n        new_solution = np.roll(new_solution, shift=start)\n\n    return new_solution\n\n",
        "score": [
            6.897979703674075,
            5.443587630992578
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a hybrid local search combining adaptive node exchange, segment inversion with cost-aware selection, and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [0.3, 0.7]\n    scores = []\n    for sol, obj in archive:\n        diversity = np.sum(np.diff(sol) != 0) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) - 0.3 * diversity)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['exchange', 'inversion', 'swap'], p=[0.4, 0.35, 0.25])\n\n        if operation == 'exchange':\n            k = np.random.randint(2, min(4, n//3))\n            indices = np.random.choice(n, size=k, replace=False)\n            for i in indices:\n                j = np.random.randint(0, n)\n                while j == i:\n                    j = np.random.randint(0, n)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'inversion':\n            seg_length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - seg_length)\n            end = start + seg_length\n\n            cost_diff_1 = distance_matrix_1[base_solution[start-1], base_solution[end]] + distance_matrix_1[base_solution[start], base_solution[end-1]] - \\\n                         distance_matrix_1[base_solution[start-1], base_solution[start]] - distance_matrix_1[base_solution[end], base_solution[end-1]]\n            cost_diff_2 = distance_matrix_2[base_solution[start-1], base_solution[end]] + distance_matrix_2[base_solution[start], base_solution[end-1]] - \\\n                         distance_matrix_2[base_solution[start-1], base_solution[start]] - distance_matrix_2[base_solution[end], base_solution[end-1]]\n\n            if cost_diff_1 + cost_diff_2 < 0 or np.random.rand() < 0.3:\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:\n                    continue\n\n                cost_diff_1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] + \\\n                            distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] + \\\n                            distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 0.5 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 0.5\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                i, j, _, _ = candidates[selected]\n\n                if i < j:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                else:\n                    new_solution[j:i+1] = new_solution[j:i+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.731218921963779,
            4.785822941928008
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized dominance score and adaptive weights, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with dynamically adjusted probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized dominance scores\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Adaptive weighting based on objective range\n    weights = (max_vals - min_vals) / np.sum(max_vals - min_vals)\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic operation probabilities based on solution quality\n        quality = scores[selected_idx]\n        probabilities = [0.2 + 0.4*(1-quality), 0.3 + 0.2*(1-quality), 0.3 - 0.2*quality, 0.2 - 0.1*quality]\n        probabilities = [max(0.05, p) for p in probabilities]\n        probabilities = [p/sum(probabilities) for p in probabilities]\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=probabilities)\n\n        if operation == 'reversal':\n            length = np.random.randint(2, min(8, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            if n > 5:\n                split1 = np.random.randint(1, n//3)\n                split2 = np.random.randint(2*n//3, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.780648900462513,
            5.945860251541944
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and spatial diversity, then applies a hybrid local search combining adaptive 3-opt moves, probabilistic insertion of nodes from the instance, and guided segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective and spatial diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    spatial_diversity = np.array([np.std(instance[sol, :2], axis=0).sum() + np.std(instance[sol, 2:], axis=0).sum() for sol, _ in archive])\n    scores = 0.6 * normalized.sum(axis=1) + 0.4 * (spatial_diversity / np.max(spatial_diversity))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['3opt', 'insert', 'rotate'], p=[0.4, 0.3, 0.3])\n\n        if operation == '3opt':\n            # Adaptive 3-opt move\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n            # Try all possible 3-opt configurations\n            configs = [\n                (a, b, c),\n                (a, c, b),\n                (b, a, c),\n                (b, c, a),\n                (c, a, b),\n                (c, b, a)\n            ]\n            min_cost = cost_before\n            best_config = (a, b, c)\n\n            for config in configs:\n                x, y, z = config\n                cost = (distance_matrix_1[new_solution[x-1], new_solution[y]] + distance_matrix_1[new_solution[y-1], new_solution[z]] +\n                        distance_matrix_1[new_solution[z-1], new_solution[(x+1)%n]] + distance_matrix_2[new_solution[x-1], new_solution[y]] +\n                        distance_matrix_2[new_solution[y-1], new_solution[z]] + distance_matrix_2[new_solution[z-1], new_solution[(x+1)%n]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_config = config\n\n            if best_config != (a, b, c):\n                x, y, z = best_config\n                new_solution[x:y+1] = new_solution[x:y+1][::-1]\n                new_solution[y:z+1] = new_solution[y:z+1][::-1]\n\n        elif operation == 'insert':\n            # Probabilistic insertion of nodes from instance\n            unused_nodes = [node for node in range(len(instance)) if node not in new_solution]\n            if unused_nodes:\n                node = np.random.choice(unused_nodes)\n                costs = []\n                for i in range(n):\n                    cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]] - distance_matrix_1[new_solution[i-1], new_solution[i]]\n                    cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]]\n                    costs.append(cost1 + cost2)\n\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(n, p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Guided segment rotation\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n\n            # Estimate rotation costs\n            costs = []\n            for rot in range(1, k):\n                rotated = np.concatenate([segment[rot:], segment[:rot]])\n                cost1 = distance_matrix_1[new_solution[start-1], rotated[0]] + distance_matrix_1[rotated[-1], new_solution[(start+k)%n]] - \\\n                       (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(start+k)%n]])\n                cost2 = distance_matrix_2[new_solution[start-1], rotated[0]] + distance_matrix_2[rotated[-1], new_solution[(start+k)%n]] - \\\n                       (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(start+k)%n]])\n                costs.append(cost1 + cost2)\n\n            if costs:\n                best_rot = np.argmin(costs) + 1\n                new_solution[start:start+k] = np.concatenate([segment[best_rot:], segment[:best_rot]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.711730210675992,
            6.346023177091556
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and adaptive crowding distance, then applies a hybrid local search combining node relocation with cost-sensitive insertion, edge reversal with dynamic cost estimation, and probabilistic segment inversion with adaptive acceptance criteria to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate adaptive crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Adaptive crowding distance calculation\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection with different weights\n    weights = [0.5, 0.3, 0.2]  # Higher weight for objectives, moderate for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'relocation':\n            # Cost-sensitive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs with dynamic weighting\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + 0.7*cost2)  # Dynamic weighting\n\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with dynamic cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + 0.6*weights[1]*x[3] for x in candidates]  # Dynamic weighting\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion with adaptive acceptance\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost with dynamic weighting\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Adaptive acceptance criteria\n            total_cost = weights[0]*cost1 + 0.8*weights[1]*cost2  # Dynamic weighting\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 15)):  # More aggressive acceptance\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.649361977310061,
            6.418112756517555
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid of objective dominance and adaptive path length, then applies a novel combination of segment-based relocation, probabilistic edge swapping with cost estimation, and dynamic segment inversion with temperature-based acceptance to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on dominance and path length\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n = len(solutions[0])\n\n    # Calculate dominance counts and path lengths\n    dominance = np.zeros(len(archive))\n    path_lengths = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                dominance[i] += 1\n        path_lengths[i] = sum(distance_matrix_1[solutions[i][k], solutions[i][(k+1)%n]] for k in range(n))\n\n    # Normalize and combine metrics\n    norm_dominance = (dominance - np.min(dominance)) / (np.max(dominance) - np.min(dominance) + 1e-10)\n    norm_length = (path_lengths - np.min(path_lengths)) / (np.max(path_lengths) - np.min(path_lengths) + 1e-10)\n    scores = 0.6 * norm_dominance + 0.4 * (1 - norm_length)  # Prefer non-dominated with shorter paths\n    selected_idx = np.argmax(scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic temperature for acceptance\n    temp = 1.0 / (1 + np.exp(-0.1 * (np.max(path_lengths) - np.min(path_lengths))))\n\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['segment_relocation', 'edge_swap', 'dynamic_inversion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'segment_relocation':\n            # Segment-based relocation with cost estimation\n            seg_size = max(2, min(5, np.random.randint(1, n//2)))\n            start = np.random.randint(0, n - seg_size)\n            segment = new_solution[start:start+seg_size]\n            new_solution = np.delete(new_solution, slice(start, start+seg_size))\n\n            # Estimate insertion costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                seg_start = segment[0]\n                seg_end = segment[-1]\n                cost1 = distance_matrix_1[prev_node, seg_start] + distance_matrix_1[seg_end, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, seg_start] + distance_matrix_2[seg_end, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            if costs:\n                probabilities = np.exp(-np.array(costs) / (temp * np.max(np.abs(costs))))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, segment)\n\n        elif operation == 'edge_swap':\n            # Probabilistic edge swapping with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [0.5*x[2] + 0.5*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / (temp * np.max(np.abs(costs))))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                i, j, _, _ = candidates[selected]\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        else:\n            # Dynamic segment inversion with temperature-based acceptance\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            total_cost = 0.5*cost1 + 0.5*cost2\n            if np.random.random() < np.exp(-total_cost / (temp * 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.055332689107308,
            10.38094659927301
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and adaptive crowding distance, then applies a hybrid local search combining node relocation with cost-sensitive insertion, edge reversal with dynamic cost estimation, and probabilistic segment inversion with adaptive acceptance criteria to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate adaptive crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Adaptive crowding distance calculation\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection with different weights\n    weights = [0.5, 0.3, 0.2]  # Higher weight for objectives, moderate for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'relocation':\n            # Cost-sensitive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs with dynamic weighting\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + 0.7*cost2)  # Dynamic weighting\n\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with dynamic cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + 0.6*weights[1]*x[3] for x in candidates]  # Dynamic weighting\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion with adaptive acceptance\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost with dynamic weighting\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Adaptive acceptance criteria\n            total_cost = weights[0]*cost1 + 0.8*weights[1]*cost2  # Dynamic weighting\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 15)):  # More aggressive acceptance\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.649361977310061,
            6.418112756517555
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized and inverse-weighted combination of objective values, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (inverse-weighted normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Inverse weights for each objective\n    scores = [sum(w * (1 - norm) for w, norm in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on inverse-weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(1 - x[2]/(np.max([c[2] for c in candidates]) + 1e-8)) + weights[1]*(1 - x[3]/(np.max([c[3] for c in candidates]) + 1e-8)))\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.168627579692995,
            4.486829527756991
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive node relocation, edge reversal with cost estimation, and probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_obj[m] - min_obj[m] + 1e-10)\n\n    # Combine objectives and crowding distance for selection\n    weights = [0.4, 0.4, 0.2]  # Higher weight for objectives, lower for diversity\n    scores = [weights[0]*obj1 + weights[1]*obj2 + weights[2]*crowd for (obj1, obj2), crowd in zip(objectives, crowding)]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocation', 'reversal', 'inversion'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocation':\n            # Adaptive node relocation\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate relocation costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Relocate with probabilistic acceptance\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'reversal':\n            # Edge reversal with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Probabilistic segment inversion\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = weights[0]*cost1 + weights[1]*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.848229135490238,
            5.88752722167784
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment transposition, node relocation with cost-sensitive insertion, and edge flipping with probabilistic selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and structural entropy)\n    weights = [0.4, 0.6]  # Higher weight for second objective\n    scores = []\n    for sol, obj in archive:\n        # Calculate structural entropy as diversity measure\n        entropy = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(sum(w * o for w, o in zip(weights, obj)) + 0.5 * entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive operations\n        operation = np.random.choice(['transposition', 'relocation', 'flip'], p=[0.35, 0.4, 0.25])\n\n        if operation == 'transposition':\n            # Adaptive segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:  # Ensure segments don't overlap\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'relocation':\n            # Node relocation with cost-sensitive insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Calculate insertion costs considering both objectives\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            # Insert at position with cost-sensitive probability\n            if costs:\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Edge flipping with probabilistic selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                if abs(i - j) < 2:  # Ensure sufficient distance\n                    continue\n\n                # Calculate cost difference for both objectives\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select best candidate with probabilistic acceptance\n            if candidates:\n                costs = [weights[0]*x[2] + weights[1]*x[3] for x in candidates]\n                temp = 1.0 / np.max(np.abs(costs)) if np.max(np.abs(costs)) > 0 else 1.0\n                probabilities = np.exp(-np.array(costs) * temp)\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n\n                # Perform the flip\n                if best_i < best_j:\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n                else:\n                    new_solution[best_j:best_i+1] = new_solution[best_j:best_i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.760891911552608,
            5.560281739921709
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    }
]