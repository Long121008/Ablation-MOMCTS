[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment reversal, adaptive edge swapping, and multi-point insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on combined objectives and diversity\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'swap', 'multi_insert'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal with adaptive selection\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-2)\n                j = np.random.randint(i+2, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swap':\n            # Adaptive edge swapping\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Multi-point insertion\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.5174918438430645,
            5.283765169936114
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a combination of objective values and edge entropy metrics, then applies a hybrid local search combining probabilistic node relocation, adaptive segment rotation, and dynamic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective values and edge entropy\n    weights = [0.5, 0.5]\n    scores = []\n    for sol, obj in archive:\n        edge_entropy = 0\n        n = len(sol)\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            edge_entropy += (distance_matrix_1[curr, prev] + distance_matrix_2[curr, prev] +\n                           distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n        scores.append(weights[0] * (obj[0] + obj[1]) + weights[1] * edge_entropy)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['relocate', 'rotate', 'flip'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'relocate':\n            # Probabilistic node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*(x[2]+x[3]) + weights[1]*(x[2]+x[3])/n)\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'rotate':\n            # Adaptive segment rotation\n            candidates = []\n            for _ in range(5):\n                k = np.random.randint(2, min(5, n//2))\n                start = np.random.randint(0, n - k)\n                temp_sol = new_solution.copy()\n                segment = temp_sol[start:start+k]\n                temp_sol[start:start+k] = np.roll(segment, np.random.randint(1, k))\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((start, k, cost1, cost2))\n\n            if candidates:\n                best_start, best_k, _, _ = min(candidates, key=lambda x: weights[0]*(x[2]+x[3]) + weights[1]*(x[2]+x[3])/n)\n                segment = new_solution[best_start:best_start+best_k]\n                new_solution[best_start:best_start+best_k] = np.roll(segment, np.random.randint(1, best_k))\n\n        else:\n            # Dynamic edge flipping\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                if np.random.random() < 0.7:\n                    # With 70% probability, also reverse the segment between them\n                    if i > j:\n                        i, j = j, i\n                    temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*(x[2]+x[3]) + weights[1]*(x[2]+x[3])/n)\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n                if np.random.random() < 0.7:\n                    if best_i > best_j:\n                        best_i, best_j = best_j, best_i\n                    new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.159632793023187,
            5.606508960600376
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a novel local search combining segment transposition, adaptive edge flipping, and node reinsertion with hierarchical probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective values and solution structure diversity\n    weights = [0.3, 0.7]\n    scores = []\n    for sol, obj in archive:\n        # Calculate structure diversity (measure of tour variation)\n        n = len(sol)\n        diversity = 0.0\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            diversity += (distance_matrix_1[prev, curr] * distance_matrix_2[curr, next_node] +\n                         distance_matrix_2[prev, curr] * distance_matrix_1[curr, next_node])\n        score = sum(w * o for w, o in zip(weights, obj)) + 0.15 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hierarchical operation selection\n        if np.random.random() < 0.5:\n            # Segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n\n            temp = new_solution.copy()\n            temp[start1:start1+seg_length] = seg2\n            temp[start2:start2+seg_length] = seg1\n\n            # Check if transposition is valid\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n        else:\n            # Adaptive edge flipping with node reinsertion\n            if np.random.random() < 0.7:\n                # Edge flipping\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n\n                temp = new_solution.copy()\n                temp[i:j+1] = temp[i:j+1][::-1]\n\n                if len(np.unique(temp)) == n:\n                    new_solution = temp\n            else:\n                # Node reinsertion with position selection\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n\n                temp_sol = np.delete(new_solution, i)\n\n                # Select position based on both objectives\n                candidates = []\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, cost1, cost2))\n\n                if candidates:\n                    best_pos, _, _ = min(candidates, key=lambda x: weights[0]*x[1] + weights[1]*x[2])\n                    new_solution = np.insert(temp_sol, best_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.575953962019064,
            4.681209405844362
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with different adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'rotation':\n            # Segment rotation with larger segment size\n            length = np.random.randint(3, min(7, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with more candidate evaluations\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion with different positions\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.997523924999912,
            6.918667754463472
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities, while incorporating a novel structure-preserving mutation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective values and solution structure entropy\n    weights = [0.4, 0.6]\n    scores = []\n    for sol, obj in archive:\n        # Calculate structure entropy (measure of tour randomness)\n        n = len(sol)\n        entropy = 0.0\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            # Calculate local structure diversity\n            diversity = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                        distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) / 4\n            entropy += diversity\n        score = sum(w * o for w, o in zip(weights, obj)) + 0.2 * entropy\n        scores.append(score)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'structure_preserve'], p=[0.25, 0.25, 0.25, 0.25])\n\n        if operation == 'reversal':\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif operation == 'swap':\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # structure_preserve operation\n            # Identify a segment that maintains good structure\n            segment_length = min(5, n//2)\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n\n            # Find the best position to reinsert this segment\n            best_pos = start\n            best_score = float('inf')\n            for pos in range(n - segment_length):\n                if pos >= start and pos <= end:\n                    continue\n                # Temporarily reinsert segment\n                temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n                # Calculate score for this configuration\n                score = 0\n                for i in range(n):\n                    prev = temp_sol[i-1]\n                    curr = temp_sol[i]\n                    next_node = temp_sol[(i+1)%n]\n                    score += (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                             distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            # Apply the best reinsertion\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos+segment_length:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.199432988911294,
            5.604942752052077
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.2:  # 20% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056287860548064,
            4.932706471438741
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment shifting, adaptive node relocation, and multi-segment crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [0.5, 0.5]\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['shift', 'relocate', 'crossover'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'shift':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-2)\n                j = np.random.randint(i+2, n)\n                shift = np.random.randint(1, min(5, j-i))\n                temp_sol = new_solution.copy()\n                segment = temp_sol[i:j]\n                temp_sol[i:j] = np.roll(segment, shift)\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, shift, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, best_shift, _, _ = min(candidates, key=lambda x: weights[0]*x[3] + weights[1]*x[4])\n                segment = new_solution[best_i:best_j]\n                new_solution[best_i:best_j] = np.roll(segment, best_shift)\n\n        elif operation == 'relocate':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//4, len(temp_sol)//2, 3*len(temp_sol)//4, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                k = np.random.randint(2, n//2)\n                i = np.random.randint(0, n - 2*k)\n                j = np.random.randint(i + k, n - k)\n                temp_sol = np.concatenate([new_solution[:i], new_solution[j:j+k], new_solution[i+k:j], new_solution[i:i+k], new_solution[j+k:]])\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, k, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, best_k, _, _ = min(candidates, key=lambda x: weights[0]*x[3] + weights[1]*x[4])\n                new_solution = np.concatenate([new_solution[:best_i], new_solution[best_j:best_j+best_k], new_solution[best_i+best_k:best_j], new_solution[best_i:best_i+best_k], new_solution[best_j+best_k:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.903988208882544,
            5.6635532092959355
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a nonlinear weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (nonlinear weighted combination)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1)**0.7 + (obj[1]/max_obj2)**0.3 for _, obj in archive]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.3, 0.5, 0.2])\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: (x[2]/max_obj1)**0.7 + (x[3]/max_obj2)**0.3)\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(2):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//4, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: (x[2]/max_obj1)**0.7 + (x[3]/max_obj2)**0.3)\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.55618061491404,
            8.180267322967786
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a nonlinear weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (nonlinear weighted combination)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1)**0.7 + (obj[1]/max_obj2)**0.3 for _, obj in archive]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.3, 0.5, 0.2])\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: (x[2]/max_obj1)**0.7 + (x[3]/max_obj2)**0.3)\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(2):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//4, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: (x[2]/max_obj1)**0.7 + (x[3]/max_obj2)**0.3)\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.55618061491404,
            8.180267322967786
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a novel local search combining segment transposition, adaptive edge flipping, and node reinsertion with hierarchical probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective values and solution structure diversity\n    weights = [0.3, 0.7]\n    scores = []\n    for sol, obj in archive:\n        # Calculate structure diversity (measure of tour variation)\n        n = len(sol)\n        diversity = 0.0\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            diversity += (distance_matrix_1[prev, curr] * distance_matrix_2[curr, next_node] +\n                         distance_matrix_2[prev, curr] * distance_matrix_1[curr, next_node])\n        score = sum(w * o for w, o in zip(weights, obj)) + 0.15 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hierarchical operation selection\n        if np.random.random() < 0.5:\n            # Segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n\n            temp = new_solution.copy()\n            temp[start1:start1+seg_length] = seg2\n            temp[start2:start2+seg_length] = seg1\n\n            # Check if transposition is valid\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n        else:\n            # Adaptive edge flipping with node reinsertion\n            if np.random.random() < 0.7:\n                # Edge flipping\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n\n                temp = new_solution.copy()\n                temp[i:j+1] = temp[i:j+1][::-1]\n\n                if len(np.unique(temp)) == n:\n                    new_solution = temp\n            else:\n                # Node reinsertion with position selection\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n\n                temp_sol = np.delete(new_solution, i)\n\n                # Select position based on both objectives\n                candidates = []\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, cost1, cost2))\n\n                if candidates:\n                    best_pos, _, _ = min(candidates, key=lambda x: weights[0]*x[1] + weights[1]*x[2])\n                    new_solution = np.insert(temp_sol, best_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.575953962019064,
            4.681209405844362
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with different adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'rotation':\n            # Segment rotation with larger segment size\n            length = np.random.randint(3, min(7, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with more candidate evaluations\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion with different positions\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.997523924999912,
            6.918667754463472
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.2:  # 20% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056287860548064,
            4.932706471438741
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and structural diversity, then applies a hybrid local search combining adaptive segment rotation, node chain insertion, and multi-segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [0.4, 0.6]\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['rotation', 'chain_insertion', 'inversion'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'rotation':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-2)\n                j = np.random.randint(i+2, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j] = np.roll(temp_sol[i:j], np.random.randint(1, min(5, j-i)))\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j] = np.roll(new_solution[best_i:best_j], np.random.randint(1, min(5, best_j-best_i)))\n\n        elif operation == 'chain_insertion':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i:\n                    j = np.random.randint(0, n)\n                temp_sol = new_solution.copy()\n                node = temp_sol[i]\n                temp_sol = np.delete(temp_sol, i)\n                temp_sol = np.insert(temp_sol, j, node)\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_j, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j] = temp_sol[i:j][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.936341004999909,
            4.974997860819016
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (different weights)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.2, 0.5, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.3:  # 30% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.697329845678833,
            7.720330820362394
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with different adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'rotation':\n            # Segment rotation with larger segment size\n            length = np.random.randint(3, min(7, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with more candidate evaluations\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion with different positions\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.997523924999912,
            6.918667754463472
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.2:  # 20% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056287860548064,
            4.932706471438741
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment reordering, dynamic node insertion, and multi-segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [0.6, 0.4]\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['reorder', 'insert', 'invert'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reorder':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-3)\n                j = np.random.randint(i+3, n)\n                k = np.random.randint(i+1, j)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j] = np.concatenate([temp_sol[k:j], temp_sol[i:k]])\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, k, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, best_k, _, _ = min(candidates, key=lambda x: weights[0]*x[3] + weights[1]*x[4])\n                new_solution[best_i:best_j] = np.concatenate([new_solution[best_k:best_j], new_solution[best_i:best_k]])\n\n        elif operation == 'insert':\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        else:\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-2)\n                j = np.random.randint(i+2, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j] = temp_sol[i:j][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.118034301861935,
            6.910815705872227
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a novel local search combining segment transposition, adaptive edge flipping, and node reinsertion with hierarchical probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective values and solution structure diversity\n    weights = [0.3, 0.7]\n    scores = []\n    for sol, obj in archive:\n        # Calculate structure diversity (measure of tour variation)\n        n = len(sol)\n        diversity = 0.0\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            diversity += (distance_matrix_1[prev, curr] * distance_matrix_2[curr, next_node] +\n                         distance_matrix_2[prev, curr] * distance_matrix_1[curr, next_node])\n        score = sum(w * o for w, o in zip(weights, obj)) + 0.15 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hierarchical operation selection\n        if np.random.random() < 0.5:\n            # Segment transposition\n            seg_length = np.random.randint(2, min(5, n//2))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:\n                start2 = np.random.randint(0, n - seg_length)\n\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n\n            temp = new_solution.copy()\n            temp[start1:start1+seg_length] = seg2\n            temp[start2:start2+seg_length] = seg1\n\n            # Check if transposition is valid\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n        else:\n            # Adaptive edge flipping with node reinsertion\n            if np.random.random() < 0.7:\n                # Edge flipping\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n\n                temp = new_solution.copy()\n                temp[i:j+1] = temp[i:j+1][::-1]\n\n                if len(np.unique(temp)) == n:\n                    new_solution = temp\n            else:\n                # Node reinsertion with position selection\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n\n                temp_sol = np.delete(new_solution, i)\n\n                # Select position based on both objectives\n                candidates = []\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, cost1, cost2))\n\n                if candidates:\n                    best_pos, _, _ = min(candidates, key=lambda x: weights[0]*x[1] + weights[1]*x[2])\n                    new_solution = np.insert(temp_sol, best_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.575953962019064,
            4.681209405844362
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a nonlinear weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (nonlinear weighted combination)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    normalized_scores = [(obj[0]/max_obj1)**0.7 + (obj[1]/max_obj2)**0.3 for _, obj in archive]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.3, 0.5, 0.2])\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: (x[2]/max_obj1)**0.7 + (x[3]/max_obj2)**0.3)\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(2):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//4, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: (x[2]/max_obj1)**0.7 + (x[3]/max_obj2)**0.3)\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.55618061491404,
            8.180267322967786
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with different adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'rotation':\n            # Segment rotation with larger segment size\n            length = np.random.randint(3, min(7, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with more candidate evaluations\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion with different positions\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.997523924999912,
            6.918667754463472
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.2:  # 20% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056287860548064,
            4.932706471438741
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and diversity, then applies an adaptive local search combining segment rotation, edge reversal, and node insertion with probability weights adjusted based on solution quality, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate diversity score\n    objectives = np.array([sol[1] for sol in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=0).mean()\n    weights = [0.6, 0.4]  # Higher weight for first objective\n    scores = [sum(w * (1 - obj) + 0.2 * diversity for w, obj in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Adaptive operation probabilities based on solution quality\n        quality = 1 - (scores[selected_idx] / max(scores))\n        operation_probs = [0.4 + 0.2 * quality, 0.3 + 0.3 * quality, 0.3 - 0.2 * quality]\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=operation_probs)\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.794067605066837,
            7.568405671013672
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.2:  # 20% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056287860548064,
            4.932706471438741
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with different adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'rotation':\n            # Segment rotation with larger segment size\n            length = np.random.randint(3, min(7, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with more candidate evaluations\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion with different positions\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.997523924999912,
            6.918667754463472
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion with probability-based selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and diversity)\n    weights = [0.4, 0.6]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.25, 0.4, 0.35])\n\n        if operation == 'rotation':\n            # Segment rotation with adaptive length\n            length = np.random.randint(2, min(4, n//3))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with multiple candidate segments\n            candidates = []\n            for _ in range(2):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion with multiple positions\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            6.787504706777193,
            4.999991138287893
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.2:  # 20% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056287860548064,
            4.932706471438741
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and diversity, then applies an adaptive local search combining segment rotation, edge reversal, and node insertion with probability weights adjusted based on solution quality, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate diversity score\n    objectives = np.array([sol[1] for sol in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=0).mean()\n    weights = [0.6, 0.4]  # Higher weight for first objective\n    scores = [sum(w * (1 - obj) + 0.2 * diversity for w, obj in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Adaptive operation probabilities based on solution quality\n        quality = 1 - (scores[selected_idx] / max(scores))\n        operation_probs = [0.4 + 0.2 * quality, 0.3 + 0.3 * quality, 0.3 - 0.2 * quality]\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=operation_probs)\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.794067605066837,
            7.568405671013672
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and spatial diversity, then applies a multi-phase local search combining segment transposition, adaptive node swapping, and guided edge insertion using a weighted combination of both distance matrices, with feasibility maintained through systematic validation and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective values and spatial diversity\n    objectives = np.array([sol[1] for sol in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=0).mean()\n    weights = [0.5, 0.5]\n    scores = [sum(w * (1 - obj) + 0.3 * diversity for w, obj in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return np.random.permutation(base_solution)\n\n    # Multi-phase local search\n    phases = ['transposition', 'adaptive_swap', 'guided_insertion']\n    phase_weights = [0.4, 0.3, 0.3]\n\n    for phase in np.random.choice(phases, p=phase_weights):\n        if phase == 'transposition':\n            # Segment transposition with distance-based selection\n            segments = []\n            for _ in range(3):\n                i = np.random.randint(0, n-2)\n                j = np.random.randint(i+1, n)\n                k = np.random.randint(0, n-2)\n                l = np.random.randint(k+1, n)\n                if abs(i-k) > 1 and abs(j-l) > 1:\n                    segments.append((i, j, k, l))\n\n            if segments:\n                best_seg = None\n                min_cost = float('inf')\n                for i, j, k, l in segments:\n                    temp = new_solution.copy()\n                    temp[i:j+1], temp[k:l+1] = temp[k:l+1], temp[i:j+1]\n                    cost1 = sum(distance_matrix_1[temp[m], temp[m+1]] for m in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[m], temp[m+1]] for m in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    total_cost = weights[0]*cost1 + weights[1]*cost2\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_seg = (i, j, k, l)\n\n                if best_seg:\n                    i, j, k, l = best_seg\n                    new_solution[i:j+1], new_solution[k:l+1] = new_solution[k:l+1], new_solution[i:j+1]\n\n        elif phase == 'adaptive_swap':\n            # Adaptive node swapping based on spatial proximity\n            quality = 1 - (scores[selected_idx] / max(scores))\n            swap_count = max(1, int(3 * quality))\n\n            for _ in range(swap_count):\n                candidates = []\n                for _ in range(5):\n                    a, b = np.random.choice(n, 2, replace=False)\n                    node_a = new_solution[a]\n                    node_b = new_solution[b]\n                    dist1 = np.linalg.norm(instance[node_a, :2] - instance[node_b, :2])\n                    dist2 = np.linalg.norm(instance[node_a, 2:] - instance[node_b, 2:])\n                    candidates.append((a, b, dist1, dist2))\n\n                if candidates:\n                    best_a, best_b, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                    new_solution[best_a], new_solution[best_b] = new_solution[best_b], new_solution[best_a]\n\n        else:  # guided_insertion\n            # Guided edge insertion with distance matrix guidance\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n\n                # Find insertion positions that minimize both objectives\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[m], temp[m+1]] for m in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[m], temp[m+1]] for m in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.807602546076086,
            5.777750519042891
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and diversity, then applies an adaptive local search combining segment rotation, edge reversal, and node insertion with probability weights adjusted based on solution quality, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate diversity score\n    objectives = np.array([sol[1] for sol in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=0).mean()\n    weights = [0.6, 0.4]  # Higher weight for first objective\n    scores = [sum(w * (1 - obj) + 0.2 * diversity for w, obj in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Adaptive operation probabilities based on solution quality\n        quality = 1 - (scores[selected_idx] / max(scores))\n        operation_probs = [0.4 + 0.2 * quality, 0.3 + 0.3 * quality, 0.3 - 0.2 * quality]\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=operation_probs)\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.794067605066837,
            7.568405671013672
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment inversion, adaptive node swapping, and probabilistic edge relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['inversion', 'swapping', 'relinking'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'inversion':\n            # Segment inversion with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'swapping':\n            # Adaptive node swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, 2, replace=False)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            # Probabilistic edge relinking\n            ref_idx = np.random.randint(0, len(archive))\n            ref_solution = archive[ref_idx][0]\n            for i in range(n):\n                if np.random.random() < 0.2:  # 20% chance to relink\n                    node = ref_solution[i]\n                    if node in new_solution:\n                        pos = np.where(new_solution == node)[0][0]\n                        if pos != i:\n                            new_solution = np.delete(new_solution, pos)\n                            new_solution = np.insert(new_solution, i, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the operation fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056287860548064,
            4.932706471438741
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware metric combining objective values and tour structure, then applies a hybrid local search combining adaptive segment rotation, probabilistic edge flipping with greedy acceptance, and dynamic node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity-aware metric\n    diversity_scores = []\n    for sol, obj in archive:\n        obj_score = 0.4 * obj[0] + 0.6 * obj[1]\n        structure_score = np.mean([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n        diversity = sum(abs(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] - distance_matrix_2[sol[i], sol[(i+1)%len(sol)]]) for i in range(len(sol)))\n        diversity_scores.append(obj_score + 0.3 * structure_score + 0.2 * diversity)\n\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['rotate', 'flip', 'reinsert'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotate':\n            k = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - k)\n            segment = new_solution[start:start+k]\n            rotated = np.roll(segment, np.random.randint(1, k))\n            new_solution[start:start+k] = rotated\n\n        elif operation == 'flip':\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while abs(i - j) < 2 or (i > j and i - j < 2) or (j > i and j - i < 2):\n                    j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                edge1 = (new_solution[i-1], new_solution[i])\n                edge2 = (new_solution[j], new_solution[(j+1)%n])\n                new_edge1 = (new_solution[i-1], new_solution[j])\n                new_edge2 = (new_solution[i], new_solution[(j+1)%n])\n                cost_diff_1 = (distance_matrix_1[new_edge1[0], new_edge1[1]] + distance_matrix_1[new_edge2[0], new_edge2[1]]) - \\\n                             (distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]])\n                cost_diff_2 = (distance_matrix_2[new_edge1[0], new_edge1[1]] + distance_matrix_2[new_edge2[0], new_edge2[1]]) - \\\n                             (distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            best_i, best_j, _, _ = min(candidates, key=lambda x: 0.5*x[2] + 0.5*x[3])\n            if best_i > best_j:\n                best_i, best_j = best_j, best_i\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n            # Greedy acceptance for reinsertion\n            if np.random.random() < 0.7:\n                cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                if cost1 > sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)) or \\\n                   cost2 > sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)):\n                    new_solution = base_solution.copy()\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.225614810766075,
            5.4040028650240535
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.859781897209521,
            7.5145439472350475
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and diversity, then applies an adaptive local search combining segment rotation, edge reversal, and node insertion with probability weights adjusted based on solution quality, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate diversity score\n    objectives = np.array([sol[1] for sol in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=0).mean()\n    weights = [0.6, 0.4]  # Higher weight for first objective\n    scores = [sum(w * (1 - obj) + 0.2 * diversity for w, obj in zip(weights, normalized[i])) for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Adaptive operation probabilities based on solution quality\n        quality = 1 - (scores[selected_idx] / max(scores))\n        operation_probs = [0.4 + 0.2 * quality, 0.3 + 0.3 * quality, 0.3 - 0.2 * quality]\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=operation_probs)\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            4.794067605066837,
            7.568405671013672
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment reversal, adaptive edge insertion, and node shifting to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [0.3, 0.7]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = [sum(w * obj for w, obj in zip(weights, normalized_obj[i])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        new_solution = new_solution[::-1]\n    else:\n        operation = np.random.choice(['reversal', 'insertion', 'shift'], p=[0.2, 0.5, 0.3])\n\n        if operation == 'reversal':\n            candidates = []\n            for _ in range(2):\n                i = np.random.randint(0, n-2)\n                j = np.random.randint(i+1, n-1)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        elif operation == 'insertion':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                while j == i or j == (i-1)%n or j == (i+1)%n:\n                    j = np.random.randint(0, n)\n                temp_sol = new_solution.copy()\n                node = temp_sol[i]\n                temp_sol = np.delete(temp_sol, i)\n                temp_sol = np.insert(temp_sol, j, node)\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_j, node)\n\n        else:\n            candidates = []\n            for _ in range(2):\n                i = np.random.randint(0, n)\n                shift = np.random.randint(1, min(3, n//2))\n                temp_sol = np.roll(new_solution, shift)\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((shift, cost1, cost2))\n\n            if candidates:\n                best_shift, _, _ = min(candidates, key=lambda x: weights[0]*x[1] + weights[1]*x[2])\n                new_solution = np.roll(new_solution, best_shift)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.492363987361017,
            4.179640891383562
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion, with different parameter settings for the score function to prioritize solutions with higher diversity and lower objective values.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, 2*len(temp_sol)//3, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            7.387530632703905,
            4.831055816750341
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objective values and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion, with different probability weights for each operation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select based on weighted sum with diversity consideration\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, normalized_obj[i])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.25, 0.45, 0.3])\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            8.018738268973163,
            4.425019279293417
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a rank-based selection that prioritizes solutions with better relative performance in either objective, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a dynamically adjusted weight that emphasizes the underperforming objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank-based selection prioritizing underperforming objective\n    sorted_by_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_by_obj2 = sorted(archive, key=lambda x: x[1][1])\n\n    # Select solution with best rank in either objective\n    ranks = {}\n    for i, (sol, _) in enumerate(sorted_by_obj1):\n        ranks[sol.tobytes()] = i\n    for i, (sol, _) in enumerate(sorted_by_obj2):\n        ranks[sol.tobytes()] = min(ranks.get(sol.tobytes(), float('inf')), i)\n\n    selected_solution = min(archive, key=lambda x: ranks[x[0].tobytes()])[0].copy()\n\n    # Hybrid local search with dynamic weight adjustment\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    weight = 0.3 if cost1 > cost2 else 0.7  # Emphasize underperforming objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            9.938795448622109,
            4.094656377143874
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and solution entropy, then applies a hybrid local search combining adaptive segment reversal, intelligent node insertion, and edge exchange with dynamic probabilities, ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    solutions = np.array([sol for sol, _ in archive])\n    entropy = np.zeros(len(archive))\n    for i in range(len(archive)):\n        transitions = []\n        for j in range(len(solutions[i])-1):\n            transitions.append((solutions[i][j], solutions[i][j+1]))\n        transition_counts = np.unique(transitions, return_counts=True)[1]\n        entropy[i] = -np.sum(transition_counts * np.log(transition_counts)) / len(transitions)\n\n    entropy = (entropy - entropy.min()) / (entropy.max() - entropy.min() + 1e-10)\n    scores = 0.7 * np.sum(normalized, axis=1) + 0.3 * entropy\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation_probs = [0.4, 0.3, 0.2, 0.1]\n        operation = np.random.choice(['reversal', 'insertion', 'exchange', 'swap'], p=operation_probs)\n\n        if operation == 'reversal':\n            num_segments = np.random.randint(1, min(4, n//3))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(8, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'insertion':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'exchange':\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:\n            if n > 5:\n                split1 = np.random.randint(1, n//3)\n                split2 = np.random.randint(2*n//3, n-1)\n                segment = new_solution[split1:split2]\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    if len(np.unique(new_solution)) != n:\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.746740591202224,
            6.086308796928504
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid of objective improvement potential and structural diversity, then applies a novel local search combining adaptive segment swapping with probabilistic edge inversion and dynamic node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and structural metrics\n    objective_scores = [0.4 * obj[0] + 0.6 * obj[1] for _, obj in archive]\n    diversity_scores = [sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] + distance_matrix_2[sol[i], sol[(i+1)%len(sol)]]\n                        for i in range(len(sol))) for sol, _ in archive]\n    combined_scores = [obj + 0.2 * div for obj, div in zip(objective_scores, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment swapping with probabilistic inversion\n        operation = np.random.choice(['segment_swap', 'edge_inversion', 'node_relocation'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'segment_swap':\n            # Swap two non-adjacent segments\n            seg_length = np.random.randint(2, min(5, n//3))\n            start1 = np.random.randint(0, n - seg_length)\n            start2 = np.random.randint(0, n - seg_length)\n            while abs(start1 - start2) < seg_length:\n                start2 = np.random.randint(0, n - seg_length)\n            seg1 = new_solution[start1:start1+seg_length]\n            seg2 = new_solution[start2:start2+seg_length]\n            new_solution[start1:start1+seg_length] = seg2\n            new_solution[start2:start2+seg_length] = seg1\n\n        elif operation == 'edge_inversion':\n            # Invert edges with probability based on distance improvement\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: 0.4*x[2] + 0.6*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Dynamic node relocation based on both objectives\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//3, len(temp_sol)//2, 2*len(temp_sol)//3, len(temp_sol)]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: 0.4*x[2] + 0.6*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to segment swap\n        seg_length = np.random.randint(2, min(4, n//2))\n        start1 = np.random.randint(0, n - seg_length)\n        start2 = np.random.randint(0, n - seg_length)\n        while abs(start1 - start2) < seg_length:\n            start2 = np.random.randint(0, n - seg_length)\n        seg1 = new_solution[start1:start1+seg_length]\n        seg2 = new_solution[start2:start2+seg_length]\n        new_solution[start1:start1+seg_length] = seg2\n        new_solution[start2:start2+seg_length] = seg1\n\n    return new_solution\n\n",
        "score": [
            6.487452247695854,
            5.208478101521793
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objective values and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion, with different probability weights for each operation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select based on weighted sum with diversity consideration\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, normalized_obj[i])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.25, 0.45, 0.3])\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            8.018738268973163,
            4.425019279293417
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objective values and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion, with different probability weights for each operation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select based on weighted sum with diversity consideration\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, normalized_obj[i])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.25, 0.45, 0.3])\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            8.018738268973163,
            4.425019279293417
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection metric that combines objective scores and tour structure similarity, then applies a hybrid local search combining adaptive 3-opt moves, node reinsertion with path optimization, and a novel \"objective-balanced\" edge replacement strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj, axis=1) + 0.5 * np.mean([np.sum(np.abs(np.diff(sol, prepend=sol[-1]))) for sol, _ in archive])\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['3opt', 'reinsertion', 'edge_replace'], p=[0.3, 0.4, 0.3])\n\n        if operation == '3opt':\n            # Adaptive 3-opt move\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            candidates = [\n                base_solution.copy(),\n                np.concatenate([base_solution[:a], base_solution[a:b][::-1], base_solution[b:]]),\n                np.concatenate([base_solution[:a], base_solution[b:c+1], base_solution[a:b], base_solution[c+1:]]),\n                np.concatenate([base_solution[:a], base_solution[b:c+1][::-1], base_solution[a:b], base_solution[c+1:]]),\n                np.concatenate([base_solution[:a], base_solution[b:c+1], base_solution[a:b][::-1], base_solution[c+1:]]),\n                np.concatenate([base_solution[:a], base_solution[b:c+1][::-1], base_solution[a:b][::-1], base_solution[c+1:]])\n            ]\n            costs = []\n            for sol in candidates:\n                cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n                costs.append(0.6*cost1 + 0.4*cost2)\n            new_solution = candidates[np.argmin(costs)]\n\n        elif operation == 'reinsertion':\n            # Node reinsertion with path optimization\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n\n            # Find optimal insertion point considering both objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for pos in range(n-1):\n                temp = np.insert(new_solution, pos, node)\n                cost1 = (distance_matrix_1[temp[pos-1], temp[pos]] + distance_matrix_1[temp[pos], temp[(pos+1)%n]] -\n                        distance_matrix_1[temp[pos-1], temp[(pos+1)%n]])\n                cost2 = (distance_matrix_2[temp[pos-1], temp[pos]] + distance_matrix_2[temp[pos], temp[(pos+1)%n]] -\n                        distance_matrix_2[temp[pos-1], temp[(pos+1)%n]])\n                total_cost = 0.7*cost1 + 0.3*cost2\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n        else:\n            # Objective-balanced edge replacement\n            # Select edges with high combined cost\n            edge_costs = []\n            for i in range(n):\n                cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]]\n                cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]]\n                edge_costs.append(0.6*cost1 + 0.4*cost2)\n            edge_costs = np.array(edge_costs)\n            top_edges = np.argsort(edge_costs)[-max(2, n//5):]\n\n            # Replace selected edges with optimal alternatives\n            for i in top_edges:\n                # Find the best replacement edge\n                best_replacement = i\n                best_cost = edge_costs[i]\n                for j in range(n):\n                    if j != i and j != (i+1)%n and j != (i-1)%n:\n                        cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]]\n                        cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]]\n                        total_cost = 0.6*cost1 + 0.4*cost2\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_replacement = j\n                if best_replacement != i:\n                    # Perform the replacement\n                    if i < best_replacement:\n                        new_solution[i:best_replacement+1] = new_solution[i:best_replacement+1][::-1]\n                    else:\n                        new_solution[best_replacement:i+1] = new_solution[best_replacement:i+1][::-1]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.381295634273116,
            6.274289197589871
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objective values and diversity, then applies a hybrid local search combining segment rotation, edge reversal, and adaptive node insertion, with different probability weights for each operation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select based on weighted sum with diversity consideration\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = [0.4, 0.6]  # Higher weight for the second objective\n    scores = [sum(w * obj for w, obj in zip(weights, normalized_obj[i])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.25, 0.45, 0.3])\n\n        if operation == 'rotation':\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            8.018738268973163,
            4.425019279293417
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment rotation, edge reversal, and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (combination of objectives and diversity)\n    weights = [0.5, 0.5]  # Equal weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple rotation\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Novel local search with adaptive probabilities\n        operation = np.random.choice(['rotation', 'reversal', 'insertion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'rotation':\n            # Segment rotation\n            length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - length)\n            segment = new_solution[start:start+length]\n            shift = np.random.randint(1, length)\n            rotated_segment = np.roll(segment, shift)\n            new_solution[start:start+length] = rotated_segment\n\n        elif operation == 'reversal':\n            # Edge reversal with adaptive selection\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(i+1, n)\n                temp_sol = new_solution.copy()\n                temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                candidates.append((i, j, cost1, cost2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n        else:\n            # Adaptive node insertion\n            candidates = []\n            for _ in range(4):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in [0, len(temp_sol)//2, len(temp_sol)-1]:\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple rotation if the operation fails\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            5.750147278743561,
            5.943542530756865
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining segment reversal, node relocation, and edge crossover with adaptive probabilities, while ensuring feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity score\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate diversity scores\n    solutions = np.array([sol for sol, _ in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        unique_pairs = set()\n        for j in range(len(solutions[i])-1):\n            unique_pairs.add((min(solutions[i][j], solutions[i][j+1]), max(solutions[i][j], solutions[i][j+1])))\n        diversity[i] = len(unique_pairs)\n\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n    scores = 0.6 * np.sum(normalized, axis=1) + 0.4 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive operation selection\n        operation_probs = [0.3, 0.25, 0.2, 0.25]  # reversal, relocation, swap, crossover\n        operation = np.random.choice(['reversal', 'relocation', 'swap', 'crossover'], p=operation_probs)\n\n        if operation == 'reversal':\n            # Multi-segment reversal\n            num_segments = np.random.randint(1, min(3, n//4))\n            segments = []\n            for _ in range(num_segments):\n                length = np.random.randint(2, min(6, n//2))\n                start = np.random.randint(0, n - length)\n                segments.append((start, start + length))\n            segments.sort()\n            for start, end in reversed(segments):\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        elif operation == 'relocation':\n            # Intelligent node relocation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(1, len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: x[2] + x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Adaptive swap with multiple candidates\n            candidates = []\n            for _ in range(8):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]) + \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                           distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff))\n\n            if candidates:\n                best_i, best_j, _ = min(candidates, key=lambda x: x[2])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # crossover\n            # Partial tour crossover with validation\n            if n > 5:\n                split1 = np.random.randint(1, n//4)\n                split2 = np.random.randint(3*n//4, n-1)\n                segment = new_solution[split1:split2]\n\n                # Create a new solution by inserting the segment at a different position\n                pos = np.random.randint(0, n - len(segment))\n                new_solution = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n\n    # Multi-step validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, try to repair by removing them\n        unique, indices = np.unique(new_solution, return_index=True)\n        if len(unique) == n:\n            new_solution = new_solution[np.sort(indices)]\n        else:\n            # If still invalid, fall back to simple swap\n            new_solution = base_solution.copy()\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.692718053711662,
            6.126902487305319
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of normalized objectives and solution quality scores, then applies a hybrid local search combining adaptive edge swapping, probabilistic node insertion, and segment reversal with cost estimation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate solution quality scores\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate solution quality scores\n    quality_scores = []\n    for i, (sol, _) in enumerate(archive):\n        n = len(sol)\n        total_cost = 0\n        for j in range(n):\n            total_cost += distance_matrix_1[sol[j-1], sol[j]] + distance_matrix_2[sol[j-1], sol[j]]\n        quality_scores.append(total_cost)\n\n    # Combine normalized objectives and quality scores for selection\n    combined_scores = [0.5*norm[0] + 0.3*norm[1] + 0.2*(qual/max(quality_scores)) for norm, qual in zip(normalized, quality_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['swap', 'insert', 'reverse'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'swap':\n            # Adaptive edge swapping\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [0.5*x[2] + 0.5*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                best_i, best_j, _, _ = candidates[selected]\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        elif operation == 'insert':\n            # Probabilistic node insertion\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n\n            # Estimate insertion costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            if costs:\n                probabilities = np.exp(-np.array(costs) / np.max(np.abs(costs)))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Segment reversal with cost estimation\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate reversal cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            # Accept with probability based on cost\n            total_cost = 0.5*cost1 + 0.5*cost2\n            if np.random.random() < 1 / (1 + np.exp(total_cost / 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.597751520720218,
            8.068557995811494
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution structure entropy, then applies a hybrid local search combining adaptive segment rotation, node chain insertion, and probabilistic edge flipping with cost-sensitive acceptance to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate solution structure entropy and combine with objectives\n    def calculate_entropy(sol):\n        n = len(sol)\n        entropy = 0.0\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            dist1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            dist2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            entropy += abs(dist1 - dist2) / (dist1 + dist2 + 1e-10)\n        return entropy / n\n\n    weights = [0.5, 0.3, 0.2]  # Weights for objectives and entropy\n    scores = []\n    for sol, obj in archive:\n        entropy = calculate_entropy(sol)\n        score = weights[0] * obj[0] + weights[1] * obj[1] + weights[2] * entropy\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['rotation', 'chain', 'flip'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'rotation':\n            # Adaptive segment rotation\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n            k = np.random.randint(1, len(segment))\n            rotated = np.concatenate([segment[k:], segment[:k]])\n            new_solution[start:end+1] = rotated\n\n        elif operation == 'chain':\n            # Node chain insertion\n            chain_length = min(3, n//2)\n            chain = np.random.choice(new_solution, size=chain_length, replace=False)\n            new_solution = new_solution[~np.isin(new_solution, chain)]\n            insert_pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, insert_pos, chain)\n\n        else:\n            # Probabilistic edge flipping\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                total_cost = weights[0]*cost1 + weights[1]*cost2\n                if np.random.random() < 1 / (1 + np.exp(total_cost / 5)):\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.875422573298113,
            7.214763236078257
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid of objective dominance and adaptive path length, then applies a novel combination of segment-based relocation, probabilistic edge swapping with cost estimation, and dynamic segment inversion with temperature-based acceptance to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on dominance and path length\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n = len(solutions[0])\n\n    # Calculate dominance counts and path lengths\n    dominance = np.zeros(len(archive))\n    path_lengths = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if all(objectives[i] <= objectives[j]) and any(objectives[i] < objectives[j]):\n                dominance[i] += 1\n        path_lengths[i] = sum(distance_matrix_1[solutions[i][k], solutions[i][(k+1)%n]] for k in range(n))\n\n    # Normalize and combine metrics\n    norm_dominance = (dominance - np.min(dominance)) / (np.max(dominance) - np.min(dominance) + 1e-10)\n    norm_length = (path_lengths - np.min(path_lengths)) / (np.max(path_lengths) - np.min(path_lengths) + 1e-10)\n    scores = 0.6 * norm_dominance + 0.4 * (1 - norm_length)  # Prefer non-dominated with shorter paths\n    selected_idx = np.argmax(scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic temperature for acceptance\n    temp = 1.0 / (1 + np.exp(-0.1 * (np.max(path_lengths) - np.min(path_lengths))))\n\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        operation = np.random.choice(['segment_relocation', 'edge_swap', 'dynamic_inversion'], p=[0.35, 0.35, 0.3])\n\n        if operation == 'segment_relocation':\n            # Segment-based relocation with cost estimation\n            seg_size = max(2, min(5, np.random.randint(1, n//2)))\n            start = np.random.randint(0, n - seg_size)\n            segment = new_solution[start:start+seg_size]\n            new_solution = np.delete(new_solution, slice(start, start+seg_size))\n\n            # Estimate insertion costs\n            costs = []\n            for i in range(len(new_solution)):\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n                seg_start = segment[0]\n                seg_end = segment[-1]\n                cost1 = distance_matrix_1[prev_node, seg_start] + distance_matrix_1[seg_end, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, seg_start] + distance_matrix_2[seg_end, next_node] - distance_matrix_2[prev_node, next_node]\n                costs.append(cost1 + cost2)\n\n            if costs:\n                probabilities = np.exp(-np.array(costs) / (temp * np.max(np.abs(costs))))\n                probabilities = probabilities / np.sum(probabilities)\n                insert_pos = np.random.choice(len(new_solution), p=probabilities)\n                new_solution = np.insert(new_solution, insert_pos, segment)\n\n        elif operation == 'edge_swap':\n            # Probabilistic edge swapping with cost estimation\n            candidates = []\n            for _ in range(5):\n                i = np.random.randint(0, n)\n                j = np.random.randint(0, n)\n                if i > j:\n                    i, j = j, i\n                cost_diff_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                costs = [0.5*x[2] + 0.5*x[3] for x in candidates]\n                probabilities = np.exp(-np.array(costs) / (temp * np.max(np.abs(costs))))\n                probabilities = probabilities / np.sum(probabilities)\n                selected = np.random.choice(len(candidates), p=probabilities)\n                i, j, _, _ = candidates[selected]\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        else:\n            # Dynamic segment inversion with temperature-based acceptance\n            start = np.random.randint(0, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end+1]\n\n            # Estimate inversion cost\n            cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(end+1)%n]])\n            cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(end+1)%n]] - \\\n                   (distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(end+1)%n]])\n\n            total_cost = 0.5*cost1 + 0.5*cost2\n            if np.random.random() < np.exp(-total_cost / (temp * 10)):\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.055332689107308,
            10.38094659927301
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a combined scoring function that balances individual and normalized objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by a weighted combination of both distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective costs\n    max_cost1 = max(x[1][0] for x in archive)\n    max_cost2 = max(x[1][1] for x in archive)\n    selected_solution = min(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    # Hybrid local search with weighted distance matrices\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n    weight = 0.7  # Weight for first objective\n\n    # Weighted edge swap\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = weight * (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = weight * (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Weighted segment reversal\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = weight * (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                      (1-weight) * (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        cost_after = weight * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]) + \\\n                     (1-weight) * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.378248078639395,
            6.520534410351125
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap', 'cross'], p=[0.3, 0.3, 0.2, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with variable length\n            length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - length)\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with multiple candidates\n            candidates = []\n            for _ in range(3):\n                i = np.random.randint(0, n)\n                node = new_solution[i]\n                temp_sol = np.delete(new_solution, i)\n                for pos in range(len(temp_sol)):\n                    temp = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    candidates.append((pos, i, cost1, cost2))\n\n            if candidates:\n                best_pos, best_i, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                node = new_solution[best_i]\n                new_solution = np.delete(new_solution, best_i)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n        elif operation == 'swap':\n            # Node swap with multiple candidates\n            candidates = []\n            for _ in range(5):\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            if candidates:\n                best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n                new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n        else:  # cross operation\n            # Cross two segments from different parts of the tour\n            if n > 5:\n                split1 = np.random.randint(1, n//2)\n                split2 = np.random.randint(n//2, n-1)\n                new_solution = np.concatenate([new_solution[:split1], new_solution[split2:], new_solution[split1:split2]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.152844388311375,
            6.740554780218728
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute selection score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = [0.7, 0.3]  # Higher weight for the first objective\n    scores = np.sum(normalized_obj * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.2980857848189915,
            8.823846319133366
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a different scoring function that prioritizes solutions with lower individual objective costs, then applies a hybrid local search combining randomized edge-swaps and segment reversals guided by the combined distance matrices from both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower individual objective costs\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Random edge-swap and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random edge swap with objective-specific distance guidance\n    if n > 2:\n        a, b = np.random.choice(n, 2, replace=False)\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] + \\\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[b]] + \\\n                     distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment reversal with combined objective guidance\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 1, n - 1)\n\n        cost_before = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        cost_after = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + \\\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        if cost_after < cost_before:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            5.882148247503805,
            5.573371685601349
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and dominance rank, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives and dominance rank)\n    weights = [0.6, 0.4]  # Weight for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, archive[i][1])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search with adaptive probabilities\n        operation = np.random.choice(['reversal', 'insertion', 'swap'], p=[0.4, 0.3, 0.3])\n\n        if operation == 'reversal':\n            # Segment reversal\n            start = np.random.randint(0, n - 3)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        elif operation == 'insertion':\n            # Edge insertion\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        else:\n            # Node swap with adaptive selection\n            candidates = []\n            for _ in range(5):  # Sample 5 candidate pairs\n                i, j = np.random.choice(n, size=2, replace=False)\n                cost_diff_1 = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n                cost_diff_2 = (distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                             distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n                candidates.append((i, j, cost_diff_1, cost_diff_2))\n\n            # Select the best candidate based on weighted cost difference\n            best_i, best_j, _, _ = min(candidates, key=lambda x: weights[0]*x[2] + weights[1]*x[3])\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.269032493474907,
            6.698653434636116
        ]
    }
]