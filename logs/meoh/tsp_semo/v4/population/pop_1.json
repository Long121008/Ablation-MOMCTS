[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating the Pareto dominance or crowding distance, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or with high crowding distance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to reverse\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Insert a randomly selected edge elsewhere\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to simple swap if the hybrid operation fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.81732381730226,
            7.03853118445488
        ]
    },
    {
        "algorithm": "{A hybrid local search heuristic that intelligently selects a solution from the archive based on objective diversity and applies a novel two-phase perturbation: first, a multi-swap operation guided by Pareto dominance in both objective spaces, followed by a local refinement step that optimizes the tour structure while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        # Calculate the spread of objectives\n        obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select a solution with high diversity\n        diversity_scores = np.sum((objectives - np.mean(objectives, axis=0)) ** 2 / (obj_range + 1e-10), axis=1)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Phase 1: Multi-swap operation\n    n = len(new_solution)\n    if n > 2:\n        # Select 3 random positions\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        # Perform a 3-opt like swap\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Phase 2: Local refinement\n    if n > 3:\n        # Find the worst edge in both objectives\n        worst_edge = -1\n        worst_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            total_cost = cost1 + cost2\n            if total_cost > worst_cost:\n                worst_cost = total_cost\n                worst_edge = i\n\n        if worst_edge != -1:\n            # Find the best possible insertion point for the worst edge\n            a, b, c = worst_edge, (worst_edge + 1) % n, (worst_edge + 2) % n\n            best_improvement = 0\n            best_insert = -1\n\n            for i in range(n):\n                if i == a or i == b or i == c:\n                    continue\n                # Try inserting node b between i and i+1\n                new_cost1 = (distance_matrix_1[new_solution[i], new_solution[b]] +\n                            distance_matrix_1[new_solution[b], new_solution[(i + 1) % n]] -\n                            distance_matrix_1[new_solution[i], new_solution[(i + 1) % n]])\n                new_cost2 = (distance_matrix_2[new_solution[i], new_solution[b]] +\n                            distance_matrix_2[new_solution[b], new_solution[(i + 1) % n]] -\n                            distance_matrix_2[new_solution[i], new_solution[(i + 1) % n]])\n                improvement = worst_cost - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insert = i\n\n            if best_insert != -1:\n                # Perform the insertion\n                temp = new_solution[b]\n                if best_insert < a:\n                    new_solution = np.concatenate([\n                        new_solution[:best_insert + 1],\n                        [temp],\n                        new_solution[best_insert + 1:a],\n                        new_solution[b + 1:]\n                    ])\n                else:\n                    new_solution = np.concatenate([\n                        new_solution[:a],\n                        new_solution[b + 1:best_insert + 1],\n                        [temp],\n                        new_solution[best_insert + 1:]\n                    ])\n\n    return new_solution\n\n",
        "score": [
            10.506875125923836,
            10.629489704257072
        ]
    }
]