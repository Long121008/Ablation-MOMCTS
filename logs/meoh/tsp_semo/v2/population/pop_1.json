[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive based on a heuristic that combines Pareto dominance and solution diversity, then applies a hybrid local search operator that combines a novel edge insertion strategy with a randomized 3-opt move to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a heuristic that balances Pareto dominance and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + randomized 3-opt\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Edge insertion (novel operator)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i == j:\n        j = (j + 1) % n\n\n    # Remove edge (i, (i+1)%n) and (j, (j+1)%n)\n    # Insert (i, j) and (i+1, j+1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomized 3-opt (for diversification)\n    a, b, c = sorted(random.sample(range(n), 3))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.317942724324657,
            7.040983408168405
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: a combination of node insertion and edge reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent nodes to reverse the sub-tour between them\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j - 1:  # Ensure they are not adjacent\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node and insert it into a different position\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            10.546381917564625,
            10.587789897720583
        ]
    }
]