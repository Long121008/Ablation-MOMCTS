[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and tour structure, then applies a novel hybrid local search operator that combines a multi-segment inversion with a guided node swapping mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    obj_scores = [obj[0] * obj[1] for obj in objectives]\n    total_score = sum(obj_scores)\n    probabilities = [score / total_score for score in obj_scores] if total_score > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal with objective-aware selection\n    num_segments = random.randint(2, min(4, n // 2))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Evaluate segments based on their contribution to both objectives\n    segment_scores = []\n    for seg in segments:\n        total_cost = 0\n        for i in range(len(seg)):\n            node = seg[i]\n            prev_node = seg[i - 1] if i > 0 else new_solution[np.where(new_solution == seg[0])[0][0] - 1]\n            next_node = seg[i + 1] if i < len(seg) - 1 else new_solution[(np.where(new_solution == seg[-1])[0][0] + 1) % n]\n            total_cost += (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n        segment_scores.append(total_cost)\n\n    # Sort segments by score and reverse the worst half\n    sorted_indices = np.argsort(segment_scores)\n    for i in range(len(sorted_indices) // 2):\n        segments[sorted_indices[i]] = segments[sorted_indices[i]][::-1]\n\n    new_solution = np.concatenate(segments)\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        insert_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            if cost > max_cost:\n                max_cost = cost\n                insert_node = i\n\n        if insert_node != -1:\n            # Remove the node and find best insertion point\n            node_to_insert = new_solution[insert_node]\n            new_solution = np.delete(new_solution, insert_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate cost of inserting between i and i+1\n                cost = (distance_matrix_1[node_to_insert, new_solution[i]] +\n                       distance_matrix_1[node_to_insert, new_solution[(i + 1) % (n - 1)]] +\n                       distance_matrix_2[node_to_insert, new_solution[i]] +\n                       distance_matrix_2[node_to_insert, new_solution[(i + 1) % (n - 1)]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.189418805116094,
            5.61707276442867
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values, then applies a novel hybrid local search that combines node swapping with a dynamic sub-tour reversal strategy, ensuring feasibility while exploring diverse neighborhoods in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - min(x[1][0], x[1][1]) / max(x[1][0], x[1][1])))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic sub-tour reversal based on distance matrix analysis\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j - 1:\n        # Reverse sub-tour only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node swapping with objective-aware selection\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        # Swap nodes only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.447495483045565,
            9.257948291932776
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation operator with a probabilistic edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'prob_insert'])\n\n    if operator == 'rotate':\n        # Segment rotation (novel operator)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        rotated = np.roll(segment, k - i)\n        new_solution[i:j+1] = rotated\n\n    elif operator == 'prob_insert':\n        # Probabilistic edge insertion (novel operator)\n        a, b = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            # Insert node a between b and its successor\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            pos = (b + 1) % n\n            new_solution = np.insert(new_solution, pos, node)\n        else:\n            # Insert node b between a and its successor\n            node = new_solution[b]\n            new_solution = np.delete(new_solution, b)\n            pos = (a + 1) % n\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.8163101237854455,
            6.55605786123142
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and tour properties, then applies a novel local search operator combining adaptive edge swapping, dynamic segment reversal, and guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective values\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate weighted scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Weighted sum of objectives with random perturbation\n        weight = 0.6 if obj[0] < obj[1] else 0.4\n        score = weight * obj[0] + (1 - weight) * obj[1]\n        score += random.uniform(0, 0.05)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using adaptive local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive operator selection based on solution quality\n    if len(archive) > 5:\n        operator = random.choices(['swap', 'reverse', 'insert'], weights=[0.4, 0.4, 0.2])[0]\n    else:\n        operator = random.choice(['swap', 'reverse'])\n\n    if operator == 'swap':\n        # Adaptive edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        # Check if swap improves both objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'reverse':\n        # Dynamic segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        # Check if reversal improves both objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[i]]) - \\\n                (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[i]]) - \\\n                (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        # Guided node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Check if insertion improves both objectives\n            node = new_solution[i]\n            delta1 = (distance_matrix_1[new_solution[(j-1)%n], node] +\n                     distance_matrix_1[node, new_solution[j]]) - \\\n                    (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[(j-1)%n], node] +\n                     distance_matrix_2[node, new_solution[j]]) - \\\n                    (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n            if delta1 < 0 or delta2 < 0:\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            5.818582897440585,
            5.777169995105164
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search operator combining edge swapping, segment reversal, and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three operators\n    operator = random.choice(['swap', 'reverse', 'insert'])\n\n    if operator == 'swap':\n        # Edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'reverse':\n        # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        # Node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            6.0843578326115075,
            6.11521640805595
        ]
    },
    {
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a combination of objective values and tour properties, then applies a novel local search operator that combines multiple edge exchanges, segment rotations, and node relocations, while ensuring feasibility by carefully validating each move to maintain a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of four operators\n    operator = random.choice(['multi_swap', 'segment_rotate', 'node_relocate', 'double_reverse'])\n\n    if operator == 'multi_swap':\n        # Multiple edge swaps\n        num_swaps = random.randint(2, min(5, n//2))\n        indices = random.sample(range(n), num_swaps*2)\n        for i in range(0, num_swaps*2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n    elif operator == 'segment_rotate':\n        # Segment rotation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        rotated = np.roll(segment, k-i)\n        new_solution[i:j+1] = rotated\n\n    elif operator == 'node_relocate':\n        # Node relocation with multiple positions\n        i = random.randint(0, n-1)\n        positions = sorted(random.sample(range(n), 3))\n        for pos in positions:\n            if pos != i:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, pos, node)\n                break\n\n    elif operator == 'double_reverse':\n        # Double segment reversal\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n        new_solution[i1:j1+1] = new_solution[i1:j1+1][::-1]\n        new_solution[i2:j2+1] = new_solution[i2:j2+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.0952846011366635,
            5.928893277344715
        ]
    },
    {
        "algorithm": "{The new algorithm combines the ideas of selective node swapping with a dynamic edge reversal strategy, guided by a multi-objective improvement potential assessment to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * random.uniform(0.8, 1.2))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge reversal based on objective improvement potential\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Calculate potential improvement in both objectives\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            reversed_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Apply reversal if it improves at least one objective\n            if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Selective node swapping based on distance reduction\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        # Calculate potential improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Apply swap if it improves at least one objective\n        if (swapped_cost1 < original_cost1) or (swapped_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.04639647100613,
            8.254628272033251
        ]
    },
    {
        "algorithm": "{The new algorithm uses a hybrid approach combining dynamic edge reversal with adaptive node insertion, guided by a weighted objective improvement metric that balances exploration and exploitation to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * random.uniform(0.9, 1.1))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge reversal with weighted improvement threshold\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            reversed_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            if (reversed_cost1 < original_cost1 * 0.95) or (reversed_cost2 < original_cost2 * 0.95):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Adaptive node insertion based on distance reduction\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        # Try inserting node a after node b\n        if b + 1 < n:\n            inserted_cost1 = distance_matrix_1[new_solution[a-1], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n            inserted_cost2 = distance_matrix_2[new_solution[a-1], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n            if (inserted_cost1 < original_cost1 * 0.9) or (inserted_cost2 < original_cost2 * 0.9):\n                new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [new_solution[a]], new_solution[b+1:]])\n\n    return new_solution\n\n",
        "score": [
            9.37668596722072,
            6.067150083448338
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective diversity and tour characteristics, then applies a hybrid local search combining edge crossing, segment rotation, and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [obj[0] - obj[1] for obj in objectives]\n    selected_idx = np.argmax(np.abs(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three operators\n    operator = random.choice(['cross', 'rotate', 'relocate'])\n\n    if operator == 'cross':\n        # Edge crossing\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if i > 0 and j < n-1:\n            new_solution[i+1], new_solution[j-1] = new_solution[j-1], new_solution[i+1]\n\n    elif operator == 'rotate':\n        # Segment rotation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        rotated = np.roll(segment, k-i)\n        new_solution[i:j+1] = rotated\n\n    elif operator == 'relocate':\n        # Node relocation with path optimization\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            if j == 0:\n                new_solution = np.insert(new_solution, j, node)\n            else:\n                # Find optimal insertion point\n                best_pos = j\n                best_cost = float('inf')\n                for pos in range(max(0, j-1), min(n-1, j+1)+1):\n                    temp = np.insert(new_solution, pos, node)\n                    cost1 = distance_matrix_1[temp[pos-1], temp[pos]] + distance_matrix_1[temp[pos], temp[(pos+1)%n]]\n                    cost2 = distance_matrix_2[temp[pos-1], temp[pos]] + distance_matrix_2[temp[pos], temp[(pos+1)%n]]\n                    total_cost = cost1 + cost2\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.944358562882848,
            8.760526609743106
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values, then applies a novel hybrid local search that combines node swapping with a dynamic sub-tour reversal strategy, ensuring feasibility while exploring diverse neighborhoods in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - min(x[1][0], x[1][1]) / max(x[1][0], x[1][1])))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic sub-tour reversal based on distance matrix analysis\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j - 1:\n        # Reverse sub-tour only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node swapping with objective-aware selection\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        # Swap nodes only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.447495483045565,
            9.257948291932776
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and tour structure, then applies a novel hybrid local search operator that combines a multi-segment inversion with a guided node swapping mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    obj_scores = [obj[0] * obj[1] for obj in objectives]\n    total_score = sum(obj_scores)\n    probabilities = [score / total_score for score in obj_scores] if total_score > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal with objective-aware selection\n    num_segments = random.randint(2, min(4, n // 2))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Evaluate segments based on their contribution to both objectives\n    segment_scores = []\n    for seg in segments:\n        total_cost = 0\n        for i in range(len(seg)):\n            node = seg[i]\n            prev_node = seg[i - 1] if i > 0 else new_solution[np.where(new_solution == seg[0])[0][0] - 1]\n            next_node = seg[i + 1] if i < len(seg) - 1 else new_solution[(np.where(new_solution == seg[-1])[0][0] + 1) % n]\n            total_cost += (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n        segment_scores.append(total_cost)\n\n    # Sort segments by score and reverse the worst half\n    sorted_indices = np.argsort(segment_scores)\n    for i in range(len(sorted_indices) // 2):\n        segments[sorted_indices[i]] = segments[sorted_indices[i]][::-1]\n\n    new_solution = np.concatenate(segments)\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        insert_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            if cost > max_cost:\n                max_cost = cost\n                insert_node = i\n\n        if insert_node != -1:\n            # Remove the node and find best insertion point\n            node_to_insert = new_solution[insert_node]\n            new_solution = np.delete(new_solution, insert_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate cost of inserting between i and i+1\n                cost = (distance_matrix_1[node_to_insert, new_solution[i]] +\n                       distance_matrix_1[node_to_insert, new_solution[(i + 1) % (n - 1)]] +\n                       distance_matrix_2[node_to_insert, new_solution[i]] +\n                       distance_matrix_2[node_to_insert, new_solution[(i + 1) % (n - 1)]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.189418805116094,
            5.61707276442867
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values, then applies a novel hybrid local search that combines node swapping with a dynamic sub-tour reversal strategy, ensuring feasibility while exploring diverse neighborhoods in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - min(x[1][0], x[1][1]) / max(x[1][0], x[1][1])))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic sub-tour reversal based on distance matrix analysis\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j - 1:\n        # Reverse sub-tour only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node swapping with objective-aware selection\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        # Swap nodes only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.447495483045565,
            9.257948291932776
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values, then applies a novel hybrid local search that combines node swapping with a dynamic sub-tour reversal strategy, ensuring feasibility while exploring diverse neighborhoods in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - min(x[1][0], x[1][1]) / max(x[1][0], x[1][1])))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic sub-tour reversal based on distance matrix analysis\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j - 1:\n        # Reverse sub-tour only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node swapping with objective-aware selection\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        # Swap nodes only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.447495483045565,
            9.257948291932776
        ]
    }
]