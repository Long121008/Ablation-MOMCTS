[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized and diversified scoring mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.6 * normalized_obj1 + 0.4 * normalized_obj2\n        score += random.uniform(0, 0.3)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.98) or (new_cost2 < original_cost2 * 0.98):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            4.918643849521373,
            7.3744016029834665
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment transposition with a probabilistic node insertion strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['transpose', 'insert'])\n\n    if operator == 'transpose':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'insert':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            6.151676686868733,
            5.586187887054014
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of normalized objective values and solution diversity, then applies a hybrid local search combining adaptive segment reversal with probabilistic edge swapping and node relocation, while ensuring tour feasibility through careful validation of all operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique, counts = np.unique(sol, return_counts=True)\n        d = len(unique) / len(sol)\n        diversity.append(d)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.7 + norm_obj2[i] * 0.3) * (1 + random.uniform(-0.1, 0.1)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'relocate', 'swap'], weights=[0.5, 0.3, 0.2])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            if len(segment) % 2 == 0:\n                segment = segment[::-1]\n            new_solution[i:j+1] = segment\n\n    elif operator == 'relocate':\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.3524167455317535,
            9.032523350035685
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized and diversified scoring mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.6 * normalized_obj1 + 0.4 * normalized_obj2\n        score += random.uniform(0, 0.3)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.98) or (new_cost2 < original_cost2 * 0.98):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            4.918643849521373,
            7.3744016029834665
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of normalized objective values and solution diversity, then applies a hybrid local search combining adaptive segment reversal with probabilistic edge swapping and node relocation, while ensuring tour feasibility through careful validation of all operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique, counts = np.unique(sol, return_counts=True)\n        d = len(unique) / len(sol)\n        diversity.append(d)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.7 + norm_obj2[i] * 0.3) * (1 + random.uniform(-0.1, 0.1)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'relocate', 'swap'], weights=[0.5, 0.3, 0.2])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            if len(segment) % 2 == 0:\n                segment = segment[::-1]\n            new_solution[i:j+1] = segment\n\n    elif operator == 'relocate':\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.3524167455317535,
            9.032523350035685
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment transposition with a probabilistic node insertion strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['transpose', 'insert'])\n\n    if operator == 'transpose':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'insert':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            6.151676686868733,
            5.586187887054014
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized and diversified scoring mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.6 * normalized_obj1 + 0.4 * normalized_obj2\n        score += random.uniform(0, 0.3)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.98) or (new_cost2 < original_cost2 * 0.98):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            4.918643849521373,
            7.3744016029834665
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a novel hybrid local search combining a probabilistic segment rotation with an adaptive node swapping strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform rotation\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Adaptive node swapping with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.669860895136936,
            5.940952547723558
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment shuffling, guided node permutation, and probabilistic edge inversion while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        edge_counts = {}\n        for i in range(len(sol)):\n            edge = tuple(sorted((sol[i], sol[(i+1)%len(sol)])))\n            edge_counts[edge] = edge_counts.get(edge, 0) + 1\n        diversity.append(sum(1 for v in edge_counts.values() if v == 1) / len(sol))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.4 + norm_obj2[i] * 0.6) * (1 + random.uniform(-0.2, 0.2)) + diversity[i] * 0.5\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['shuffle', 'permute', 'invert'], weights=[0.3, 0.5, 0.2])[0]\n\n    if operator == 'shuffle':\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        np.random.shuffle(segment)\n        new_solution[i:j+1] = segment\n\n    elif operator == 'permute':\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        segment = np.roll(segment, (k-i+1) % len(segment))\n        new_solution[i:j+1] = segment\n\n    elif operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.5219305133892576,
            4.621466734883777
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized and diversified scoring mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.6 * normalized_obj1 + 0.4 * normalized_obj2\n        score += random.uniform(0, 0.3)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.98) or (new_cost2 < original_cost2 * 0.98):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            4.918643849521373,
            7.3744016029834665
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, probabilistic node swapping, and guided edge insertion while preserving tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        freq = np.zeros(len(sol))\n        for i in range(len(sol)):\n            freq[sol[i]] += 1\n        p = freq / len(sol)\n        entropy.append(-np.sum(p * np.log(p + 1e-8)))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.4 + norm_obj2[i] * 0.6) * (1 + random.uniform(-0.1, 0.1)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'swap', 'insert'], weights=[0.35, 0.35, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.09520545204995,
            5.032752218113311
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized and diversified scoring mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.6 * normalized_obj1 + 0.4 * normalized_obj2\n        score += random.uniform(0, 0.3)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.98) or (new_cost2 < original_cost2 * 0.98):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            4.918643849521373,
            7.3744016029834665
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_nodes = len(np.unique(sol))\n        diversity.append(unique_nodes / len(sol))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.1, 0.1)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.3, 0.4, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.540053110045133,
            5.535641978171212
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized and diversified scoring mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.6 * normalized_obj1 + 0.4 * normalized_obj2\n        score += random.uniform(0, 0.3)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.98) or (new_cost2 < original_cost2 * 0.98):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            4.918643849521373,
            7.3744016029834665
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a probabilistic scoring mechanism that combines objective values with solution diversity, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.3 * normalized_obj1 + 0.7 * normalized_obj2\n        score += random.uniform(0, 0.4)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.9) or (new_cost2 < original_cost2 * 0.9):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.236059773555326,
            4.277353385118487
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized and diversified scoring mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.6 * normalized_obj1 + 0.4 * normalized_obj2\n        score += random.uniform(0, 0.3)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.98) or (new_cost2 < original_cost2 * 0.98):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            4.918643849521373,
            7.3744016029834665
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.979014969172338,
            5.6515884234515195
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = 0.7 * obj[0] + 0.3 * obj[1]\n        score += random.uniform(0, 0.2)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1 * 0.90) or (new_cost2 < original_cost2 * 0.90):\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            4.748324991479499,
            7.419329630196175
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized and diversified scoring mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a segment inversion with a probabilistic edge exchange strategy, while ensuring feasibility through careful tour structure validation and bi-objective improvement checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0: max_obj1 = 1\n    if max_obj2 == 0: max_obj2 = 1\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        normalized_obj1 = obj[0] / max_obj1\n        normalized_obj2 = obj[1] / max_obj2\n        score = 0.6 * normalized_obj1 + 0.4 * normalized_obj2\n        score += random.uniform(0, 0.3)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'exchange'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.98) or (new_cost2 < original_cost2 * 0.98):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'exchange':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            4.918643849521373,
            7.3744016029834665
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and tour structure, then applies a novel hybrid local search operator that combines a multi-segment inversion with a guided node swapping mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    obj_scores = [obj[0] * obj[1] for obj in objectives]\n    total_score = sum(obj_scores)\n    probabilities = [score / total_score for score in obj_scores] if total_score > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal with objective-aware selection\n    num_segments = random.randint(2, min(4, n // 2))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Evaluate segments based on their contribution to both objectives\n    segment_scores = []\n    for seg in segments:\n        total_cost = 0\n        for i in range(len(seg)):\n            node = seg[i]\n            prev_node = seg[i - 1] if i > 0 else new_solution[np.where(new_solution == seg[0])[0][0] - 1]\n            next_node = seg[i + 1] if i < len(seg) - 1 else new_solution[(np.where(new_solution == seg[-1])[0][0] + 1) % n]\n            total_cost += (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n        segment_scores.append(total_cost)\n\n    # Sort segments by score and reverse the worst half\n    sorted_indices = np.argsort(segment_scores)\n    for i in range(len(sorted_indices) // 2):\n        segments[sorted_indices[i]] = segments[sorted_indices[i]][::-1]\n\n    new_solution = np.concatenate(segments)\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        insert_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            if cost > max_cost:\n                max_cost = cost\n                insert_node = i\n\n        if insert_node != -1:\n            # Remove the node and find best insertion point\n            node_to_insert = new_solution[insert_node]\n            new_solution = np.delete(new_solution, insert_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate cost of inserting between i and i+1\n                cost = (distance_matrix_1[node_to_insert, new_solution[i]] +\n                       distance_matrix_1[node_to_insert, new_solution[(i + 1) % (n - 1)]] +\n                       distance_matrix_2[node_to_insert, new_solution[i]] +\n                       distance_matrix_2[node_to_insert, new_solution[(i + 1) % (n - 1)]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.5434933428581035,
            5.4801909366980315
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = 0.7 * obj[0] + 0.3 * obj[1]\n        score += random.uniform(0, 0.2)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1 * 0.90) or (new_cost2 < original_cost2 * 0.90):\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            4.748324991479499,
            7.419329630196175
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and tour structure, then applies a novel hybrid local search operator that combines a multi-segment inversion with a guided node swapping mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    obj_scores = [obj[0] * obj[1] for obj in objectives]\n    total_score = sum(obj_scores)\n    probabilities = [score / total_score for score in obj_scores] if total_score > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal with objective-aware selection\n    num_segments = random.randint(2, min(4, n // 2))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Evaluate segments based on their contribution to both objectives\n    segment_scores = []\n    for seg in segments:\n        total_cost = 0\n        for i in range(len(seg)):\n            node = seg[i]\n            prev_node = seg[i - 1] if i > 0 else new_solution[np.where(new_solution == seg[0])[0][0] - 1]\n            next_node = seg[i + 1] if i < len(seg) - 1 else new_solution[(np.where(new_solution == seg[-1])[0][0] + 1) % n]\n            total_cost += (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n        segment_scores.append(total_cost)\n\n    # Sort segments by score and reverse the worst half\n    sorted_indices = np.argsort(segment_scores)\n    for i in range(len(sorted_indices) // 2):\n        segments[sorted_indices[i]] = segments[sorted_indices[i]][::-1]\n\n    new_solution = np.concatenate(segments)\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        insert_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            if cost > max_cost:\n                max_cost = cost\n                insert_node = i\n\n        if insert_node != -1:\n            # Remove the node and find best insertion point\n            node_to_insert = new_solution[insert_node]\n            new_solution = np.delete(new_solution, insert_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate cost of inserting between i and i+1\n                cost = (distance_matrix_1[node_to_insert, new_solution[i]] +\n                       distance_matrix_1[node_to_insert, new_solution[(i + 1) % (n - 1)]] +\n                       distance_matrix_2[node_to_insert, new_solution[i]] +\n                       distance_matrix_2[node_to_insert, new_solution[(i + 1) % (n - 1)]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.5434933428581035,
            5.4801909366980315
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and tour structure, then applies a novel hybrid local search operator that combines a multi-segment inversion with a guided node swapping mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and structure\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probability based on objective diversity and structure\n    obj_scores = [obj[0] * obj[1] for obj in objectives]\n    total_score = sum(obj_scores)\n    probabilities = [score / total_score for score in obj_scores] if total_score > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal with objective-aware selection\n    num_segments = random.randint(2, min(4, n // 2))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Evaluate segments based on their contribution to both objectives\n    segment_scores = []\n    for seg in segments:\n        total_cost = 0\n        for i in range(len(seg)):\n            node = seg[i]\n            prev_node = seg[i - 1] if i > 0 else new_solution[np.where(new_solution == seg[0])[0][0] - 1]\n            next_node = seg[i + 1] if i < len(seg) - 1 else new_solution[(np.where(new_solution == seg[-1])[0][0] + 1) % n]\n            total_cost += (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n        segment_scores.append(total_cost)\n\n    # Sort segments by score and reverse the worst half\n    sorted_indices = np.argsort(segment_scores)\n    for i in range(len(sorted_indices) // 2):\n        segments[sorted_indices[i]] = segments[sorted_indices[i]][::-1]\n\n    new_solution = np.concatenate(segments)\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        insert_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            if cost > max_cost:\n                max_cost = cost\n                insert_node = i\n\n        if insert_node != -1:\n            # Remove the node and find best insertion point\n            node_to_insert = new_solution[insert_node]\n            new_solution = np.delete(new_solution, insert_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate cost of inserting between i and i+1\n                cost = (distance_matrix_1[node_to_insert, new_solution[i]] +\n                       distance_matrix_1[node_to_insert, new_solution[(i + 1) % (n - 1)]] +\n                       distance_matrix_2[node_to_insert, new_solution[i]] +\n                       distance_matrix_2[node_to_insert, new_solution[(i + 1) % (n - 1)]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.510640997259852,
            6.4455562078966775
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a novel local search strategy combining adaptive segment inversion with guided node reinsertion, using a probabilistic acceptance criterion that considers both objective improvements and tour diversity to ensure feasible and high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.1, 0.1))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['invert', 'reinsert'], weights=[0.6, 0.4])[0]\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        inverted = segment[::-1]\n        new_solution[i:j+1] = inverted\n\n        original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        if (new_cost1 > original_cost1 and new_cost2 > original_cost2) or random.random() < 0.1:\n            new_solution[i:j+1] = segment\n\n    elif operator == 'reinsert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        original_cost1 = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        original_cost2 = sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        if (new_cost1 > original_cost1 and new_cost2 > original_cost2) or random.random() < 0.2:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.535945065345723,
            7.994269513804637
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and tour structure, then applies a novel hybrid local search operator that combines a multi-segment inversion with a guided node swapping mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    obj_scores = [obj[0] * obj[1] for obj in objectives]\n    total_score = sum(obj_scores)\n    probabilities = [score / total_score for score in obj_scores] if total_score > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal with objective-aware selection\n    num_segments = random.randint(2, min(4, n // 2))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Evaluate segments based on their contribution to both objectives\n    segment_scores = []\n    for seg in segments:\n        total_cost = 0\n        for i in range(len(seg)):\n            node = seg[i]\n            prev_node = seg[i - 1] if i > 0 else new_solution[np.where(new_solution == seg[0])[0][0] - 1]\n            next_node = seg[i + 1] if i < len(seg) - 1 else new_solution[(np.where(new_solution == seg[-1])[0][0] + 1) % n]\n            total_cost += (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n        segment_scores.append(total_cost)\n\n    # Sort segments by score and reverse the worst half\n    sorted_indices = np.argsort(segment_scores)\n    for i in range(len(sorted_indices) // 2):\n        segments[sorted_indices[i]] = segments[sorted_indices[i]][::-1]\n\n    new_solution = np.concatenate(segments)\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        insert_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            if cost > max_cost:\n                max_cost = cost\n                insert_node = i\n\n        if insert_node != -1:\n            # Remove the node and find best insertion point\n            node_to_insert = new_solution[insert_node]\n            new_solution = np.delete(new_solution, insert_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate cost of inserting between i and i+1\n                cost = (distance_matrix_1[node_to_insert, new_solution[i]] +\n                       distance_matrix_1[node_to_insert, new_solution[(i + 1) % (n - 1)]] +\n                       distance_matrix_2[node_to_insert, new_solution[i]] +\n                       distance_matrix_2[node_to_insert, new_solution[(i + 1) % (n - 1)]])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.5434933428581035,
            5.4801909366980315
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, ensuring feasibility by validating all moves based on Pareto improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] * obj[1]  # Product of objectives to favor balanced improvements\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        # Segment rotation with bi-objective validation\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Check if rotation improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        # Probabilistic edge swap with bi-objective validation\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform edge swap\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.962713270295118,
            5.132266489610571
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour diversity, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.3, 0.3)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.5, 0.25, 0.25])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.415932851083184,
            5.565485237265238
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] + obj[1]\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'swap'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[k]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[k]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    elif operator == 'swap':\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.913712913828576,
            5.664520875373089
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and edge uniqueness, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge crossover while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    edge_uniqueness = []\n    for sol in solutions:\n        unique_edges = set()\n        for i in range(len(sol)):\n            edge = tuple(sorted((sol[i], sol[(i+1)%len(sol)])))\n            unique_edges.add(edge)\n        edge_uniqueness.append(len(unique_edges) / len(sol))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.4 + norm_obj2[i] * 0.6) * (1 + random.uniform(-0.1, 0.1)) + edge_uniqueness[i] * 0.5\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'crossover'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'crossover':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n            k = random.randint(0, len(new_solution)-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, k, node)\n\n    return new_solution\n\n",
        "score": [
            7.522435016047099,
            4.606710991677942
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour compactness, then applies a hybrid local search combining adaptive segment reversal, guided edge swapping, and probabilistic node insertion while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    compactness = []\n    for sol in solutions:\n        total_dist1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        total_dist2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        compactness.append(1 / (total_dist1 + total_dist2))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.4 + norm_obj2[i] * 0.6) * (1 + random.uniform(-0.2, 0.2)) + compactness[i] * 0.5\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'swap', 'insert'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = (j + random.randint(1, 3)) % len(new_solution)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.010112816952443,
            4.46337575582037
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure, then applies an adaptive hybrid local search combining a variable-length segment reversal with a guided node relocation strategy, prioritizing segments with high combined cost in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Weighted selection based on normalized objectives\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    if max(obj1) - min(obj1) > 0:\n        norm_obj1 = [(x - min(obj1)) / (max(obj1) - min(obj1)) for x in obj1]\n    else:\n        norm_obj1 = [0.5 for _ in obj1]\n\n    if max(obj2) - min(obj2) > 0:\n        norm_obj2 = [(x - min(obj2)) / (max(obj2) - min(obj2)) for x in obj2]\n    else:\n        norm_obj2 = [0.5 for _ in obj2]\n\n    # Weighted combination (higher weight to better solutions)\n    weights = [0.6 * (1 - norm_obj1[i]) + 0.4 * (1 - norm_obj2[i]) for i in range(len(objectives))]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    k = random.randint(2, min(4, n // 3))\n    indices = sorted(random.sample(range(n), k))\n\n    # Calculate segment costs for both objectives\n    segment_costs = []\n    for i in range(k):\n        start = indices[i]\n        end = indices[(i + 1) % k]\n        if start > end:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        else:\n            segment = new_solution[start:end]\n\n        cost1 = 0\n        cost2 = 0\n        for j in range(len(segment)):\n            node = segment[j]\n            prev_node = segment[j - 1] if j > 0 else new_solution[(start - 1) % n]\n            next_node = segment[(j + 1) % len(segment)] if j < len(segment) - 1 else new_solution[end % n]\n            cost1 += distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 += distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Reverse segments with highest combined cost\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n    for cost, start, end in segment_costs[:max(1, k // 2)]:\n        if start > end:\n            segment = new_solution[start:][::-1]\n            new_solution[start:] = segment\n            segment = new_solution[:end][::-1]\n            new_solution[:end] = segment\n        else:\n            segment = new_solution[start:end][::-1]\n            new_solution[start:end] = segment\n\n    # Enhanced guided node relocation\n    for _ in range(3):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        relocate_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n            if total_cost > max_cost:\n                max_cost = total_cost\n                relocate_node = i\n\n        if relocate_node != -1:\n            # Remove the node and find best insertion point\n            node_to_relocate = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n - 1):\n                # Calculate weighted cost of inserting between i and i+1\n                cost1 = distance_matrix_1[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_1[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                cost2 = distance_matrix_2[node_to_relocate, new_solution[i]] + \\\n                       distance_matrix_2[node_to_relocate, new_solution[(i + 1) % (n - 1)]]\n                total_cost = 0.7 * cost1 + 0.3 * cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = i + 1\n\n            new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.273941231814126,
            6.959288926797407
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.35176615871521,
            6.49653100991086
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.659915351132185,
            7.56361718481337
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment inversion with a probabilistic node relocation strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['invert', 'relocate'])\n\n    if operator == 'invert':\n        # Segment inversion with bi-objective validation\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Check if inversion improves at least one objective\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'relocate':\n        # Probabilistic node relocation with bi-objective validation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate original and new costs for both objectives\n            original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n            original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Perform relocation\n                node = new_solution[a]\n                new_solution = np.delete(new_solution, a)\n                new_solution = np.insert(new_solution, b, node)\n\n    return new_solution\n\n",
        "score": [
            5.786380068769446,
            5.774351627883826
        ]
    }
]